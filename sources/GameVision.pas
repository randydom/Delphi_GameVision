{==============================================================================
   ___              __   ___    _
  / __|__ _ _ __  __\ \ / (_)__(_)___ _ _
 | (_ / _` | '  \/ -_) V /| (_-< / _ \ ' \
  \___\__,_|_|_|_\___|\_/ |_/__/_\___/_||_|
                  Toolkit™

 Copyright © 2022 tinyBigGAMES™ LLC
 All Rights Reserved.

 Website: https://tinybiggames.com
 Email  : support@tinybiggames.com

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software in
   a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

2. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

3. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

4. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

5. All video, audio, graphics and other content accessed through the
   software in this distro is the property of the applicable content owner
   and may be protected by applicable copyright law. This License gives
   Customer no rights to such content, and Company disclaims any liability
   for misuse of content.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
============================================================================= }

{$WARN SYMBOL_DEPRECATED OFF}
{$WARN SYMBOL_PLATFORM OFF}

{$WARN UNIT_PLATFORM OFF}
{$WARN UNIT_DEPRECATED OFF}

{$Z4}
{$A8}

{$INLINE AUTO}

{$SCOPEDENUMS ON}

{$IFNDEF WIN64}
  {$MESSAGE Error 'Unsupported platform'}
{$ENDIF}

unit GameVision;

interface

uses
  System.Generics.Collections,
  System.SysUtils,
  System.Classes,
  System.IniFiles,
  System.Variants,
  System.SyncObjs,
  Vcl.OleServer,
  WinApi.Windows,
  Winapi.ActiveX;

{$REGION '  === CLIBS ================================================================='}
const
  ALLEGRO_UNSTABLE = 1;
  INT32_MIN = (-2147483647-1);
  _ALLEGRO_UNSTABLE_BIT_SET = INT32_MIN;
  ALLEGRO_VERSION = 5;
  ALLEGRO_SUB_VERSION = 2;
  ALLEGRO_WIP_VERSION = 8;
  ALLEGRO_UNSTABLE_BIT = _ALLEGRO_UNSTABLE_BIT_SET;
  ALLEGRO_RELEASE_NUMBER = 0;
  ALLEGRO_VERSION_STR = '5.2.8 (GIT)';
  ALLEGRO_DATE_STR = '2021';
  ALLEGRO_DATE = 20210307;
  ALLEGRO_VERSION_INT = ((ALLEGRO_VERSION shl 24) or (ALLEGRO_SUB_VERSION shl 16) or (ALLEGRO_WIP_VERSION shl 8) or ALLEGRO_RELEASE_NUMBER or ALLEGRO_UNSTABLE_BIT);
  ALLEGRO_PI = 3.14159265358979323846;
  ALLEGRO_NATIVE_PATH_SEP = '\';
  ALLEGRO_NATIVE_DRIVE_SEP = ':';
  ALLEGRO_NEW_WINDOW_TITLE_MAX_SIZE = 255;
  EOF = (-1);
  _AL_MAX_JOYSTICK_AXES = 3;
  _AL_MAX_JOYSTICK_STICKS = 16;
  _AL_MAX_JOYSTICK_BUTTONS = 32;
  ALLEGRO_MOUSE_MAX_EXTRA_AXES = 4;
  ALLEGRO_TOUCH_INPUT_MAX_TOUCH_COUNT = 16;
  ALLEGRO_SHADER_VAR_COLOR = 'al_color';
  ALLEGRO_SHADER_VAR_POS = 'al_pos';
  ALLEGRO_SHADER_VAR_PROJVIEW_MATRIX = 'al_projview_matrix';
  ALLEGRO_SHADER_VAR_TEX = 'al_tex';
  ALLEGRO_SHADER_VAR_TEXCOORD = 'al_texcoord';
  ALLEGRO_SHADER_VAR_TEX_MATRIX = 'al_tex_matrix';
  ALLEGRO_SHADER_VAR_USER_ATTR = 'al_user_attr_';
  ALLEGRO_SHADER_VAR_USE_TEX = 'al_use_tex';
  ALLEGRO_SHADER_VAR_USE_TEX_MATRIX = 'al_use_tex_matrix';
  ALLEGRO_SHADER_VAR_ALPHA_TEST = 'al_alpha_test';
  ALLEGRO_SHADER_VAR_ALPHA_FUNCTION = 'al_alpha_func';
  ALLEGRO_SHADER_VAR_ALPHA_TEST_VALUE = 'al_alpha_test_val';
  ALLEGRO_MAX_CHANNELS = 8;
  ALLEGRO_AUDIO_PAN_NONE = (-1000.0);
  ALLEGRO_VERTEX_CACHE_SIZE = 256;
  ALLEGRO_PRIM_QUALITY = 10;
  ALLEGRO_TTF_NO_KERNING = 1;
  ALLEGRO_TTF_MONOCHROME = 2;
  ALLEGRO_TTF_NO_AUTOHINT = 4;
  Z_DEFLATED = 8;
  Z_DEFAULT_STRATEGY = 0;
  APPEND_STATUS_CREATE = 0;
  Z_OK = 0;
  NK_UNDEFINED = (-1.0);
  NK_UTF_INVALID = $FFFD;
  NK_UTF_SIZE = 4;
  NK_INPUT_MAX = 16;
  NK_MAX_NUMBER_BUFFER = 64;
  NK_SCROLLBAR_HIDING_TIMEOUT = 4.0;
  NK_TEXTEDIT_UNDOSTATECOUNT = 99;
  NK_TEXTEDIT_UNDOCHARCOUNT = 999;
  NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS = 16;
  NK_CHART_MAX_SLOT = 4;
  NK_WINDOW_MAX_NAME = 64;
  NK_BUTTON_BEHAVIOR_STACK_SIZE = 8;
  NK_FONT_STACK_SIZE = 8;
  NK_STYLE_ITEM_STACK_SIZE = 16;
  NK_FLOAT_STACK_SIZE = 32;
  NK_VECTOR_STACK_SIZE = 16;
  NK_FLAGS_STACK_SIZE = 32;
  NK_COLOR_STACK_SIZE = 32;
  NK_PI = 3.141592654;
  NK_MAX_FLOAT_PRECISION = 2;

  ALLEGRO_PIXEL_FORMAT_ANY = 0;
  ALLEGRO_PIXEL_FORMAT_ANY_NO_ALPHA = 1;
  ALLEGRO_PIXEL_FORMAT_ANY_WITH_ALPHA = 2;
  ALLEGRO_PIXEL_FORMAT_ANY_15_NO_ALPHA = 3;
  ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA = 4;
  ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA = 5;
  ALLEGRO_PIXEL_FORMAT_ANY_24_NO_ALPHA = 6;
  ALLEGRO_PIXEL_FORMAT_ANY_32_NO_ALPHA = 7;
  ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA = 8;
  ALLEGRO_PIXEL_FORMAT_ARGB_8888 = 9;
  ALLEGRO_PIXEL_FORMAT_RGBA_8888 = 10;
  ALLEGRO_PIXEL_FORMAT_ARGB_4444 = 11;
  ALLEGRO_PIXEL_FORMAT_RGB_888 = 12;
  ALLEGRO_PIXEL_FORMAT_RGB_565 = 13;
  ALLEGRO_PIXEL_FORMAT_RGB_555 = 14;
  ALLEGRO_PIXEL_FORMAT_RGBA_5551 = 15;
  ALLEGRO_PIXEL_FORMAT_ARGB_1555 = 16;
  ALLEGRO_PIXEL_FORMAT_ABGR_8888 = 17;
  ALLEGRO_PIXEL_FORMAT_XBGR_8888 = 18;
  ALLEGRO_PIXEL_FORMAT_BGR_888 = 19;
  ALLEGRO_PIXEL_FORMAT_BGR_565 = 20;
  ALLEGRO_PIXEL_FORMAT_BGR_555 = 21;
  ALLEGRO_PIXEL_FORMAT_RGBX_8888 = 22;
  ALLEGRO_PIXEL_FORMAT_XRGB_8888 = 23;
  ALLEGRO_PIXEL_FORMAT_ABGR_F32 = 24;
  ALLEGRO_PIXEL_FORMAT_ABGR_8888_LE = 25;
  ALLEGRO_PIXEL_FORMAT_RGBA_4444 = 26;
  ALLEGRO_PIXEL_FORMAT_SINGLE_CHANNEL_8 = 27;
  ALLEGRO_PIXEL_FORMAT_COMPRESSED_RGBA_DXT1 = 28;
  ALLEGRO_PIXEL_FORMAT_COMPRESSED_RGBA_DXT3 = 29;
  ALLEGRO_PIXEL_FORMAT_COMPRESSED_RGBA_DXT5 = 30;
  ALLEGRO_NUM_PIXEL_FORMATS = 31;

  ALLEGRO_BITMAP_WRAP_DEFAULT = 0;
  ALLEGRO_BITMAP_WRAP_REPEAT = 1;
  ALLEGRO_BITMAP_WRAP_CLAMP = 2;
  ALLEGRO_BITMAP_WRAP_MIRROR = 3;

  ALLEGRO_MEMORY_BITMAP = 1;
  _ALLEGRO_KEEP_BITMAP_FORMAT = 2;
  ALLEGRO_FORCE_LOCKING = 4;
  ALLEGRO_NO_PRESERVE_TEXTURE = 8;
  _ALLEGRO_ALPHA_TEST = 16;
  _ALLEGRO_INTERNAL_OPENGL = 32;
  ALLEGRO_MIN_LINEAR = 64;
  ALLEGRO_MAG_LINEAR = 128;
  ALLEGRO_MIPMAP = 256;
  _ALLEGRO_NO_PREMULTIPLIED_ALPHA = 512;
  ALLEGRO_VIDEO_BITMAP = 1024;
  ALLEGRO_CONVERT_BITMAP = 4096;

  ALLEGRO_FLIP_HORIZONTAL = 1;
  ALLEGRO_FLIP_VERTICAL = 2;

  ALLEGRO_SEEK_SET = 0;
  ALLEGRO_SEEK_CUR = 1;
  ALLEGRO_SEEK_END = 2;

  ALLEGRO_KEEP_BITMAP_FORMAT = 2;
  ALLEGRO_NO_PREMULTIPLIED_ALPHA = 512;
  ALLEGRO_KEEP_INDEX = 2048;

  ALLEGRO_LOCK_READWRITE = 0;
  ALLEGRO_LOCK_READONLY = 1;
  ALLEGRO_LOCK_WRITEONLY = 2;

  ALLEGRO_ZERO = 0;
  ALLEGRO_ONE = 1;
  ALLEGRO_ALPHA = 2;
  ALLEGRO_INVERSE_ALPHA = 3;
  ALLEGRO_SRC_COLOR = 4;
  ALLEGRO_DEST_COLOR = 5;
  ALLEGRO_INVERSE_SRC_COLOR = 6;
  ALLEGRO_INVERSE_DEST_COLOR = 7;
  ALLEGRO_CONST_COLOR = 8;
  ALLEGRO_INVERSE_CONST_COLOR = 9;
  ALLEGRO_NUM_BLEND_MODES = 10;

  ALLEGRO_ADD = 0;
  ALLEGRO_SRC_MINUS_DEST = 1;
  ALLEGRO_DEST_MINUS_SRC = 2;
  ALLEGRO_NUM_BLEND_OPERATIONS = 3;

  ALLEGRO_EVENT_JOYSTICK_AXIS = 1;
  ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN = 2;
  ALLEGRO_EVENT_JOYSTICK_BUTTON_UP = 3;
  ALLEGRO_EVENT_JOYSTICK_CONFIGURATION = 4;
  ALLEGRO_EVENT_KEY_DOWN = 10;
  ALLEGRO_EVENT_KEY_CHAR = 11;
  ALLEGRO_EVENT_KEY_UP = 12;
  ALLEGRO_EVENT_MOUSE_AXES = 20;
  ALLEGRO_EVENT_MOUSE_BUTTON_DOWN = 21;
  ALLEGRO_EVENT_MOUSE_BUTTON_UP = 22;
  ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY = 23;
  ALLEGRO_EVENT_MOUSE_LEAVE_DISPLAY = 24;
  ALLEGRO_EVENT_MOUSE_WARPED = 25;
  ALLEGRO_EVENT_TIMER = 30;
  ALLEGRO_EVENT_DISPLAY_EXPOSE = 40;
  ALLEGRO_EVENT_DISPLAY_RESIZE = 41;
  ALLEGRO_EVENT_DISPLAY_CLOSE = 42;
  ALLEGRO_EVENT_DISPLAY_LOST = 43;
  ALLEGRO_EVENT_DISPLAY_FOUND = 44;
  ALLEGRO_EVENT_DISPLAY_SWITCH_IN = 45;
  ALLEGRO_EVENT_DISPLAY_SWITCH_OUT = 46;
  ALLEGRO_EVENT_DISPLAY_ORIENTATION = 47;
  ALLEGRO_EVENT_DISPLAY_HALT_DRAWING = 48;
  ALLEGRO_EVENT_DISPLAY_RESUME_DRAWING = 49;
  ALLEGRO_EVENT_TOUCH_BEGIN = 50;
  ALLEGRO_EVENT_TOUCH_END = 51;
  ALLEGRO_EVENT_TOUCH_MOVE = 52;
  ALLEGRO_EVENT_TOUCH_CANCEL = 53;
  ALLEGRO_EVENT_DISPLAY_CONNECTED = 60;
  ALLEGRO_EVENT_DISPLAY_DISCONNECTED = 61;

  ALLEGRO_WINDOWED = 1;
  ALLEGRO_FULLSCREEN = 2;
  ALLEGRO_OPENGL = 4;
  ALLEGRO_DIRECT3D_INTERNAL = 8;
  ALLEGRO_RESIZABLE = 16;
  ALLEGRO_FRAMELESS = 32;
  ALLEGRO_NOFRAME = 32;
  ALLEGRO_GENERATE_EXPOSE_EVENTS = 64;
  ALLEGRO_OPENGL_3_0 = 128;
  ALLEGRO_OPENGL_FORWARD_COMPATIBLE = 256;
  ALLEGRO_FULLSCREEN_WINDOW = 512;
  ALLEGRO_MINIMIZED = 1024;
  ALLEGRO_PROGRAMMABLE_PIPELINE = 2048;
  ALLEGRO_GTK_TOPLEVEL_INTERNAL = 4096;
  ALLEGRO_MAXIMIZED = 8192;
  ALLEGRO_OPENGL_ES_PROFILE = 16384;
  ALLEGRO_OPENGL_CORE_PROFILE = 32768;

  ALLEGRO_RED_SIZE = 0;
  ALLEGRO_GREEN_SIZE = 1;
  ALLEGRO_BLUE_SIZE = 2;
  ALLEGRO_ALPHA_SIZE = 3;
  ALLEGRO_RED_SHIFT = 4;
  ALLEGRO_GREEN_SHIFT = 5;
  ALLEGRO_BLUE_SHIFT = 6;
  ALLEGRO_ALPHA_SHIFT = 7;
  ALLEGRO_ACC_RED_SIZE = 8;
  ALLEGRO_ACC_GREEN_SIZE = 9;
  ALLEGRO_ACC_BLUE_SIZE = 10;
  ALLEGRO_ACC_ALPHA_SIZE = 11;
  ALLEGRO_STEREO = 12;
  ALLEGRO_AUX_BUFFERS = 13;
  ALLEGRO_COLOR_SIZE = 14;
  ALLEGRO_DEPTH_SIZE = 15;
  ALLEGRO_STENCIL_SIZE = 16;
  ALLEGRO_SAMPLE_BUFFERS = 17;
  ALLEGRO_SAMPLES = 18;
  ALLEGRO_RENDER_METHOD = 19;
  ALLEGRO_FLOAT_COLOR = 20;
  ALLEGRO_FLOAT_DEPTH = 21;
  ALLEGRO_SINGLE_BUFFER = 22;
  ALLEGRO_SWAP_METHOD = 23;
  ALLEGRO_COMPATIBLE_DISPLAY = 24;
  ALLEGRO_UPDATE_DISPLAY_REGION = 25;
  ALLEGRO_VSYNC = 26;
  ALLEGRO_MAX_BITMAP_SIZE = 27;
  ALLEGRO_SUPPORT_NPOT_BITMAP = 28;
  ALLEGRO_CAN_DRAW_INTO_BITMAP = 29;
  ALLEGRO_SUPPORT_SEPARATE_ALPHA = 30;
  ALLEGRO_AUTO_CONVERT_BITMAPS = 31;
  ALLEGRO_SUPPORTED_ORIENTATIONS = 32;
  ALLEGRO_OPENGL_MAJOR_VERSION = 33;
  ALLEGRO_OPENGL_MINOR_VERSION = 34;
  ALLEGRO_DEFAULT_SHADER_PLATFORM = 35;
  ALLEGRO_DISPLAY_OPTIONS_COUNT = 36;

  ALLEGRO_DONTCARE = 0;
  ALLEGRO_REQUIRE = 1;
  ALLEGRO_SUGGEST = 2;

  ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN = 0;
  ALLEGRO_DISPLAY_ORIENTATION_0_DEGREES = 1;
  ALLEGRO_DISPLAY_ORIENTATION_90_DEGREES = 2;
  ALLEGRO_DISPLAY_ORIENTATION_180_DEGREES = 4;
  ALLEGRO_DISPLAY_ORIENTATION_270_DEGREES = 8;
  ALLEGRO_DISPLAY_ORIENTATION_PORTRAIT = 5;
  ALLEGRO_DISPLAY_ORIENTATION_LANDSCAPE = 10;
  ALLEGRO_DISPLAY_ORIENTATION_ALL = 15;
  ALLEGRO_DISPLAY_ORIENTATION_FACE_UP = 16;
  ALLEGRO_DISPLAY_ORIENTATION_FACE_DOWN = 32;

  _ALLEGRO_PRIM_MAX_USER_ATTR = 10;

  ALLEGRO_FILEMODE_READ = 1;
  ALLEGRO_FILEMODE_WRITE = 2;
  ALLEGRO_FILEMODE_EXECUTE = 4;
  ALLEGRO_FILEMODE_HIDDEN = 8;
  ALLEGRO_FILEMODE_ISFILE = 16;
  ALLEGRO_FILEMODE_ISDIR = 32;

  ALLEGRO_FOR_EACH_FS_ENTRY_ERROR = -1;
  ALLEGRO_FOR_EACH_FS_ENTRY_OK = 0;
  ALLEGRO_FOR_EACH_FS_ENTRY_SKIP = 1;
  ALLEGRO_FOR_EACH_FS_ENTRY_STOP = 2;

  ALLEGRO_JOYFLAG_DIGITAL = 1;
  ALLEGRO_JOYFLAG_ANALOGUE = 2;

  ALLEGRO_KEY_A = 1;
  ALLEGRO_KEY_B = 2;
  ALLEGRO_KEY_C = 3;
  ALLEGRO_KEY_D = 4;
  ALLEGRO_KEY_E = 5;
  ALLEGRO_KEY_F = 6;
  ALLEGRO_KEY_G = 7;
  ALLEGRO_KEY_H = 8;
  ALLEGRO_KEY_I = 9;
  ALLEGRO_KEY_J = 10;
  ALLEGRO_KEY_K = 11;
  ALLEGRO_KEY_L = 12;
  ALLEGRO_KEY_M = 13;
  ALLEGRO_KEY_N = 14;
  ALLEGRO_KEY_O = 15;
  ALLEGRO_KEY_P = 16;
  ALLEGRO_KEY_Q = 17;
  ALLEGRO_KEY_R = 18;
  ALLEGRO_KEY_S = 19;
  ALLEGRO_KEY_T = 20;
  ALLEGRO_KEY_U = 21;
  ALLEGRO_KEY_V = 22;
  ALLEGRO_KEY_W = 23;
  ALLEGRO_KEY_X = 24;
  ALLEGRO_KEY_Y = 25;
  ALLEGRO_KEY_Z = 26;
  ALLEGRO_KEY_0 = 27;
  ALLEGRO_KEY_1 = 28;
  ALLEGRO_KEY_2 = 29;
  ALLEGRO_KEY_3 = 30;
  ALLEGRO_KEY_4 = 31;
  ALLEGRO_KEY_5 = 32;
  ALLEGRO_KEY_6 = 33;
  ALLEGRO_KEY_7 = 34;
  ALLEGRO_KEY_8 = 35;
  ALLEGRO_KEY_9 = 36;
  ALLEGRO_KEY_PAD_0 = 37;
  ALLEGRO_KEY_PAD_1 = 38;
  ALLEGRO_KEY_PAD_2 = 39;
  ALLEGRO_KEY_PAD_3 = 40;
  ALLEGRO_KEY_PAD_4 = 41;
  ALLEGRO_KEY_PAD_5 = 42;
  ALLEGRO_KEY_PAD_6 = 43;
  ALLEGRO_KEY_PAD_7 = 44;
  ALLEGRO_KEY_PAD_8 = 45;
  ALLEGRO_KEY_PAD_9 = 46;
  ALLEGRO_KEY_F1 = 47;
  ALLEGRO_KEY_F2 = 48;
  ALLEGRO_KEY_F3 = 49;
  ALLEGRO_KEY_F4 = 50;
  ALLEGRO_KEY_F5 = 51;
  ALLEGRO_KEY_F6 = 52;
  ALLEGRO_KEY_F7 = 53;
  ALLEGRO_KEY_F8 = 54;
  ALLEGRO_KEY_F9 = 55;
  ALLEGRO_KEY_F10 = 56;
  ALLEGRO_KEY_F11 = 57;
  ALLEGRO_KEY_F12 = 58;
  ALLEGRO_KEY_ESCAPE = 59;
  ALLEGRO_KEY_TILDE = 60;
  ALLEGRO_KEY_MINUS = 61;
  ALLEGRO_KEY_EQUALS = 62;
  ALLEGRO_KEY_BACKSPACE = 63;
  ALLEGRO_KEY_TAB = 64;
  ALLEGRO_KEY_OPENBRACE = 65;
  ALLEGRO_KEY_CLOSEBRACE = 66;
  ALLEGRO_KEY_ENTER = 67;
  ALLEGRO_KEY_SEMICOLON = 68;
  ALLEGRO_KEY_QUOTE = 69;
  ALLEGRO_KEY_BACKSLASH = 70;
  ALLEGRO_KEY_BACKSLASH2 = 71;
  ALLEGRO_KEY_COMMA = 72;
  ALLEGRO_KEY_FULLSTOP = 73;
  ALLEGRO_KEY_SLASH = 74;
  ALLEGRO_KEY_SPACE = 75;
  ALLEGRO_KEY_INSERT = 76;
  ALLEGRO_KEY_DELETE = 77;
  ALLEGRO_KEY_HOME = 78;
  ALLEGRO_KEY_END = 79;
  ALLEGRO_KEY_PGUP = 80;
  ALLEGRO_KEY_PGDN = 81;
  ALLEGRO_KEY_LEFT = 82;
  ALLEGRO_KEY_RIGHT = 83;
  ALLEGRO_KEY_UP = 84;
  ALLEGRO_KEY_DOWN = 85;
  ALLEGRO_KEY_PAD_SLASH = 86;
  ALLEGRO_KEY_PAD_ASTERISK = 87;
  ALLEGRO_KEY_PAD_MINUS = 88;
  ALLEGRO_KEY_PAD_PLUS = 89;
  ALLEGRO_KEY_PAD_DELETE = 90;
  ALLEGRO_KEY_PAD_ENTER = 91;
  ALLEGRO_KEY_PRINTSCREEN = 92;
  ALLEGRO_KEY_PAUSE = 93;
  ALLEGRO_KEY_ABNT_C1 = 94;
  ALLEGRO_KEY_YEN = 95;
  ALLEGRO_KEY_KANA = 96;
  ALLEGRO_KEY_CONVERT = 97;
  ALLEGRO_KEY_NOCONVERT = 98;
  ALLEGRO_KEY_AT = 99;
  ALLEGRO_KEY_CIRCUMFLEX = 100;
  ALLEGRO_KEY_COLON2 = 101;
  ALLEGRO_KEY_KANJI = 102;
  ALLEGRO_KEY_PAD_EQUALS = 103;
  ALLEGRO_KEY_BACKQUOTE = 104;
  ALLEGRO_KEY_SEMICOLON2 = 105;
  ALLEGRO_KEY_COMMAND = 106;
  ALLEGRO_KEY_BACK = 107;
  ALLEGRO_KEY_VOLUME_UP = 108;
  ALLEGRO_KEY_VOLUME_DOWN = 109;
  ALLEGRO_KEY_SEARCH = 110;
  ALLEGRO_KEY_DPAD_CENTER = 111;
  ALLEGRO_KEY_BUTTON_X = 112;
  ALLEGRO_KEY_BUTTON_Y = 113;
  ALLEGRO_KEY_DPAD_UP = 114;
  ALLEGRO_KEY_DPAD_DOWN = 115;
  ALLEGRO_KEY_DPAD_LEFT = 116;
  ALLEGRO_KEY_DPAD_RIGHT = 117;
  ALLEGRO_KEY_SELECT = 118;
  ALLEGRO_KEY_START = 119;
  ALLEGRO_KEY_BUTTON_L1 = 120;
  ALLEGRO_KEY_BUTTON_R1 = 121;
  ALLEGRO_KEY_BUTTON_L2 = 122;
  ALLEGRO_KEY_BUTTON_R2 = 123;
  ALLEGRO_KEY_BUTTON_A = 124;
  ALLEGRO_KEY_BUTTON_B = 125;
  ALLEGRO_KEY_THUMBL = 126;
  ALLEGRO_KEY_THUMBR = 127;
  ALLEGRO_KEY_UNKNOWN = 128;
  ALLEGRO_KEY_MODIFIERS = 215;
  ALLEGRO_KEY_LSHIFT = 215;
  ALLEGRO_KEY_RSHIFT = 216;
  ALLEGRO_KEY_LCTRL = 217;
  ALLEGRO_KEY_RCTRL = 218;
  ALLEGRO_KEY_ALT = 219;
  ALLEGRO_KEY_ALTGR = 220;
  ALLEGRO_KEY_LWIN = 221;
  ALLEGRO_KEY_RWIN = 222;
  ALLEGRO_KEY_MENU = 223;
  ALLEGRO_KEY_SCROLLLOCK = 224;
  ALLEGRO_KEY_NUMLOCK = 225;
  ALLEGRO_KEY_CAPSLOCK = 226;
  ALLEGRO_KEY_MAX = 227;

  ALLEGRO_KEYMOD_SHIFT = 1;
  ALLEGRO_KEYMOD_CTRL = 2;
  ALLEGRO_KEYMOD_ALT = 4;
  ALLEGRO_KEYMOD_LWIN = 8;
  ALLEGRO_KEYMOD_RWIN = 16;
  ALLEGRO_KEYMOD_MENU = 32;
  ALLEGRO_KEYMOD_ALTGR = 64;
  ALLEGRO_KEYMOD_COMMAND = 128;
  ALLEGRO_KEYMOD_SCROLLLOCK = 256;
  ALLEGRO_KEYMOD_NUMLOCK = 512;
  ALLEGRO_KEYMOD_CAPSLOCK = 1024;
  ALLEGRO_KEYMOD_INALTSEQ = 2048;
  ALLEGRO_KEYMOD_ACCENT1 = 4096;
  ALLEGRO_KEYMOD_ACCENT2 = 8192;
  ALLEGRO_KEYMOD_ACCENT3 = 16384;
  ALLEGRO_KEYMOD_ACCENT4 = 32768;

  ALLEGRO_MOUSE_EMULATION_NONE = 0;
  ALLEGRO_MOUSE_EMULATION_TRANSPARENT = 1;
  ALLEGRO_MOUSE_EMULATION_INCLUSIVE = 2;
  ALLEGRO_MOUSE_EMULATION_EXCLUSIVE = 3;
  ALLEGRO_MOUSE_EMULATION_5_0_x = 4;

  ALLEGRO_HAPTIC_RUMBLE = 1;
  ALLEGRO_HAPTIC_PERIODIC = 2;
  ALLEGRO_HAPTIC_CONSTANT = 4;
  ALLEGRO_HAPTIC_SPRING = 8;
  ALLEGRO_HAPTIC_FRICTION = 16;
  ALLEGRO_HAPTIC_DAMPER = 32;
  ALLEGRO_HAPTIC_INERTIA = 64;
  ALLEGRO_HAPTIC_RAMP = 128;
  ALLEGRO_HAPTIC_SQUARE = 256;
  ALLEGRO_HAPTIC_TRIANGLE = 512;
  ALLEGRO_HAPTIC_SINE = 1024;
  ALLEGRO_HAPTIC_SAW_UP = 2048;
  ALLEGRO_HAPTIC_SAW_DOWN = 4096;
  ALLEGRO_HAPTIC_CUSTOM = 8192;
  ALLEGRO_HAPTIC_GAIN = 16384;
  ALLEGRO_HAPTIC_ANGLE = 32768;
  ALLEGRO_HAPTIC_RADIUS = 65536;
  ALLEGRO_HAPTIC_AZIMUTH = 131072;
  ALLEGRO_HAPTIC_AUTOCENTER = 262144;

  ALLEGRO_DEFAULT_DISPLAY_ADAPTER = -1;

  ALLEGRO_SYSTEM_MOUSE_CURSOR_NONE = 0;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_DEFAULT = 1;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_ARROW = 2;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_BUSY = 3;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_QUESTION = 4;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_EDIT = 5;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_MOVE = 6;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_N = 7;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_W = 8;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_S = 9;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_E = 10;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_NW = 11;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_SW = 12;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_SE = 13;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_NE = 14;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_PROGRESS = 15;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_PRECISION = 16;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_LINK = 17;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_ALT_SELECT = 18;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_UNAVAILABLE = 19;
  ALLEGRO_NUM_SYSTEM_MOUSE_CURSORS = 20;

  ALLEGRO_ALPHA_TEST = 16;
  ALLEGRO_WRITE_MASK = 17;
  ALLEGRO_DEPTH_TEST = 18;
  ALLEGRO_DEPTH_FUNCTION = 19;
  ALLEGRO_ALPHA_FUNCTION = 20;
  ALLEGRO_ALPHA_TEST_VALUE = 21;

  ALLEGRO_RENDER_NEVER = 0;
  ALLEGRO_RENDER_ALWAYS = 1;
  ALLEGRO_RENDER_LESS = 2;
  ALLEGRO_RENDER_EQUAL = 3;
  ALLEGRO_RENDER_LESS_EQUAL = 4;
  ALLEGRO_RENDER_GREATER = 5;
  ALLEGRO_RENDER_NOT_EQUAL = 6;
  ALLEGRO_RENDER_GREATER_EQUAL = 7;

  ALLEGRO_MASK_RED = 1;
  ALLEGRO_MASK_GREEN = 2;
  ALLEGRO_MASK_BLUE = 4;
  ALLEGRO_MASK_ALPHA = 8;
  ALLEGRO_MASK_DEPTH = 16;
  ALLEGRO_MASK_RGB = 7;
  ALLEGRO_MASK_RGBA = 15;

  ALLEGRO_VERTEX_SHADER = 1;
  ALLEGRO_PIXEL_SHADER = 2;

  ALLEGRO_SHADER_AUTO = 0;
  ALLEGRO_SHADER_GLSL = 1;
  ALLEGRO_SHADER_HLSL = 2;
  ALLEGRO_SHADER_AUTO_MINIMAL = 3;
  ALLEGRO_SHADER_GLSL_MINIMAL = 4;
  ALLEGRO_SHADER_HLSL_MINIMAL = 5;
  ALLEGRO_SHADER_HLSL_SM_3_0 = 6;

  ALLEGRO_SYSTEM_ID_UNKNOWN = 0;
  ALLEGRO_SYSTEM_ID_XGLX = 1481067608;
  ALLEGRO_SYSTEM_ID_WINDOWS = 1464421956;
  ALLEGRO_SYSTEM_ID_MACOSX = 1330862112;
  ALLEGRO_SYSTEM_ID_ANDROID = 1095648338;
  ALLEGRO_SYSTEM_ID_IPHONE = 1229998159;
  ALLEGRO_SYSTEM_ID_GP2XWIZ = 1464424992;
  ALLEGRO_SYSTEM_ID_RASPBERRYPI = 1380012880;
  ALLEGRO_SYSTEM_ID_SDL = 1396984882;

  ALLEGRO_RESOURCES_PATH = 0;
  ALLEGRO_TEMP_PATH = 1;
  ALLEGRO_USER_DATA_PATH = 2;
  ALLEGRO_USER_HOME_PATH = 3;
  ALLEGRO_USER_SETTINGS_PATH = 4;
  ALLEGRO_USER_DOCUMENTS_PATH = 5;
  ALLEGRO_EXENAME_PATH = 6;
  ALLEGRO_LAST_PATH = 7;

  ALLEGRO_STATE_NEW_DISPLAY_PARAMETERS = 1;
  ALLEGRO_STATE_NEW_BITMAP_PARAMETERS = 2;
  ALLEGRO_STATE_DISPLAY = 4;
  ALLEGRO_STATE_TARGET_BITMAP = 8;
  ALLEGRO_STATE_BLENDER = 16;
  ALLEGRO_STATE_NEW_FILE_INTERFACE = 32;
  ALLEGRO_STATE_TRANSFORM = 64;
  ALLEGRO_STATE_PROJECTION_TRANSFORM = 256;
  ALLEGRO_STATE_BITMAP = 10;
  ALLEGRO_STATE_ALL = 65535;

  _KCM_STREAM_FEEDER_QUIT_EVENT_TYPE = 512;
  ALLEGRO_EVENT_AUDIO_STREAM_FRAGMENT = 513;
  ALLEGRO_EVENT_AUDIO_STREAM_FINISHED = 514;
  ALLEGRO_EVENT_AUDIO_RECORDER_FRAGMENT = 515;

  ALLEGRO_AUDIO_DEPTH_INT8 = 0;
  ALLEGRO_AUDIO_DEPTH_INT16 = 1;
  ALLEGRO_AUDIO_DEPTH_INT24 = 2;
  ALLEGRO_AUDIO_DEPTH_FLOAT32 = 3;
  ALLEGRO_AUDIO_DEPTH_UNSIGNED = 8;
  ALLEGRO_AUDIO_DEPTH_UINT8 = 8;
  ALLEGRO_AUDIO_DEPTH_UINT16 = 9;
  ALLEGRO_AUDIO_DEPTH_UINT24 = 10;

  ALLEGRO_CHANNEL_CONF_1 = 16;
  ALLEGRO_CHANNEL_CONF_2 = 32;
  ALLEGRO_CHANNEL_CONF_3 = 48;
  ALLEGRO_CHANNEL_CONF_4 = 64;
  ALLEGRO_CHANNEL_CONF_5_1 = 81;
  ALLEGRO_CHANNEL_CONF_6_1 = 97;
  ALLEGRO_CHANNEL_CONF_7_1 = 113;

  ALLEGRO_PLAYMODE_ONCE = 256;
  ALLEGRO_PLAYMODE_LOOP = 257;
  ALLEGRO_PLAYMODE_BIDIR = 258;
  _ALLEGRO_PLAYMODE_STREAM_ONCE = 259;
  _ALLEGRO_PLAYMODE_STREAM_ONEDIR = 260;
  ALLEGRO_PLAYMODE_LOOP_ONCE = 261;
  _ALLEGRO_PLAYMODE_STREAM_LOOP_ONCE = 262;

  ALLEGRO_MIXER_QUALITY_POINT = 272;
  ALLEGRO_MIXER_QUALITY_LINEAR = 273;
  ALLEGRO_MIXER_QUALITY_CUBIC = 274;

  ALLEGRO_ALIGN_CENTER = 1;
  ALLEGRO_ALIGN_RIGHT = 2;
  ALLEGRO_ALIGN_LEFT = 3;
  ALLEGRO_ALIGN_INTEGER = 4;

  ALLEGRO_FILECHOOSER_PICTURES = 8;
  ALLEGRO_FILECHOOSER_SHOW_HIDDEN = 16;
  ALLEGRO_FILECHOOSER_MULTIPLE = 32;

  ALLEGRO_MESSAGEBOX_WARN = 1;
  ALLEGRO_MESSAGEBOX_ERROR = 2;
  ALLEGRO_MESSAGEBOX_OK_CANCEL = 4;
  ALLEGRO_MESSAGEBOX_YES_NO = 8;
  ALLEGRO_MESSAGEBOX_QUESTION = 16;

  ALLEGRO_TEXTLOG_NO_CLOSE = 1;
  ALLEGRO_TEXTLOG_MONOSPACE = 2;

  ALLEGRO_EVENT_NATIVE_DIALOG_CLOSE = 600;
  ALLEGRO_EVENT_MENU_CLICK = 601;

  ALLEGRO_MENU_ITEM_ENABLED = 0;
  ALLEGRO_MENU_ITEM_CHECKBOX = 1;
  ALLEGRO_MENU_ITEM_CHECKED = 2;
  ALLEGRO_MENU_ITEM_DISABLED = 4;

  ALLEGRO_PRIM_LINE_LIST = 0;
  ALLEGRO_PRIM_LINE_STRIP = 1;
  ALLEGRO_PRIM_LINE_LOOP = 2;
  ALLEGRO_PRIM_TRIANGLE_LIST = 3;
  ALLEGRO_PRIM_TRIANGLE_STRIP = 4;
  ALLEGRO_PRIM_TRIANGLE_FAN = 5;
  ALLEGRO_PRIM_POINT_LIST = 6;
  ALLEGRO_PRIM_NUM_TYPES = 7;

  ALLEGRO_PRIM_MAX_USER_ATTR = 10;

  ALLEGRO_PRIM_POSITION = 1;
  ALLEGRO_PRIM_COLOR_ATTR = 2;
  ALLEGRO_PRIM_TEX_COORD = 3;
  ALLEGRO_PRIM_TEX_COORD_PIXEL = 4;
  ALLEGRO_PRIM_USER_ATTR = 5;
  ALLEGRO_PRIM_ATTR_NUM = 15;

  ALLEGRO_PRIM_FLOAT_2 = 0;
  ALLEGRO_PRIM_FLOAT_3 = 1;
  ALLEGRO_PRIM_SHORT_2 = 2;
  ALLEGRO_PRIM_FLOAT_1 = 3;
  ALLEGRO_PRIM_FLOAT_4 = 4;
  ALLEGRO_PRIM_UBYTE_4 = 5;
  ALLEGRO_PRIM_SHORT_4 = 6;
  ALLEGRO_PRIM_NORMALIZED_UBYTE_4 = 7;
  ALLEGRO_PRIM_NORMALIZED_SHORT_2 = 8;
  ALLEGRO_PRIM_NORMALIZED_SHORT_4 = 9;
  ALLEGRO_PRIM_NORMALIZED_USHORT_2 = 10;
  ALLEGRO_PRIM_NORMALIZED_USHORT_4 = 11;
  ALLEGRO_PRIM_HALF_FLOAT_2 = 12;
  ALLEGRO_PRIM_HALF_FLOAT_4 = 13;

  ALLEGRO_LINE_JOIN_NONE = 0;
  ALLEGRO_LINE_JOIN_BEVEL = 1;
  ALLEGRO_LINE_JOIN_ROUND = 2;
  ALLEGRO_LINE_JOIN_MITER = 3;
  ALLEGRO_LINE_JOIN_MITRE = 3;

  ALLEGRO_LINE_CAP_NONE = 0;
  ALLEGRO_LINE_CAP_SQUARE = 1;
  ALLEGRO_LINE_CAP_ROUND = 2;
  ALLEGRO_LINE_CAP_TRIANGLE = 3;
  ALLEGRO_LINE_CAP_CLOSED = 4;

  ALLEGRO_PRIM_BUFFER_STREAM = 1;
  ALLEGRO_PRIM_BUFFER_STATIC = 2;
  ALLEGRO_PRIM_BUFFER_DYNAMIC = 4;
  ALLEGRO_PRIM_BUFFER_READWRITE = 8;

  ALLEGRO_EVENT_VIDEO_FRAME_SHOW = 550;
  ALLEGRO_EVENT_VIDEO_FINISHED = 551;
  _ALLEGRO_EVENT_VIDEO_SEEK = 552;

  ALLEGRO_VIDEO_POSITION_ACTUAL = 0;
  ALLEGRO_VIDEO_POSITION_VIDEO_DECODE = 1;
  ALLEGRO_VIDEO_POSITION_AUDIO_DECODE = 2;

  nk_false = 0;
  nk_true = 1;

  NK_UP = 0;
  NK_RIGHT = 1;
  NK_DOWN = 2;
  NK_LEFT = 3;

  NK_BUTTON_DEFAULT = 0;
  NK_BUTTON_REPEATER = 1;

  NK_FIXED = 0;
  NK_MODIFIABLE = 1;

  NK_VERTICAL = 0;
  NK_HORIZONTAL = 1;

  NK_MINIMIZED = 0;
  NK_MAXIMIZED = 1;

  NK_HIDDEN = 0;
  NK_SHOWN = 1;

  NK_CHART_LINES = 0;
  NK_CHART_COLUMN = 1;
  NK_CHART_MAX = 2;

  NK_CHART_HOVERING = 1;
  NK_CHART_CLICKED = 2;

  NK_RGB = 0;
  NK_RGBA = 1;

  NK_POPUP_STATIC = 0;
  NK_POPUP_DYNAMIC = 1;

  NK_DYNAMIC = 0;
  NK_STATIC = 1;

  NK_TREE_NODE = 0;
  NK_TREE_TAB = 1;

  NK_SYMBOL_NONE = 0;
  NK_SYMBOL_X = 1;
  NK_SYMBOL_UNDERSCORE = 2;
  NK_SYMBOL_CIRCLE_SOLID = 3;
  NK_SYMBOL_CIRCLE_OUTLINE = 4;
  NK_SYMBOL_RECT_SOLID = 5;
  NK_SYMBOL_RECT_OUTLINE = 6;
  NK_SYMBOL_TRIANGLE_UP = 7;
  NK_SYMBOL_TRIANGLE_DOWN = 8;
  NK_SYMBOL_TRIANGLE_LEFT = 9;
  NK_SYMBOL_TRIANGLE_RIGHT = 10;
  NK_SYMBOL_PLUS = 11;
  NK_SYMBOL_MINUS = 12;
  NK_SYMBOL_MAX = 13;

  NK_KEY_NONE = 0;
  NK_KEY_SHIFT = 1;
  NK_KEY_CTRL = 2;
  NK_KEY_DEL = 3;
  NK_KEY_ENTER = 4;
  NK_KEY_TAB = 5;
  NK_KEY_BACKSPACE = 6;
  NK_KEY_COPY = 7;
  NK_KEY_CUT = 8;
  NK_KEY_PASTE = 9;
  NK_KEY_UP = 10;
  NK_KEY_DOWN = 11;
  NK_KEY_LEFT = 12;
  NK_KEY_RIGHT = 13;
  NK_KEY_TEXT_INSERT_MODE = 14;
  NK_KEY_TEXT_REPLACE_MODE = 15;
  NK_KEY_TEXT_RESET_MODE = 16;
  NK_KEY_TEXT_LINE_START = 17;
  NK_KEY_TEXT_LINE_END = 18;
  NK_KEY_TEXT_START = 19;
  NK_KEY_TEXT_END = 20;
  NK_KEY_TEXT_UNDO = 21;
  NK_KEY_TEXT_REDO = 22;
  NK_KEY_TEXT_SELECT_ALL = 23;
  NK_KEY_TEXT_WORD_LEFT = 24;
  NK_KEY_TEXT_WORD_RIGHT = 25;
  NK_KEY_SCROLL_START = 26;
  NK_KEY_SCROLL_END = 27;
  NK_KEY_SCROLL_DOWN = 28;
  NK_KEY_SCROLL_UP = 29;
  NK_KEY_MAX = 30;

  NK_BUTTON_LEFT = 0;
  NK_BUTTON_MIDDLE = 1;
  NK_BUTTON_RIGHT = 2;
  NK_BUTTON_DOUBLE = 3;
  NK_BUTTON_MAX = 4;

  NK_ANTI_ALIASING_OFF = 0;
  NK_ANTI_ALIASING_ON = 1;

  NK_CONVERT_SUCCESS = 0;
  NK_CONVERT_INVALID_PARAM = 1;
  NK_CONVERT_COMMAND_BUFFER_FULL = 2;
  NK_CONVERT_VERTEX_BUFFER_FULL = 4;
  NK_CONVERT_ELEMENT_BUFFER_FULL = 8;

  NK_WINDOW_BORDER = 1;
  NK_WINDOW_MOVABLE = 2;
  NK_WINDOW_SCALABLE = 4;
  NK_WINDOW_CLOSABLE = 8;
  NK_WINDOW_MINIMIZABLE = 16;
  NK_WINDOW_NO_SCROLLBAR = 32;
  NK_WINDOW_TITLE = 64;
  NK_WINDOW_SCROLL_AUTO_HIDE = 128;
  NK_WINDOW_BACKGROUND = 256;
  NK_WINDOW_SCALE_LEFT = 512;
  NK_WINDOW_NO_INPUT = 1024;

  NK_WIDGET_INVALID = 0;
  NK_WIDGET_VALID = 1;
  NK_WIDGET_ROM = 2;

  NK_WIDGET_STATE_MODIFIED = 2;
  NK_WIDGET_STATE_INACTIVE = 4;
  NK_WIDGET_STATE_ENTERED = 8;
  NK_WIDGET_STATE_HOVER = 16;
  NK_WIDGET_STATE_ACTIVED = 32;
  NK_WIDGET_STATE_LEFT = 64;
  NK_WIDGET_STATE_HOVERED = 18;
  NK_WIDGET_STATE_ACTIVE = 34;

  NK_TEXT_ALIGN_LEFT = 1;
  NK_TEXT_ALIGN_CENTERED = 2;
  NK_TEXT_ALIGN_RIGHT = 4;
  NK_TEXT_ALIGN_TOP = 8;
  NK_TEXT_ALIGN_MIDDLE = 16;
  NK_TEXT_ALIGN_BOTTOM = 32;

  NK_TEXT_LEFT = 17;
  NK_TEXT_CENTERED = 18;
  NK_TEXT_RIGHT = 20;

  NK_EDIT_DEFAULT = 0;
  NK_EDIT_READ_ONLY = 1;
  NK_EDIT_AUTO_SELECT = 2;
  NK_EDIT_SIG_ENTER = 4;
  NK_EDIT_ALLOW_TAB = 8;
  NK_EDIT_NO_CURSOR = 16;
  NK_EDIT_SELECTABLE = 32;
  NK_EDIT_CLIPBOARD = 64;
  NK_EDIT_CTRL_ENTER_NEWLINE = 128;
  NK_EDIT_NO_HORIZONTAL_SCROLL = 256;
  NK_EDIT_ALWAYS_INSERT_MODE = 512;
  NK_EDIT_MULTILINE = 1024;
  NK_EDIT_GOTO_END_ON_ACTIVATE = 2048;

  NK_EDIT_SIMPLE = 512;
  NK_EDIT_FIELD = 608;
  NK_EDIT_BOX = 1640;
  NK_EDIT_EDITOR = 1128;

  NK_EDIT_ACTIVE = 1;
  NK_EDIT_INACTIVE = 2;
  NK_EDIT_ACTIVATED = 4;
  NK_EDIT_DEACTIVATED = 8;
  NK_EDIT_COMMITED = 16;

  NK_COLOR_TEXT = 0;
  NK_COLOR_WINDOW = 1;
  NK_COLOR_HEADER = 2;
  NK_COLOR_BORDER = 3;
  NK_COLOR_BUTTON = 4;
  NK_COLOR_BUTTON_HOVER = 5;
  NK_COLOR_BUTTON_ACTIVE = 6;
  NK_COLOR_TOGGLE = 7;
  NK_COLOR_TOGGLE_HOVER = 8;
  NK_COLOR_TOGGLE_CURSOR = 9;
  NK_COLOR_SELECT = 10;
  NK_COLOR_SELECT_ACTIVE = 11;
  NK_COLOR_SLIDER = 12;
  NK_COLOR_SLIDER_CURSOR = 13;
  NK_COLOR_SLIDER_CURSOR_HOVER = 14;
  NK_COLOR_SLIDER_CURSOR_ACTIVE = 15;
  NK_COLOR_PROPERTY = 16;
  NK_COLOR_EDIT = 17;
  NK_COLOR_EDIT_CURSOR = 18;
  NK_COLOR_COMBO = 19;
  NK_COLOR_CHART = 20;
  NK_COLOR_CHART_COLOR = 21;
  NK_COLOR_CHART_COLOR_HIGHLIGHT = 22;
  NK_COLOR_SCROLLBAR = 23;
  NK_COLOR_SCROLLBAR_CURSOR = 24;
  NK_COLOR_SCROLLBAR_CURSOR_HOVER = 25;
  NK_COLOR_SCROLLBAR_CURSOR_ACTIVE = 26;
  NK_COLOR_TAB_HEADER = 27;
  NK_COLOR_COUNT = 28;

  NK_CURSOR_ARROW = 0;
  NK_CURSOR_TEXT = 1;
  NK_CURSOR_MOVE = 2;
  NK_CURSOR_RESIZE_VERTICAL = 3;
  NK_CURSOR_RESIZE_HORIZONTAL = 4;
  NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT = 5;
  NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT = 6;
  NK_CURSOR_COUNT = 7;

  NK_BUFFER_FIXED = 0;
  NK_BUFFER_DYNAMIC = 1;

  NK_BUFFER_FRONT = 0;
  NK_BUFFER_BACK = 1;
  NK_BUFFER_MAX = 2;

  NK_TEXT_EDIT_SINGLE_LINE = 0;
  NK_TEXT_EDIT_MULTI_LINE = 1;

  NK_TEXT_EDIT_MODE_VIEW = 0;
  NK_TEXT_EDIT_MODE_INSERT = 1;
  NK_TEXT_EDIT_MODE_REPLACE = 2;

  NK_COMMAND_NOP_ = 0;
  NK_COMMAND_SCISSOR_ = 1;
  NK_COMMAND_LINE_ = 2;
  NK_COMMAND_CURVE_ = 3;
  NK_COMMAND_RECT_ = 4;
  NK_COMMAND_RECT_FILLED_ = 5;
  NK_COMMAND_RECT_MULTI_COLOR_ = 6;
  NK_COMMAND_CIRCLE_ = 7;
  NK_COMMAND_CIRCLE_FILLED_ = 8;
  NK_COMMAND_ARC_ = 9;
  NK_COMMAND_ARC_FILLED_ = 10;
  NK_COMMAND_TRIANGLE_ = 11;
  NK_COMMAND_TRIANGLE_FILLED_ = 12;
  NK_COMMAND_POLYGON_ = 13;
  NK_COMMAND_POLYGON_FILLED_ = 14;
  NK_COMMAND_POLYLINE_ = 15;
  NK_COMMAND_TEXT_ = 16;
  NK_COMMAND_IMAGE_ = 17;
  NK_COMMAND_CUSTOM_ = 18;

  NK_CLIPPING_OFF = 0;
  NK_CLIPPING_ON = 1;

  NK_STYLE_ITEM_COLOR = 0;
  NK_STYLE_ITEM_IMAGE = 1;
  NK_STYLE_ITEM_NINE_SLICE = 2;

  NK_HEADER_LEFT = 0;
  NK_HEADER_RIGHT = 1;

  NK_PANEL_NONE = 0;
  NK_PANEL_WINDOW = 1;
  NK_PANEL_GROUP = 2;
  NK_PANEL_POPUP = 4;
  NK_PANEL_CONTEXTUAL = 16;
  NK_PANEL_COMBO = 32;
  NK_PANEL_MENU = 64;
  NK_PANEL_TOOLTIP = 128;

  NK_PANEL_SET_NONBLOCK = 240;
  NK_PANEL_SET_POPUP = 244;
  NK_PANEL_SET_SUB = 246;

  NK_LAYOUT_DYNAMIC_FIXED = 0;
  NK_LAYOUT_DYNAMIC_ROW = 1;
  NK_LAYOUT_DYNAMIC_FREE = 2;
  NK_LAYOUT_DYNAMIC = 3;
  NK_LAYOUT_STATIC_FIXED = 4;
  NK_LAYOUT_STATIC_ROW = 5;
  NK_LAYOUT_STATIC_FREE = 6;
  NK_LAYOUT_STATIC = 7;
  NK_LAYOUT_TEMPLATE = 8;
  NK_LAYOUT_COUNT = 9;

  NK_WINDOW_PRIVATE = 2048;
  NK_WINDOW_DYNAMIC = 2048;
  NK_WINDOW_ROM = 4096;
  NK_WINDOW_NOT_INTERACTIVE = 5120;
  NK_WINDOW_HIDDEN = 8192;
  NK_WINDOW_CLOSED = 16384;
  NK_WINDOW_MINIMIZED = 32768;
  NK_WINDOW_REMOVE_ROM = 65536;

type
  { ALLEGRO_PIXEL_FORMAT }
  ALLEGRO_PIXEL_FORMAT = Integer;

  { PALLEGRO_PIXEL_FORMAT }
  PALLEGRO_PIXEL_FORMAT = ^ALLEGRO_PIXEL_FORMAT;

  { ALLEGRO_BITMAP_WRAP }
  ALLEGRO_BITMAP_WRAP = Integer;

  { PALLEGRO_BITMAP_WRAP }
  PALLEGRO_BITMAP_WRAP = ^ALLEGRO_BITMAP_WRAP;

  { ALLEGRO_SEEK }
  ALLEGRO_SEEK = Integer;

  { PALLEGRO_SEEK }
  PALLEGRO_SEEK = ^ALLEGRO_SEEK;

  { ALLEGRO_BLEND_MODE }
  ALLEGRO_BLEND_MODE = Integer;

  { PALLEGRO_BLEND_MODE }
  PALLEGRO_BLEND_MODE = ^ALLEGRO_BLEND_MODE;

  { ALLEGRO_BLEND_OPERATIONS }
  ALLEGRO_BLEND_OPERATIONS = Integer;

  { PALLEGRO_BLEND_OPERATIONS }
  PALLEGRO_BLEND_OPERATIONS = ^ALLEGRO_BLEND_OPERATIONS;

  { ALLEGRO_DISPLAY_OPTIONS }
  ALLEGRO_DISPLAY_OPTIONS = Integer;

  { PALLEGRO_DISPLAY_OPTIONS }
  PALLEGRO_DISPLAY_OPTIONS = ^ALLEGRO_DISPLAY_OPTIONS;

  { ALLEGRO_DISPLAY_ORIENTATION }
  ALLEGRO_DISPLAY_ORIENTATION = Integer;

  { PALLEGRO_DISPLAY_ORIENTATION }
  PALLEGRO_DISPLAY_ORIENTATION = ^ALLEGRO_DISPLAY_ORIENTATION;

  { ALLEGRO_FILE_MODE }
  ALLEGRO_FILE_MODE = Integer;

  { PALLEGRO_FILE_MODE }
  PALLEGRO_FILE_MODE = ^ALLEGRO_FILE_MODE;

  { ALLEGRO_FOR_EACH_FS_ENTRY_RESULT }
  ALLEGRO_FOR_EACH_FS_ENTRY_RESULT = Integer;

  { PALLEGRO_FOR_EACH_FS_ENTRY_RESULT }
  PALLEGRO_FOR_EACH_FS_ENTRY_RESULT = ^ALLEGRO_FOR_EACH_FS_ENTRY_RESULT;

  { ALLEGRO_JOYFLAGS }
  ALLEGRO_JOYFLAGS = Integer;

  { PALLEGRO_JOYFLAGS }
  PALLEGRO_JOYFLAGS = ^ALLEGRO_JOYFLAGS;

  { ALLEGRO_MOUSE_EMULATION_MODE }
  ALLEGRO_MOUSE_EMULATION_MODE = Integer;

  { PALLEGRO_MOUSE_EMULATION_MODE }
  PALLEGRO_MOUSE_EMULATION_MODE = ^ALLEGRO_MOUSE_EMULATION_MODE;

  { ALLEGRO_HAPTIC_CONSTANTS }
  ALLEGRO_HAPTIC_CONSTANTS = Integer;

  { PALLEGRO_HAPTIC_CONSTANTS }
  PALLEGRO_HAPTIC_CONSTANTS = ^ALLEGRO_HAPTIC_CONSTANTS;

  { ALLEGRO_SYSTEM_MOUSE_CURSOR }
  ALLEGRO_SYSTEM_MOUSE_CURSOR = Integer;

  { PALLEGRO_SYSTEM_MOUSE_CURSOR }
  PALLEGRO_SYSTEM_MOUSE_CURSOR = ^ALLEGRO_SYSTEM_MOUSE_CURSOR;

  { ALLEGRO_RENDER_STATE }
  ALLEGRO_RENDER_STATE = Integer;

  { PALLEGRO_RENDER_STATE }
  PALLEGRO_RENDER_STATE = ^ALLEGRO_RENDER_STATE;

  { ALLEGRO_RENDER_FUNCTION }
  ALLEGRO_RENDER_FUNCTION = Integer;

  { PALLEGRO_RENDER_FUNCTION }
  PALLEGRO_RENDER_FUNCTION = ^ALLEGRO_RENDER_FUNCTION;

  { ALLEGRO_WRITE_MASK_FLAGS }
  ALLEGRO_WRITE_MASK_FLAGS = Integer;

  { PALLEGRO_WRITE_MASK_FLAGS }
  PALLEGRO_WRITE_MASK_FLAGS = ^ALLEGRO_WRITE_MASK_FLAGS;

  { ALLEGRO_SHADER_TYPE }
  ALLEGRO_SHADER_TYPE = Integer;

  { PALLEGRO_SHADER_TYPE }
  PALLEGRO_SHADER_TYPE = ^ALLEGRO_SHADER_TYPE;

  { ALLEGRO_SHADER_PLATFORM }
  ALLEGRO_SHADER_PLATFORM = Integer;

  { PALLEGRO_SHADER_PLATFORM }
  PALLEGRO_SHADER_PLATFORM = ^ALLEGRO_SHADER_PLATFORM;

  { ALLEGRO_SYSTEM_ID }
  ALLEGRO_SYSTEM_ID = Integer;

  { PALLEGRO_SYSTEM_ID }
  PALLEGRO_SYSTEM_ID = ^ALLEGRO_SYSTEM_ID;

  { ALLEGRO_STATE_FLAGS }
  ALLEGRO_STATE_FLAGS = Integer;

  { PALLEGRO_STATE_FLAGS }
  PALLEGRO_STATE_FLAGS = ^ALLEGRO_STATE_FLAGS;

  { ALLEGRO_AUDIO_EVENT_TYPE }
  ALLEGRO_AUDIO_EVENT_TYPE = Integer;

  { PALLEGRO_AUDIO_EVENT_TYPE }
  PALLEGRO_AUDIO_EVENT_TYPE = ^ALLEGRO_AUDIO_EVENT_TYPE;

  { ALLEGRO_AUDIO_DEPTH }
  ALLEGRO_AUDIO_DEPTH = Integer;

  { PALLEGRO_AUDIO_DEPTH }
  PALLEGRO_AUDIO_DEPTH = ^ALLEGRO_AUDIO_DEPTH;

  { ALLEGRO_CHANNEL_CONF }
  ALLEGRO_CHANNEL_CONF = Integer;

  { PALLEGRO_CHANNEL_CONF }
  PALLEGRO_CHANNEL_CONF = ^ALLEGRO_CHANNEL_CONF;

  { ALLEGRO_PLAYMODE }
  ALLEGRO_PLAYMODE = Integer;

  { PALLEGRO_PLAYMODE }
  PALLEGRO_PLAYMODE = ^ALLEGRO_PLAYMODE;

  { ALLEGRO_MIXER_QUALITY }
  ALLEGRO_MIXER_QUALITY = Integer;

  { PALLEGRO_MIXER_QUALITY }
  PALLEGRO_MIXER_QUALITY = ^ALLEGRO_MIXER_QUALITY;

  { ALLEGRO_PRIM_TYPE }
  ALLEGRO_PRIM_TYPE = Integer;

  { PALLEGRO_PRIM_TYPE }
  PALLEGRO_PRIM_TYPE = ^ALLEGRO_PRIM_TYPE;

  { ALLEGRO_PRIM_ATTR }
  ALLEGRO_PRIM_ATTR = Integer;

  { PALLEGRO_PRIM_ATTR }
  PALLEGRO_PRIM_ATTR = ^ALLEGRO_PRIM_ATTR;

  { ALLEGRO_PRIM_STORAGE }
  ALLEGRO_PRIM_STORAGE = Integer;

  { PALLEGRO_PRIM_STORAGE }
  PALLEGRO_PRIM_STORAGE = ^ALLEGRO_PRIM_STORAGE;

  { ALLEGRO_LINE_JOIN }
  ALLEGRO_LINE_JOIN = Integer;

  { PALLEGRO_LINE_JOIN }
  PALLEGRO_LINE_JOIN = ^ALLEGRO_LINE_JOIN;

  { ALLEGRO_LINE_CAP }
  ALLEGRO_LINE_CAP = Integer;

  { PALLEGRO_LINE_CAP }
  PALLEGRO_LINE_CAP = ^ALLEGRO_LINE_CAP;

  { ALLEGRO_PRIM_BUFFER_FLAGS }
  ALLEGRO_PRIM_BUFFER_FLAGS = Integer;

  { PALLEGRO_PRIM_BUFFER_FLAGS }
  PALLEGRO_PRIM_BUFFER_FLAGS = ^ALLEGRO_PRIM_BUFFER_FLAGS;

  { ALLEGRO_VIDEO_EVENT_TYPE }
  ALLEGRO_VIDEO_EVENT_TYPE = Integer;

  { PALLEGRO_VIDEO_EVENT_TYPE }
  PALLEGRO_VIDEO_EVENT_TYPE = ^ALLEGRO_VIDEO_EVENT_TYPE;

  { ALLEGRO_VIDEO_POSITION_TYPE }
  ALLEGRO_VIDEO_POSITION_TYPE = Integer;

  { PALLEGRO_VIDEO_POSITION_TYPE }
  PALLEGRO_VIDEO_POSITION_TYPE = ^ALLEGRO_VIDEO_POSITION_TYPE;

  { nk_heading }
  nk_heading = Integer;

  { Pnk_heading }
  Pnk_heading = ^nk_heading;

  { nk_button_behavior }
  nk_button_behavior = Integer;

  { Pnk_button_behavior }
  Pnk_button_behavior = ^nk_button_behavior;

  { nk_modify }
  nk_modify = Integer;

  { Pnk_modify }
  Pnk_modify = ^nk_modify;

  { nk_orientation }
  nk_orientation = Integer;

  { Pnk_orientation }
  Pnk_orientation = ^nk_orientation;

  { nk_collapse_states }
  nk_collapse_states = Integer;

  { Pnk_collapse_states }
  Pnk_collapse_states = ^nk_collapse_states;

  { nk_show_states }
  nk_show_states = Integer;

  { Pnk_show_states }
  Pnk_show_states = ^nk_show_states;

  { nk_chart_type }
  nk_chart_type = Integer;

  { Pnk_chart_type }
  Pnk_chart_type = ^nk_chart_type;

  { nk_chart_event }
  nk_chart_event = Integer;

  { Pnk_chart_event }
  Pnk_chart_event = ^nk_chart_event;

  { nk_color_format }
  nk_color_format = Integer;

  { Pnk_color_format }
  Pnk_color_format = ^nk_color_format;

  { nk_popup_type }
  nk_popup_type = Integer;

  { Pnk_popup_type }
  Pnk_popup_type = ^nk_popup_type;

  { nk_layout_format }
  nk_layout_format = Integer;

  { Pnk_layout_format }
  Pnk_layout_format = ^nk_layout_format;

  { nk_tree_type }
  nk_tree_type = Integer;

  { Pnk_tree_type }
  Pnk_tree_type = ^nk_tree_type;

  { nk_symbol_type }
  nk_symbol_type = Integer;

  { Pnk_symbol_type }
  Pnk_symbol_type = ^nk_symbol_type;

  { nk_keys }
  nk_keys = Integer;

  { Pnk_keys }
  Pnk_keys = ^nk_keys;

  { nk_buttons }
  nk_buttons = Integer;

  { Pnk_buttons }
  Pnk_buttons = ^nk_buttons;

  { nk_anti_aliasing }
  nk_anti_aliasing = Integer;

  { Pnk_anti_aliasing }
  Pnk_anti_aliasing = ^nk_anti_aliasing;

  { nk_convert_result }
  nk_convert_result = Integer;

  { Pnk_convert_result }
  Pnk_convert_result = ^nk_convert_result;

  { nk_panel_flags }
  nk_panel_flags = Integer;

  { Pnk_panel_flags }
  Pnk_panel_flags = ^nk_panel_flags;

  { nk_widget_layout_states }
  nk_widget_layout_states = Integer;

  { Pnk_widget_layout_states }
  Pnk_widget_layout_states = ^nk_widget_layout_states;

  { nk_widget_states }
  nk_widget_states = Integer;

  { Pnk_widget_states }
  Pnk_widget_states = ^nk_widget_states;

  { nk_text_align }
  nk_text_align = Integer;

  { Pnk_text_align }
  Pnk_text_align = ^nk_text_align;

  { nk_text_alignment }
  nk_text_alignment = Integer;

  { Pnk_text_alignment }
  Pnk_text_alignment = ^nk_text_alignment;

  { nk_edit_flags }
  nk_edit_flags = Integer;

  { Pnk_edit_flags }
  Pnk_edit_flags = ^nk_edit_flags;

  { nk_edit_types }
  nk_edit_types = Integer;

  { Pnk_edit_types }
  Pnk_edit_types = ^nk_edit_types;

  { nk_edit_events }
  nk_edit_events = Integer;

  { Pnk_edit_events }
  Pnk_edit_events = ^nk_edit_events;

  { nk_style_colors }
  nk_style_colors = Integer;

  { Pnk_style_colors }
  Pnk_style_colors = ^nk_style_colors;

  { nk_style_cursor }
  nk_style_cursor = Integer;

  { Pnk_style_cursor }
  Pnk_style_cursor = ^nk_style_cursor;

  { nk_allocation_type }
  nk_allocation_type = Integer;

  { Pnk_allocation_type }
  Pnk_allocation_type = ^nk_allocation_type;

  { nk_buffer_allocation_type }
  nk_buffer_allocation_type = Integer;

  { Pnk_buffer_allocation_type }
  Pnk_buffer_allocation_type = ^nk_buffer_allocation_type;

  { nk_text_edit_type }
  nk_text_edit_type = Integer;

  { Pnk_text_edit_type }
  Pnk_text_edit_type = ^nk_text_edit_type;

  { nk_text_edit_mode }
  nk_text_edit_mode = Integer;

  { Pnk_text_edit_mode }
  Pnk_text_edit_mode = ^nk_text_edit_mode;

  { nk_command_type }
  nk_command_type = Integer;

  { Pnk_command_type }
  Pnk_command_type = ^nk_command_type;

  { nk_command_clipping }
  nk_command_clipping = Integer;

  { Pnk_command_clipping }
  Pnk_command_clipping = ^nk_command_clipping;

  { nk_style_item_type }
  nk_style_item_type = Integer;

  { Pnk_style_item_type }
  Pnk_style_item_type = ^nk_style_item_type;

  { nk_style_header_align }
  nk_style_header_align = Integer;

  { Pnk_style_header_align }
  Pnk_style_header_align = ^nk_style_header_align;

  { nk_panel_type }
  nk_panel_type = Integer;

  { Pnk_panel_type }
  Pnk_panel_type = ^nk_panel_type;

  { nk_panel_set }
  nk_panel_set = Integer;

  { Pnk_panel_set }
  Pnk_panel_set = ^nk_panel_set;

  { nk_panel_row_layout_type }
  nk_panel_row_layout_type = Integer;

  { Pnk_panel_row_layout_type }
  Pnk_panel_row_layout_type = ^nk_panel_row_layout_type;

  { nk_window_flags }
  nk_window_flags = Integer;

  { Pnk_window_flags }
  Pnk_window_flags = ^nk_window_flags;

  // Forward declarations

  { PPUTF8Char }
  PPUTF8Char = ^PUTF8Char;

  { PUInt16 }
  PUInt16 = ^UInt16;

  { PALLEGRO_USER_EVENT_DESCRIPTOR }
  PALLEGRO_USER_EVENT_DESCRIPTOR = Pointer;

  { PPALLEGRO_USER_EVENT_DESCRIPTOR }
  PPALLEGRO_USER_EVENT_DESCRIPTOR = ^PALLEGRO_USER_EVENT_DESCRIPTOR;

  { PALLEGRO_JOYSTICK_DRIVER }
  PALLEGRO_JOYSTICK_DRIVER = Pointer;

  { PPALLEGRO_JOYSTICK_DRIVER }
  PPALLEGRO_JOYSTICK_DRIVER = ^PALLEGRO_JOYSTICK_DRIVER;

  { PALLEGRO_HAPTIC_DRIVER }
  PALLEGRO_HAPTIC_DRIVER = Pointer;

  { PPALLEGRO_HAPTIC_DRIVER }
  PPALLEGRO_HAPTIC_DRIVER = ^PALLEGRO_HAPTIC_DRIVER;

  { Pnk_draw_command }
  Pnk_draw_command = Pointer;

  { PPnk_draw_command }
  PPnk_draw_command = ^Pnk_draw_command;

  { Pnk_draw_list }
  Pnk_draw_list = Pointer;

  { PPnk_draw_list }
  PPnk_draw_list = ^Pnk_draw_list;

  { Pnk_draw_vertex_layout_element }
  Pnk_draw_vertex_layout_element = Pointer;

  { PPnk_draw_vertex_layout_element }
  PPnk_draw_vertex_layout_element = ^Pnk_draw_vertex_layout_element;

  { Pnk_style_slide }
  Pnk_style_slide = Pointer;

  { PPnk_style_slide }
  PPnk_style_slide = ^Pnk_style_slide;

  { Pnk_user_font_glyph }
  Pnk_user_font_glyph = Pointer;

  { PPnk_user_font_glyph }
  PPnk_user_font_glyph = ^Pnk_user_font_glyph;

  { PALLEGRO_TIMEOUT }
  PALLEGRO_TIMEOUT = ^ALLEGRO_TIMEOUT;

  { PALLEGRO_COLOR }
  PALLEGRO_COLOR = ^ALLEGRO_COLOR;

  { P_al_tagbstring }
  P_al_tagbstring = ^_al_tagbstring;

  { PALLEGRO_FILE_INTERFACE }
  PALLEGRO_FILE_INTERFACE = ^ALLEGRO_FILE_INTERFACE;

  { PALLEGRO_LOCKED_REGION }
  PALLEGRO_LOCKED_REGION = ^ALLEGRO_LOCKED_REGION;

  { PALLEGRO_EVENT_SOURCE }
  PALLEGRO_EVENT_SOURCE = ^ALLEGRO_EVENT_SOURCE;

  { PALLEGRO_ANY_EVENT }
  PALLEGRO_ANY_EVENT = ^ALLEGRO_ANY_EVENT;

  { PALLEGRO_DISPLAY_EVENT }
  PALLEGRO_DISPLAY_EVENT = ^ALLEGRO_DISPLAY_EVENT;

  { PALLEGRO_JOYSTICK_EVENT }
  PALLEGRO_JOYSTICK_EVENT = ^ALLEGRO_JOYSTICK_EVENT;

  { PALLEGRO_KEYBOARD_EVENT }
  PALLEGRO_KEYBOARD_EVENT = ^ALLEGRO_KEYBOARD_EVENT;

  { PALLEGRO_MOUSE_EVENT }
  PALLEGRO_MOUSE_EVENT = ^ALLEGRO_MOUSE_EVENT;

  { PALLEGRO_TIMER_EVENT }
  PALLEGRO_TIMER_EVENT = ^ALLEGRO_TIMER_EVENT;

  { PALLEGRO_TOUCH_EVENT }
  PALLEGRO_TOUCH_EVENT = ^ALLEGRO_TOUCH_EVENT;

  { PALLEGRO_USER_EVENT }
  PALLEGRO_USER_EVENT = ^ALLEGRO_USER_EVENT;

  { PALLEGRO_FS_ENTRY }
  PALLEGRO_FS_ENTRY = ^ALLEGRO_FS_ENTRY;

  { PALLEGRO_FS_INTERFACE }
  PALLEGRO_FS_INTERFACE = ^ALLEGRO_FS_INTERFACE;

  { PALLEGRO_DISPLAY_MODE }
  PALLEGRO_DISPLAY_MODE = ^ALLEGRO_DISPLAY_MODE;

  { PALLEGRO_JOYSTICK_STATE }
  PALLEGRO_JOYSTICK_STATE = ^ALLEGRO_JOYSTICK_STATE;

  { PALLEGRO_KEYBOARD_STATE }
  PALLEGRO_KEYBOARD_STATE = ^ALLEGRO_KEYBOARD_STATE;

  { PALLEGRO_MOUSE_STATE }
  PALLEGRO_MOUSE_STATE = ^ALLEGRO_MOUSE_STATE;

  { PALLEGRO_TOUCH_STATE }
  PALLEGRO_TOUCH_STATE = ^ALLEGRO_TOUCH_STATE;

  { PALLEGRO_TOUCH_INPUT_STATE }
  PALLEGRO_TOUCH_INPUT_STATE = ^ALLEGRO_TOUCH_INPUT_STATE;

  { PALLEGRO_HAPTIC_DIRECTION }
  PALLEGRO_HAPTIC_DIRECTION = ^ALLEGRO_HAPTIC_DIRECTION;

  { PALLEGRO_HAPTIC_REPLAY }
  PALLEGRO_HAPTIC_REPLAY = ^ALLEGRO_HAPTIC_REPLAY;

  { PALLEGRO_HAPTIC_ENVELOPE }
  PALLEGRO_HAPTIC_ENVELOPE = ^ALLEGRO_HAPTIC_ENVELOPE;

  { PALLEGRO_HAPTIC_CONSTANT_EFFECT }
  PALLEGRO_HAPTIC_CONSTANT_EFFECT = ^ALLEGRO_HAPTIC_CONSTANT_EFFECT;

  { PALLEGRO_HAPTIC_RAMP_EFFECT }
  PALLEGRO_HAPTIC_RAMP_EFFECT = ^ALLEGRO_HAPTIC_RAMP_EFFECT;

  { PALLEGRO_HAPTIC_CONDITION_EFFECT }
  PALLEGRO_HAPTIC_CONDITION_EFFECT = ^ALLEGRO_HAPTIC_CONDITION_EFFECT;

  { PALLEGRO_HAPTIC_PERIODIC_EFFECT }
  PALLEGRO_HAPTIC_PERIODIC_EFFECT = ^ALLEGRO_HAPTIC_PERIODIC_EFFECT;

  { PALLEGRO_HAPTIC_RUMBLE_EFFECT }
  PALLEGRO_HAPTIC_RUMBLE_EFFECT = ^ALLEGRO_HAPTIC_RUMBLE_EFFECT;

  { PALLEGRO_HAPTIC_EFFECT }
  PALLEGRO_HAPTIC_EFFECT = ^ALLEGRO_HAPTIC_EFFECT;

  { PALLEGRO_HAPTIC_EFFECT_ID }
  PALLEGRO_HAPTIC_EFFECT_ID = ^ALLEGRO_HAPTIC_EFFECT_ID;

  { PALLEGRO_MEMORY_INTERFACE }
  PALLEGRO_MEMORY_INTERFACE = ^ALLEGRO_MEMORY_INTERFACE;

  { PALLEGRO_MONITOR_INFO }
  PALLEGRO_MONITOR_INFO = ^ALLEGRO_MONITOR_INFO;

  { PALLEGRO_TRANSFORM }
  PALLEGRO_TRANSFORM = ^ALLEGRO_TRANSFORM;

  { PALLEGRO_STATE }
  PALLEGRO_STATE = ^ALLEGRO_STATE;

  { PALLEGRO_AUDIO_RECORDER_EVENT }
  PALLEGRO_AUDIO_RECORDER_EVENT = ^ALLEGRO_AUDIO_RECORDER_EVENT;

  { PALLEGRO_SAMPLE_ID }
  PALLEGRO_SAMPLE_ID = ^ALLEGRO_SAMPLE_ID;

  { PALLEGRO_GLYPH }
  PALLEGRO_GLYPH = ^ALLEGRO_GLYPH;

  { PALLEGRO_MENU_INFO }
  PALLEGRO_MENU_INFO = ^ALLEGRO_MENU_INFO;

  { PALLEGRO_VERTEX_ELEMENT }
  PALLEGRO_VERTEX_ELEMENT = ^ALLEGRO_VERTEX_ELEMENT;

  { PALLEGRO_VERTEX }
  PALLEGRO_VERTEX = ^ALLEGRO_VERTEX;

  { Ptm_zip_s }
  Ptm_zip_s = ^tm_zip_s;

  { Pzip_fileinfo }
  Pzip_fileinfo = ^zip_fileinfo;

  { Pnk_color }
  Pnk_color = ^nk_color;

  { Pnk_colorf }
  Pnk_colorf = ^nk_colorf;

  { Pnk_vec2 }
  Pnk_vec2 = ^nk_vec2;

  { Pnk_vec2i }
  Pnk_vec2i = ^nk_vec2i;

  { Pnk_rect }
  Pnk_rect = ^nk_rect;

  { Pnk_recti }
  Pnk_recti = ^nk_recti;

  { Pnk_image }
  Pnk_image = ^nk_image;

  { Pnk_nine_slice }
  Pnk_nine_slice = ^nk_nine_slice;

  { Pnk_cursor }
  Pnk_cursor = ^nk_cursor;

  { Pnk_scroll }
  Pnk_scroll = ^nk_scroll;

  { Pnk_allocator }
  Pnk_allocator = ^nk_allocator;

  { Pnk_draw_null_texture }
  Pnk_draw_null_texture = ^nk_draw_null_texture;

  { Pnk_convert_config }
  Pnk_convert_config = ^nk_convert_config;

  { Pnk_list_view }
  Pnk_list_view = ^nk_list_view;

  { Pnk_user_font }
  Pnk_user_font = ^nk_user_font;

  { PPnk_user_font }
  PPnk_user_font = ^Pnk_user_font;

  { Pnk_memory_status }
  Pnk_memory_status = ^nk_memory_status;

  { Pnk_buffer_marker }
  Pnk_buffer_marker = ^nk_buffer_marker;

  { Pnk_memory }
  Pnk_memory = ^nk_memory;

  { Pnk_buffer }
  Pnk_buffer = ^nk_buffer;

  { Pnk_str }
  Pnk_str = ^nk_str;

  { Pnk_clipboard }
  Pnk_clipboard = ^nk_clipboard;

  { Pnk_text_undo_record }
  Pnk_text_undo_record = ^nk_text_undo_record;

  { Pnk_text_undo_state }
  Pnk_text_undo_state = ^nk_text_undo_state;

  { Pnk_text_edit }
  Pnk_text_edit = ^nk_text_edit;

  { Pnk_command }
  Pnk_command = ^nk_command;

  { Pnk_command_scissor }
  Pnk_command_scissor = ^nk_command_scissor;

  { Pnk_command_line }
  Pnk_command_line = ^nk_command_line;

  { Pnk_command_curve }
  Pnk_command_curve = ^nk_command_curve;

  { Pnk_command_rect }
  Pnk_command_rect = ^nk_command_rect;

  { Pnk_command_rect_filled }
  Pnk_command_rect_filled = ^nk_command_rect_filled;

  { Pnk_command_rect_multi_color }
  Pnk_command_rect_multi_color = ^nk_command_rect_multi_color;

  { Pnk_command_triangle }
  Pnk_command_triangle = ^nk_command_triangle;

  { Pnk_command_triangle_filled }
  Pnk_command_triangle_filled = ^nk_command_triangle_filled;

  { Pnk_command_circle }
  Pnk_command_circle = ^nk_command_circle;

  { Pnk_command_circle_filled }
  Pnk_command_circle_filled = ^nk_command_circle_filled;

  { Pnk_command_arc }
  Pnk_command_arc = ^nk_command_arc;

  { Pnk_command_arc_filled }
  Pnk_command_arc_filled = ^nk_command_arc_filled;

  { Pnk_command_polygon }
  Pnk_command_polygon = ^nk_command_polygon;

  { Pnk_command_polygon_filled }
  Pnk_command_polygon_filled = ^nk_command_polygon_filled;

  { Pnk_command_polyline }
  Pnk_command_polyline = ^nk_command_polyline;

  { Pnk_command_image }
  Pnk_command_image = ^nk_command_image;

  { Pnk_command_custom }
  Pnk_command_custom = ^nk_command_custom;

  { Pnk_command_text }
  Pnk_command_text = ^nk_command_text;

  { Pnk_command_buffer }
  Pnk_command_buffer = ^nk_command_buffer;

  { Pnk_mouse_button }
  Pnk_mouse_button = ^nk_mouse_button;

  { Pnk_mouse }
  Pnk_mouse = ^nk_mouse;

  { Pnk_key }
  Pnk_key = ^nk_key;

  { Pnk_keyboard }
  Pnk_keyboard = ^nk_keyboard;

  { Pnk_input }
  Pnk_input = ^nk_input;

  { Pnk_style_item }
  Pnk_style_item = ^nk_style_item;

  { Pnk_style_text }
  Pnk_style_text = ^nk_style_text;

  { Pnk_style_button }
  Pnk_style_button = ^nk_style_button;

  { Pnk_style_toggle }
  Pnk_style_toggle = ^nk_style_toggle;

  { Pnk_style_selectable }
  Pnk_style_selectable = ^nk_style_selectable;

  { Pnk_style_slider }
  Pnk_style_slider = ^nk_style_slider;

  { Pnk_style_progress }
  Pnk_style_progress = ^nk_style_progress;

  { Pnk_style_scrollbar }
  Pnk_style_scrollbar = ^nk_style_scrollbar;

  { Pnk_style_edit }
  Pnk_style_edit = ^nk_style_edit;

  { Pnk_style_property }
  Pnk_style_property = ^nk_style_property;

  { Pnk_style_chart }
  Pnk_style_chart = ^nk_style_chart;

  { Pnk_style_combo }
  Pnk_style_combo = ^nk_style_combo;

  { Pnk_style_tab }
  Pnk_style_tab = ^nk_style_tab;

  { Pnk_style_window_header }
  Pnk_style_window_header = ^nk_style_window_header;

  { Pnk_style_window }
  Pnk_style_window = ^nk_style_window;

  { Pnk_style }
  Pnk_style = ^nk_style;

  { Pnk_chart_slot }
  Pnk_chart_slot = ^nk_chart_slot;

  { Pnk_chart }
  Pnk_chart = ^nk_chart;

  { Pnk_row_layout }
  Pnk_row_layout = ^nk_row_layout;

  { Pnk_popup_buffer }
  Pnk_popup_buffer = ^nk_popup_buffer;

  { Pnk_menu_state }
  Pnk_menu_state = ^nk_menu_state;

  { Pnk_panel }
  Pnk_panel = ^nk_panel;

  { Pnk_popup_state }
  Pnk_popup_state = ^nk_popup_state;

  { Pnk_edit_state }
  Pnk_edit_state = ^nk_edit_state;

  { Pnk_property_state }
  Pnk_property_state = ^nk_property_state;

  { Pnk_window }
  Pnk_window = ^nk_window;

  { Pnk_config_stack_style_item_element }
  Pnk_config_stack_style_item_element = ^nk_config_stack_style_item_element;

  { Pnk_config_stack_float_element }
  Pnk_config_stack_float_element = ^nk_config_stack_float_element;

  { Pnk_config_stack_vec2_element }
  Pnk_config_stack_vec2_element = ^nk_config_stack_vec2_element;

  { Pnk_config_stack_flags_element }
  Pnk_config_stack_flags_element = ^nk_config_stack_flags_element;

  { Pnk_config_stack_color_element }
  Pnk_config_stack_color_element = ^nk_config_stack_color_element;

  { Pnk_config_stack_user_font_element }
  Pnk_config_stack_user_font_element = ^nk_config_stack_user_font_element;

  { Pnk_config_stack_button_behavior_element }
  Pnk_config_stack_button_behavior_element = ^nk_config_stack_button_behavior_element;

  { Pnk_config_stack_style_item }
  Pnk_config_stack_style_item = ^nk_config_stack_style_item;

  { Pnk_config_stack_float }
  Pnk_config_stack_float = ^nk_config_stack_float;

  { Pnk_config_stack_vec2 }
  Pnk_config_stack_vec2 = ^nk_config_stack_vec2;

  { Pnk_config_stack_flags }
  Pnk_config_stack_flags = ^nk_config_stack_flags;

  { Pnk_config_stack_color }
  Pnk_config_stack_color = ^nk_config_stack_color;

  { Pnk_config_stack_user_font }
  Pnk_config_stack_user_font = ^nk_config_stack_user_font;

  { Pnk_config_stack_button_behavior }
  Pnk_config_stack_button_behavior = ^nk_config_stack_button_behavior;

  { Pnk_configuration_stacks }
  Pnk_configuration_stacks = ^nk_configuration_stacks;

  { Pnk_table }
  Pnk_table = ^nk_table;

  { Pnk_page_element }
  Pnk_page_element = ^nk_page_element;

  { Pnk_page }
  Pnk_page = ^nk_page;

  { Pnk_pool }
  Pnk_pool = ^nk_pool;

  { Pnk_context }
  Pnk_context = ^nk_context;

  { ALLEGRO_TIMEOUT }
  ALLEGRO_TIMEOUT = record
    __pad1__: UInt64;
    __pad2__: UInt64;
  end;

  { ALLEGRO_COLOR }
  ALLEGRO_COLOR = record
    r: Single;
    g: Single;
    b: Single;
    a: Single;
  end;

  { PALLEGRO_BITMAP }
  PALLEGRO_BITMAP = Pointer;

  { PPALLEGRO_BITMAP }
  PPALLEGRO_BITMAP = ^PALLEGRO_BITMAP;

  { PALLEGRO_USTR }
  PALLEGRO_USTR = ^ALLEGRO_USTR;

  { _al_tagbstring }
  _al_tagbstring = record
    mlen: Integer;
    slen: Integer;
    data: PByte;
  end;

  { PALLEGRO_USTR_INFO }
  PALLEGRO_USTR_INFO = ^ALLEGRO_USTR_INFO;

  { ALLEGRO_USTR_INFO }
  ALLEGRO_USTR_INFO = _al_tagbstring;

  { ALLEGRO_USTR }
  ALLEGRO_USTR = _al_tagbstring;

  { PALLEGRO_PATH }
  PALLEGRO_PATH = Pointer;

  { PPALLEGRO_PATH }
  PPALLEGRO_PATH = ^PALLEGRO_PATH;

  { PALLEGRO_FILE }
  PALLEGRO_FILE = Pointer;

  { PPALLEGRO_FILE }
  PPALLEGRO_FILE = ^PALLEGRO_FILE;

  { off_t }
  off_t = longint;

  { ALLEGRO_FILE_INTERFACE }
  ALLEGRO_FILE_INTERFACE = record
    fi_fopen: function(const path: PUTF8Char; const mode: PUTF8Char): Pointer; cdecl;
    fi_fclose: function(handle: PALLEGRO_FILE): Boolean; cdecl;
    fi_fread: function(f: PALLEGRO_FILE; ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
    fi_fwrite: function(f: PALLEGRO_FILE; const ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
    fi_fflush: function(f: PALLEGRO_FILE): Boolean; cdecl;
    fi_ftell: function(f: PALLEGRO_FILE): Int64; cdecl;
    fi_fseek: function(f: PALLEGRO_FILE; offset: Int64; whence: Integer): Boolean; cdecl;
    fi_feof: function(f: PALLEGRO_FILE): Boolean; cdecl;
    fi_ferror: function(f: PALLEGRO_FILE): Integer; cdecl;
    fi_ferrmsg: function(f: PALLEGRO_FILE): PUTF8Char; cdecl;
    fi_fclearerr: procedure(f: PALLEGRO_FILE); cdecl;
    fi_fungetc: function(f: PALLEGRO_FILE; c: Integer): Integer; cdecl;
    fi_fsize: function(f: PALLEGRO_FILE): off_t; cdecl;
  end;

  { ALLEGRO_IIO_LOADER_FUNCTION }
  ALLEGRO_IIO_LOADER_FUNCTION = function(const filename: PUTF8Char; flags: Integer): PALLEGRO_BITMAP; cdecl;

  { ALLEGRO_IIO_FS_LOADER_FUNCTION }
  ALLEGRO_IIO_FS_LOADER_FUNCTION = function(fp: PALLEGRO_FILE; flags: Integer): PALLEGRO_BITMAP; cdecl;

  { ALLEGRO_IIO_SAVER_FUNCTION }
  ALLEGRO_IIO_SAVER_FUNCTION = function(const filename: PUTF8Char; bitmap: PALLEGRO_BITMAP): Boolean; cdecl;

  { ALLEGRO_IIO_FS_SAVER_FUNCTION }
  ALLEGRO_IIO_FS_SAVER_FUNCTION = function(fp: PALLEGRO_FILE; bitmap: PALLEGRO_BITMAP): Boolean; cdecl;

  { ALLEGRO_IIO_IDENTIFIER_FUNCTION }
  ALLEGRO_IIO_IDENTIFIER_FUNCTION = function(f: PALLEGRO_FILE): Boolean; cdecl;

  { ALLEGRO_LOCKED_REGION }
  ALLEGRO_LOCKED_REGION = record
    data: Pointer;
    format: Integer;
    pitch: Integer;
    pixel_size: Integer;
  end;

  { ALLEGRO_EVENT_TYPE }
  ALLEGRO_EVENT_TYPE = Cardinal;

  { ALLEGRO_EVENT_SOURCE }
  ALLEGRO_EVENT_SOURCE = record
    __pad: array [0..31] of Integer;
  end;

  { ALLEGRO_ANY_EVENT }
  ALLEGRO_ANY_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_EVENT_SOURCE;
    timestamp: Double;
  end;

  { PALLEGRO_DISPLAY }
  PALLEGRO_DISPLAY = Pointer;

  { PPALLEGRO_DISPLAY }
  PPALLEGRO_DISPLAY = ^PALLEGRO_DISPLAY;

  { PALLEGRO_JOYSTICK }
  PALLEGRO_JOYSTICK = Pointer;

  { PPALLEGRO_JOYSTICK }
  PPALLEGRO_JOYSTICK = ^PALLEGRO_JOYSTICK;

  { PALLEGRO_KEYBOARD }
  PALLEGRO_KEYBOARD = Pointer;

  { PPALLEGRO_KEYBOARD }
  PPALLEGRO_KEYBOARD = ^PALLEGRO_KEYBOARD;

  { PALLEGRO_MOUSE }
  PALLEGRO_MOUSE = Pointer;

  { PPALLEGRO_MOUSE }
  PPALLEGRO_MOUSE = ^PALLEGRO_MOUSE;

  { PALLEGRO_TIMER }
  PALLEGRO_TIMER = Pointer;

  { PPALLEGRO_TIMER }
  PPALLEGRO_TIMER = ^PALLEGRO_TIMER;

  { PALLEGRO_TOUCH_INPUT }
  PALLEGRO_TOUCH_INPUT = Pointer;

  { PPALLEGRO_TOUCH_INPUT }
  PPALLEGRO_TOUCH_INPUT = ^PALLEGRO_TOUCH_INPUT;

  { ALLEGRO_DISPLAY_EVENT }
  ALLEGRO_DISPLAY_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_DISPLAY;
    timestamp: Double;
    x: Integer;
    y: Integer;
    width: Integer;
    height: Integer;
    orientation: Integer;
  end;

  { ALLEGRO_JOYSTICK_EVENT }
  ALLEGRO_JOYSTICK_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_JOYSTICK;
    timestamp: Double;
    id: PALLEGRO_JOYSTICK;
    stick: Integer;
    axis: Integer;
    pos: Single;
    button: Integer;
  end;

  { ALLEGRO_KEYBOARD_EVENT }
  ALLEGRO_KEYBOARD_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_KEYBOARD;
    timestamp: Double;
    display: PALLEGRO_DISPLAY;
    keycode: Integer;
    unichar: Integer;
    modifiers: Cardinal;
    repeat_: Boolean;
  end;

  { ALLEGRO_MOUSE_EVENT }
  ALLEGRO_MOUSE_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_MOUSE;
    timestamp: Double;
    display: PALLEGRO_DISPLAY;
    x: Integer;
    y: Integer;
    z: Integer;
    w: Integer;
    dx: Integer;
    dy: Integer;
    dz: Integer;
    dw: Integer;
    button: Cardinal;
    pressure: Single;
  end;

  { ALLEGRO_TIMER_EVENT }
  ALLEGRO_TIMER_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_TIMER;
    timestamp: Double;
    count: Int64;
    error: Double;
  end;

  { ALLEGRO_TOUCH_EVENT }
  ALLEGRO_TOUCH_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_TOUCH_INPUT;
    timestamp: Double;
    display: PALLEGRO_DISPLAY;
    id: Integer;
    x: Single;
    y: Single;
    dx: Single;
    dy: Single;
    primary: Boolean;
  end;

  { ALLEGRO_USER_EVENT }
  ALLEGRO_USER_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_EVENT_SOURCE;
    timestamp: Double;
    __internal__descr: PALLEGRO_USER_EVENT_DESCRIPTOR;
    data1: IntPtr;
    data2: IntPtr;
    data3: IntPtr;
    data4: IntPtr;
  end;

  { PALLEGRO_EVENT }
  PALLEGRO_EVENT = ^ALLEGRO_EVENT;

  { ALLEGRO_EVENT }
  ALLEGRO_EVENT = record
    case Integer of
      0: (type_: ALLEGRO_EVENT_TYPE);
      1: (any: ALLEGRO_ANY_EVENT);
      2: (display: ALLEGRO_DISPLAY_EVENT);
      3: (joystick: ALLEGRO_JOYSTICK_EVENT);
      4: (keyboard: ALLEGRO_KEYBOARD_EVENT);
      5: (mouse: ALLEGRO_MOUSE_EVENT);
      6: (timer: ALLEGRO_TIMER_EVENT);
      7: (touch: ALLEGRO_TOUCH_EVENT);
      8: (user: ALLEGRO_USER_EVENT);
  end;

  { PALLEGRO_EVENT_QUEUE }
  PALLEGRO_EVENT_QUEUE = Pointer;

  { PPALLEGRO_EVENT_QUEUE }
  PPALLEGRO_EVENT_QUEUE = ^PALLEGRO_EVENT_QUEUE;

  { PALLEGRO_CONFIG }
  PALLEGRO_CONFIG = Pointer;

  { PPALLEGRO_CONFIG }
  PPALLEGRO_CONFIG = ^PALLEGRO_CONFIG;

  { PALLEGRO_CONFIG_SECTION }
  PALLEGRO_CONFIG_SECTION = Pointer;

  { PPALLEGRO_CONFIG_SECTION }
  PPALLEGRO_CONFIG_SECTION = ^PALLEGRO_CONFIG_SECTION;

  { PALLEGRO_CONFIG_ENTRY }
  PALLEGRO_CONFIG_ENTRY = Pointer;

  { PPALLEGRO_CONFIG_ENTRY }
  PPALLEGRO_CONFIG_ENTRY = ^PALLEGRO_CONFIG_ENTRY;

  { al_fixed }
  al_fixed = Int32;

  { ALLEGRO_FS_ENTRY }
  ALLEGRO_FS_ENTRY = record
    vtable: PALLEGRO_FS_INTERFACE;
  end;

  { ALLEGRO_FS_INTERFACE }
  ALLEGRO_FS_INTERFACE = record
    fs_create_entry: function(const path: PUTF8Char): PALLEGRO_FS_ENTRY; cdecl;
    fs_destroy_entry: procedure(e: PALLEGRO_FS_ENTRY); cdecl;
    fs_entry_name: function(e: PALLEGRO_FS_ENTRY): PUTF8Char; cdecl;
    fs_update_entry: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_entry_mode: function(e: PALLEGRO_FS_ENTRY): UInt32; cdecl;
    fs_entry_atime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
    fs_entry_mtime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
    fs_entry_ctime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
    fs_entry_size: function(e: PALLEGRO_FS_ENTRY): off_t; cdecl;
    fs_entry_exists: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_remove_entry: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_open_directory: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_read_directory: function(e: PALLEGRO_FS_ENTRY): PALLEGRO_FS_ENTRY; cdecl;
    fs_close_directory: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_filename_exists: function(const path: PUTF8Char): Boolean; cdecl;
    fs_remove_filename: function(const path: PUTF8Char): Boolean; cdecl;
    fs_get_current_directory: function(): PUTF8Char; cdecl;
    fs_change_directory: function(const path: PUTF8Char): Boolean; cdecl;
    fs_make_directory: function(const path: PUTF8Char): Boolean; cdecl;
    fs_open_file: function(e: PALLEGRO_FS_ENTRY; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  end;

  { ALLEGRO_DISPLAY_MODE }
  ALLEGRO_DISPLAY_MODE = record
    width: Integer;
    height: Integer;
    format: Integer;
    refresh_rate: Integer;
  end;

  { ALLEGRO_JOYSTICK_STATE_AXIS }
  ALLEGRO_JOYSTICK_STATE_AXIS = record
    axis: array [0..2] of Single;
  end;

  { ALLEGRO_JOYSTICK_STATE }
  ALLEGRO_JOYSTICK_STATE = record
    stick: array [0..15] of ALLEGRO_JOYSTICK_STATE_AXIS;
    button: array [0..31] of Integer;
  end;

  { ALLEGRO_KEYBOARD_STATE }
  ALLEGRO_KEYBOARD_STATE = record
    display: PALLEGRO_DISPLAY;
    __key_down__internal__: array [0..7] of Cardinal;
  end;

  { ALLEGRO_MOUSE_STATE }
  ALLEGRO_MOUSE_STATE = record
    x: Integer;
    y: Integer;
    z: Integer;
    w: Integer;
    more_axes: array [0..3] of Integer;
    buttons: Integer;
    pressure: Single;
    display: PALLEGRO_DISPLAY;
  end;


  { ALLEGRO_TOUCH_STATE }
  ALLEGRO_TOUCH_STATE = record
    id: Integer;
    x: Single;
    y: Single;
    dx: Single;
    dy: Single;
    primary: Boolean;
    display: PALLEGRO_DISPLAY;
  end;

  { ALLEGRO_TOUCH_INPUT_STATE }
  ALLEGRO_TOUCH_INPUT_STATE = record
    touches: array [0..15] of ALLEGRO_TOUCH_STATE;
  end;

  { PALLEGRO_HAPTIC }
  PALLEGRO_HAPTIC = Pointer;

  { PPALLEGRO_HAPTIC }
  PPALLEGRO_HAPTIC = ^PALLEGRO_HAPTIC;

  { ALLEGRO_HAPTIC_DIRECTION }
  ALLEGRO_HAPTIC_DIRECTION = record
    angle: Double;
    radius: Double;
    azimuth: Double;
  end;

  { ALLEGRO_HAPTIC_REPLAY }
  ALLEGRO_HAPTIC_REPLAY = record
    length: Double;
    delay: Double;
  end;

  { ALLEGRO_HAPTIC_ENVELOPE }
  ALLEGRO_HAPTIC_ENVELOPE = record
    attack_length: Double;
    attack_level: Double;
    fade_length: Double;
    fade_level: Double;
  end;

  { ALLEGRO_HAPTIC_CONSTANT_EFFECT }
  ALLEGRO_HAPTIC_CONSTANT_EFFECT = record
    level: Double;
    envelope: ALLEGRO_HAPTIC_ENVELOPE;
  end;

  { ALLEGRO_HAPTIC_RAMP_EFFECT }
  ALLEGRO_HAPTIC_RAMP_EFFECT = record
    start_level: Double;
    end_level: Double;
    envelope: ALLEGRO_HAPTIC_ENVELOPE;
  end;

  { ALLEGRO_HAPTIC_CONDITION_EFFECT }
  ALLEGRO_HAPTIC_CONDITION_EFFECT = record
    right_saturation: Double;
    left_saturation: Double;
    right_coeff: Double;
    left_coeff: Double;
    deadband: Double;
    center: Double;
  end;

  { ALLEGRO_HAPTIC_PERIODIC_EFFECT }
  ALLEGRO_HAPTIC_PERIODIC_EFFECT = record
    waveform: Integer;
    period: Double;
    magnitude: Double;
    offset: Double;
    phase: Double;
    envelope: ALLEGRO_HAPTIC_ENVELOPE;
    custom_len: Integer;
    custom_data: PDouble;
  end;

  { ALLEGRO_HAPTIC_RUMBLE_EFFECT }
  ALLEGRO_HAPTIC_RUMBLE_EFFECT = record
    strong_magnitude: Double;
    weak_magnitude: Double;
  end;

  { ALLEGRO_HAPTIC_EFFECT_UNION }
  ALLEGRO_HAPTIC_EFFECT_UNION = record
    case Integer of
      0: (constant: ALLEGRO_HAPTIC_CONSTANT_EFFECT);
      1: (ramp: ALLEGRO_HAPTIC_RAMP_EFFECT);
      2: (periodic: ALLEGRO_HAPTIC_PERIODIC_EFFECT);
      3: (condition: ALLEGRO_HAPTIC_CONDITION_EFFECT);
      4: (rumble: ALLEGRO_HAPTIC_RUMBLE_EFFECT);
  end;

  { ALLEGRO_HAPTIC_EFFECT }
  ALLEGRO_HAPTIC_EFFECT = record
    direction: ALLEGRO_HAPTIC_DIRECTION;
    replay: ALLEGRO_HAPTIC_REPLAY;
    data: ALLEGRO_HAPTIC_EFFECT_UNION;
  end;

  { ALLEGRO_HAPTIC_EFFECT_ID }
  ALLEGRO_HAPTIC_EFFECT_ID = record
    _haptic: PALLEGRO_HAPTIC;
    _id: Integer;
    _handle: Integer;
    _pointer: Pointer;
    _effect_duration: Double;
    _playing: Boolean;
    _start_time: Double;
    _end_time: Double;
    driver: Pointer;
  end;

  { ALLEGRO_MEMORY_INTERFACE }
  ALLEGRO_MEMORY_INTERFACE = record
    mi_malloc: function(n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
    mi_free: procedure(ptr: Pointer; line: Integer; const file_: PUTF8Char; const func: PUTF8Char); cdecl;
    mi_realloc: function(ptr: Pointer; n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
    mi_calloc: function(count: NativeUInt; n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
  end;

  { ALLEGRO_MONITOR_INFO }
  ALLEGRO_MONITOR_INFO = record
    x1: Integer;
    y1: Integer;
    x2: Integer;
    y2: Integer;
  end;

  { PALLEGRO_MOUSE_CURSOR }
  PALLEGRO_MOUSE_CURSOR = Pointer;

  { PPALLEGRO_MOUSE_CURSOR }
  PPALLEGRO_MOUSE_CURSOR = ^PALLEGRO_MOUSE_CURSOR;

  { ALLEGRO_TRANSFORM }
  ALLEGRO_TRANSFORM = record
    m: array [0..3] of array [0..3] of Single;
  end;

  { PALLEGRO_SHADER }
  PALLEGRO_SHADER = Pointer;

  { PPALLEGRO_SHADER }
  PPALLEGRO_SHADER = ^PALLEGRO_SHADER;

  { PALLEGRO_SYSTEM }
  PALLEGRO_SYSTEM = Pointer;

  { PPALLEGRO_SYSTEM }
  PPALLEGRO_SYSTEM = ^PALLEGRO_SYSTEM;

  { PALLEGRO_THREAD }
  PALLEGRO_THREAD = Pointer;

  { PPALLEGRO_THREAD }
  PPALLEGRO_THREAD = ^PALLEGRO_THREAD;

  { PALLEGRO_MUTEX }
  PALLEGRO_MUTEX = Pointer;

  { PPALLEGRO_MUTEX }
  PPALLEGRO_MUTEX = ^PALLEGRO_MUTEX;

  { PALLEGRO_COND }
  PALLEGRO_COND = Pointer;

  { PPALLEGRO_COND }
  PPALLEGRO_COND = ^PALLEGRO_COND;

  { ALLEGRO_STATE }
  ALLEGRO_STATE = record
    _tls: array [0..1023] of UTF8Char;
  end;

  { PALLEGRO_AUDIO_RECORDER }
  PALLEGRO_AUDIO_RECORDER = Pointer;

  { PPALLEGRO_AUDIO_RECORDER }
  PPALLEGRO_AUDIO_RECORDER = ^PALLEGRO_AUDIO_RECORDER;

  { ALLEGRO_AUDIO_RECORDER_EVENT }
  ALLEGRO_AUDIO_RECORDER_EVENT = record
    source: PALLEGRO_AUDIO_RECORDER;
    timestamp: Double;
    __internal__descr: PALLEGRO_USER_EVENT_DESCRIPTOR;
    buffer: Pointer;
    samples: Cardinal;
  end;

  { PALLEGRO_SAMPLE }
  PALLEGRO_SAMPLE = Pointer;

  { PPALLEGRO_SAMPLE }
  PPALLEGRO_SAMPLE = ^PALLEGRO_SAMPLE;

  { ALLEGRO_SAMPLE_ID }
  ALLEGRO_SAMPLE_ID = record
    _index: Integer;
    _id: Integer;
  end;

  { PALLEGRO_SAMPLE_INSTANCE }
  PALLEGRO_SAMPLE_INSTANCE = Pointer;

  { PPALLEGRO_SAMPLE_INSTANCE }
  PPALLEGRO_SAMPLE_INSTANCE = ^PALLEGRO_SAMPLE_INSTANCE;

  { PALLEGRO_AUDIO_STREAM }
  PALLEGRO_AUDIO_STREAM = Pointer;

  { PPALLEGRO_AUDIO_STREAM }
  PPALLEGRO_AUDIO_STREAM = ^PALLEGRO_AUDIO_STREAM;

  { PALLEGRO_MIXER }
  PALLEGRO_MIXER = Pointer;

  { PPALLEGRO_MIXER }
  PPALLEGRO_MIXER = ^PALLEGRO_MIXER;

  { PALLEGRO_VOICE }
  PALLEGRO_VOICE = Pointer;

  { PPALLEGRO_VOICE }
  PPALLEGRO_VOICE = ^PALLEGRO_VOICE;

  { PALLEGRO_AUDIO_DEVICE }
  PALLEGRO_AUDIO_DEVICE = Pointer;

  { PPALLEGRO_AUDIO_DEVICE }
  PPALLEGRO_AUDIO_DEVICE = ^PALLEGRO_AUDIO_DEVICE;

  { PALLEGRO_FONT }
  PALLEGRO_FONT = Pointer;

  { PPALLEGRO_FONT }
  PPALLEGRO_FONT = ^PALLEGRO_FONT;

  { ALLEGRO_GLYPH }
  ALLEGRO_GLYPH = record
    bitmap: PALLEGRO_BITMAP;
    x: Integer;
    y: Integer;
    w: Integer;
    h: Integer;
    kerning: Integer;
    offset_x: Integer;
    offset_y: Integer;
    advance: Integer;
  end;

  { PALLEGRO_FILECHOOSER }
  PALLEGRO_FILECHOOSER = Pointer;

  { PPALLEGRO_FILECHOOSER }
  PPALLEGRO_FILECHOOSER = ^PALLEGRO_FILECHOOSER;

  { PALLEGRO_TEXTLOG }
  PALLEGRO_TEXTLOG = Pointer;

  { PPALLEGRO_TEXTLOG }
  PPALLEGRO_TEXTLOG = ^PALLEGRO_TEXTLOG;

  { PALLEGRO_MENU }
  PALLEGRO_MENU = Pointer;

  { PPALLEGRO_MENU }
  PPALLEGRO_MENU = ^PALLEGRO_MENU;

  { ALLEGRO_MENU_INFO }
  ALLEGRO_MENU_INFO = record
    caption: PUTF8Char;
    id: UInt16;
    flags: Integer;
    icon: PALLEGRO_BITMAP;
  end;

  { ALLEGRO_VERTEX_ELEMENT }
  ALLEGRO_VERTEX_ELEMENT = record
    attribute: Integer;
    storage: Integer;
    offset: Integer;
  end;

  { PALLEGRO_VERTEX_DECL }
  PALLEGRO_VERTEX_DECL = Pointer;

  { PPALLEGRO_VERTEX_DECL }
  PPALLEGRO_VERTEX_DECL = ^PALLEGRO_VERTEX_DECL;

  { ALLEGRO_VERTEX }
  ALLEGRO_VERTEX = record
    x: Single;
    y: Single;
    z: Single;
    u: Single;
    v: Single;
    color: ALLEGRO_COLOR;
  end;

  { PALLEGRO_VERTEX_BUFFER }
  PALLEGRO_VERTEX_BUFFER = Pointer;

  { PPALLEGRO_VERTEX_BUFFER }
  PPALLEGRO_VERTEX_BUFFER = ^PALLEGRO_VERTEX_BUFFER;

  { PALLEGRO_INDEX_BUFFER }
  PALLEGRO_INDEX_BUFFER = Pointer;

  { PPALLEGRO_INDEX_BUFFER }
  PPALLEGRO_INDEX_BUFFER = ^PALLEGRO_INDEX_BUFFER;

  { PALLEGRO_VIDEO }
  PALLEGRO_VIDEO = Pointer;

  { PPALLEGRO_VIDEO }
  PPALLEGRO_VIDEO = ^PALLEGRO_VIDEO;

  { tm_zip_s }
  tm_zip_s = record
    tm_sec: Integer;
    tm_min: Integer;
    tm_hour: Integer;
    tm_mday: Integer;
    tm_mon: Integer;
    tm_year: Integer;
  end;

  { tm_zip }
  tm_zip = tm_zip_s;

  { zip_fileinfo }
  zip_fileinfo = record
    tmz_date: tm_zip;
    dosDate: Cardinal;
    internal_fa: Cardinal;
    external_fa: Cardinal;
  end;

  { zipFile }
  zipFile = Pointer;

  { nk_char }
  nk_char = UTF8Char;

  { nk_uchar }
  nk_uchar = Byte;

  { nk_byte }
  nk_byte = Byte;

  { Pnk_byte }
  Pnk_byte = ^nk_byte;

  { nk_short }
  nk_short = Smallint;

  { nk_ushort }
  nk_ushort = Word;

  { nk_int }
  nk_int = Integer;

  { nk_uint }
  nk_uint = Cardinal;

  { Pnk_uint }
  Pnk_uint = ^nk_uint;

  { nk_size }
  nk_size = UInt64;

  { Pnk_size }
  Pnk_size = ^nk_size;

  { nk_ptr }
  nk_ptr = UInt64;

  { nk_bool }
  nk_bool = Integer;

  { Pnk_bool }
  Pnk_bool = ^nk_bool;

  { nk_hash }
  nk_hash = nk_uint;

  { nk_flags }
  nk_flags = nk_uint;

  { Pnk_flags }
  Pnk_flags = ^nk_flags;

  { nk_rune }
  nk_rune = nk_uint;

  { Pnk_rune }
  Pnk_rune = ^nk_rune;

  { _dummy_array0 }
  _dummy_array0 = array [0..0] of UTF8Char;

  { _dummy_array1 }
  _dummy_array1 = array [0..0] of UTF8Char;

  { _dummy_array2 }
  _dummy_array2 = array [0..0] of UTF8Char;

  { _dummy_array3 }
  _dummy_array3 = array [0..0] of UTF8Char;

  { _dummy_array4 }
  _dummy_array4 = array [0..0] of UTF8Char;

  { _dummy_array5 }
  _dummy_array5 = array [0..0] of UTF8Char;

  { _dummy_array6 }
  _dummy_array6 = array [0..0] of UTF8Char;

  { _dummy_array7 }
  _dummy_array7 = array [0..0] of UTF8Char;

  { _dummy_array8 }
  _dummy_array8 = array [0..0] of UTF8Char;

  { _dummy_array9 }
  _dummy_array9 = array [0..0] of UTF8Char;

  { nk_color }
  nk_color = record
    r: nk_byte;
    g: nk_byte;
    b: nk_byte;
    a: nk_byte;
  end;

  { nk_colorf }
  nk_colorf = record
    r: Single;
    g: Single;
    b: Single;
    a: Single;
  end;

  { nk_vec2 }
  nk_vec2 = record
    x: Single;
    y: Single;
  end;

  { nk_vec2i }
  nk_vec2i = record
    x: Smallint;
    y: Smallint;
  end;

  { nk_rect }
  nk_rect = record
    x: Single;
    y: Single;
    w: Single;
    h: Single;
  end;

  { nk_recti }
  nk_recti = record
    x: Smallint;
    y: Smallint;
    w: Smallint;
    h: Smallint;
  end;

  { nk_glyph }
  nk_glyph = array [0..3] of UTF8Char;

  { nk_handle }
  nk_handle = record
    case Integer of
      0: (ptr: Pointer);
      1: (id: Integer);
  end;

  { nk_image }
  nk_image = record
    handle: nk_handle;
    w: nk_ushort;
    h: nk_ushort;
    region: array [0..3] of nk_ushort;
  end;

  { nk_nine_slice }
  nk_nine_slice = record
    img: nk_image;
    l: nk_ushort;
    t: nk_ushort;
    r: nk_ushort;
    b: nk_ushort;
  end;

  { nk_cursor }
  nk_cursor = record
    img: nk_image;
    size: nk_vec2;
    offset: nk_vec2;
  end;

  { nk_scroll }
  nk_scroll = record
    x: nk_uint;
    y: nk_uint;
  end;

  { nk_plugin_alloc }
  nk_plugin_alloc = function(p1: nk_handle; old: Pointer; p3: nk_size): Pointer; cdecl;

  { nk_plugin_free }
  nk_plugin_free = procedure(p1: nk_handle; old: Pointer); cdecl;

  { nk_plugin_filter }
  nk_plugin_filter = function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;

  { nk_plugin_paste }
  nk_plugin_paste = procedure(p1: nk_handle; p2: Pnk_text_edit); cdecl;

  { nk_plugin_copy }
  nk_plugin_copy = procedure(p1: nk_handle; const p2: PUTF8Char; len: Integer); cdecl;

  { nk_allocator }
  nk_allocator = record
    userdata: nk_handle;
    alloc: nk_plugin_alloc;
    free: nk_plugin_free;
  end;

  { nk_draw_null_texture }
  nk_draw_null_texture = record
    texture: nk_handle;
    uv: nk_vec2;
  end;

  { nk_convert_config }
  nk_convert_config = record
    global_alpha: Single;
    line_AA: nk_anti_aliasing;
    shape_AA: nk_anti_aliasing;
    circle_segment_count: Cardinal;
    arc_segment_count: Cardinal;
    curve_segment_count: Cardinal;
    null: nk_draw_null_texture;
    vertex_layout: Pnk_draw_vertex_layout_element;
    vertex_size: nk_size;
    vertex_alignment: nk_size;
  end;

  { nk_list_view }
  nk_list_view = record
    begin_: Integer;
    end_: Integer;
    count: Integer;
    total_height: Integer;
    ctx: Pnk_context;
    scroll_pointer: Pnk_uint;
    scroll_value: nk_uint;
  end;

  { nk_text_width_f }
  nk_text_width_f = function(p1: nk_handle; h: Single; const p3: PUTF8Char; len: Integer): Single; cdecl;

  { nk_query_font_glyph_f }
  nk_query_font_glyph_f = procedure(handle: nk_handle; font_height: Single; glyph: Pnk_user_font_glyph; codepoint: nk_rune; next_codepoint: nk_rune); cdecl;

  { nk_user_font }
  nk_user_font = record
    userdata: nk_handle;
    height: Single;
    width: nk_text_width_f;
  end;

  { nk_memory_status }
  nk_memory_status = record
    memory: Pointer;
    size: nk_size;
    allocated: nk_size;
    needed: nk_size;
    calls: nk_size;
  end;

  { nk_buffer_marker }
  nk_buffer_marker = record
    active: nk_bool;
    offset: nk_size;
  end;

  { nk_memory }
  nk_memory = record
    ptr: Pointer;
    size: nk_size;
  end;

  { nk_buffer }
  nk_buffer = record
    marker: array [0..1] of nk_buffer_marker;
    pool: nk_allocator;
    memory: nk_memory;
    grow_factor: Single;
    allocated: nk_size;
    needed: nk_size;
    calls: nk_size;
    size: nk_size;
  end;

  { nk_str }
  nk_str = record
    buffer: nk_buffer;
    len: Integer;
  end;

  { nk_clipboard }
  nk_clipboard = record
    userdata: nk_handle;
    paste: nk_plugin_paste;
    copy: nk_plugin_copy;
  end;

  { nk_text_undo_record }
  nk_text_undo_record = record
    where: Integer;
    insert_length: Smallint;
    delete_length: Smallint;
    char_storage: Smallint;
  end;

  { nk_text_undo_state }
  nk_text_undo_state = record
    undo_rec: array [0..98] of nk_text_undo_record;
    undo_char: array [0..998] of nk_rune;
    undo_point: Smallint;
    redo_point: Smallint;
    undo_char_point: Smallint;
    redo_char_point: Smallint;
  end;

  { nk_text_edit }
  nk_text_edit = record
    clip: nk_clipboard;
    string_: nk_str;
    filter: nk_plugin_filter;
    scrollbar: nk_vec2;
    cursor: Integer;
    select_start: Integer;
    select_end: Integer;
    mode: Byte;
    cursor_at_end_of_line: Byte;
    initialized: Byte;
    has_preferred_x: Byte;
    single_line: Byte;
    active: Byte;
    padding1: Byte;
    preferred_x: Single;
    undo: nk_text_undo_state;
  end;

  { nk_command }
  nk_command = record
    next: nk_size;
  end;

  { nk_command_scissor }
  nk_command_scissor = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
  end;

  { nk_command_line }
  nk_command_line = record
    header: nk_command;
    line_thickness: Word;
    begin_: nk_vec2i;
    end_: nk_vec2i;
    color: nk_color;
  end;

  { nk_command_curve }
  nk_command_curve = record
    header: nk_command;
    line_thickness: Word;
    begin_: nk_vec2i;
    end_: nk_vec2i;
    ctrl: array [0..1] of nk_vec2i;
    color: nk_color;
  end;

  { nk_command_rect }
  nk_command_rect = record
    header: nk_command;
    rounding: Word;
    line_thickness: Word;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    color: nk_color;
  end;

  { nk_command_rect_filled }
  nk_command_rect_filled = record
    header: nk_command;
    rounding: Word;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    color: nk_color;
  end;

  { nk_command_rect_multi_color }
  nk_command_rect_multi_color = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    left: nk_color;
    top: nk_color;
    bottom: nk_color;
    right: nk_color;
  end;

  { nk_command_triangle }
  nk_command_triangle = record
    header: nk_command;
    line_thickness: Word;
    a: nk_vec2i;
    b: nk_vec2i;
    c: nk_vec2i;
    color: nk_color;
  end;

  { nk_command_triangle_filled }
  nk_command_triangle_filled = record
    header: nk_command;
    a: nk_vec2i;
    b: nk_vec2i;
    c: nk_vec2i;
    color: nk_color;
  end;

  { nk_command_circle }
  nk_command_circle = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    line_thickness: Word;
    w: Word;
    h: Word;
    color: nk_color;
  end;

  { nk_command_circle_filled }
  nk_command_circle_filled = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    color: nk_color;
  end;

  { nk_command_arc }
  nk_command_arc = record
    header: nk_command;
    cx: Smallint;
    cy: Smallint;
    r: Word;
    line_thickness: Word;
    a: array [0..1] of Single;
    color: nk_color;
  end;

  { nk_command_arc_filled }
  nk_command_arc_filled = record
    header: nk_command;
    cx: Smallint;
    cy: Smallint;
    r: Word;
    a: array [0..1] of Single;
    color: nk_color;
  end;

  { nk_command_polygon }
  nk_command_polygon = record
    header: nk_command;
    color: nk_color;
    line_thickness: Word;
    point_count: Word;
    points: array [0..0] of nk_vec2i;
  end;

  { nk_command_polygon_filled }
  nk_command_polygon_filled = record
    header: nk_command;
    color: nk_color;
    point_count: Word;
    points: array [0..0] of nk_vec2i;
  end;

  { nk_command_polyline }
  nk_command_polyline = record
    header: nk_command;
    color: nk_color;
    line_thickness: Word;
    point_count: Word;
    points: array [0..0] of nk_vec2i;
  end;

  { nk_command_image }
  nk_command_image = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    img: nk_image;
    col: nk_color;
  end;

  { nk_command_custom_callback }
  nk_command_custom_callback = procedure(canvas: Pointer; x: Smallint; y: Smallint; w: Word; h: Word; callback_data: nk_handle); cdecl;

  { nk_command_custom }
  nk_command_custom = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    callback_data: nk_handle;
    callback: nk_command_custom_callback;
  end;

  { nk_command_text }
  nk_command_text = record
    header: nk_command;
    font: Pnk_user_font;
    background: nk_color;
    foreground: nk_color;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    height: Single;
    length: Integer;
    string_: array [0..0] of UTF8Char;
  end;

  { nk_command_buffer }
  nk_command_buffer = record
    base: Pnk_buffer;
    clip: nk_rect;
    use_clipping: Integer;
    userdata: nk_handle;
    begin_: nk_size;
    end_: nk_size;
    last: nk_size;
  end;

  { nk_mouse_button }
  nk_mouse_button = record
    down: nk_bool;
    clicked: Cardinal;
    clicked_pos: nk_vec2;
  end;

  { nk_mouse }
  nk_mouse = record
    buttons: array [0..3] of nk_mouse_button;
    pos: nk_vec2;
    prev: nk_vec2;
    delta: nk_vec2;
    scroll_delta: nk_vec2;
    grab: Byte;
    grabbed: Byte;
    ungrab: Byte;
  end;

  { nk_key }
  nk_key = record
    down: nk_bool;
    clicked: Cardinal;
  end;

  { nk_keyboard }
  nk_keyboard = record
    keys: array [0..29] of nk_key;
    text: array [0..15] of UTF8Char;
    text_len: Integer;
  end;

  { nk_input }
  nk_input = record
    keyboard: nk_keyboard;
    mouse: nk_mouse;
  end;

  { nk_style_item_data }
  nk_style_item_data = record
    case Integer of
      0: (color: nk_color);
      1: (image: nk_image);
      2: (slice: nk_nine_slice);
  end;

  { nk_style_item }
  nk_style_item = record
    data: nk_style_item_data;
  end;

  { nk_style_text }
  nk_style_text = record
    color: nk_color;
    padding: nk_vec2;
  end;

  { nk_style_button }
  nk_style_button = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    text_background: nk_color;
    text_normal: nk_color;
    text_hover: nk_color;
    text_active: nk_color;
    text_alignment: nk_flags;
    border: Single;
    rounding: Single;
    padding: nk_vec2;
    image_padding: nk_vec2;
    touch_padding: nk_vec2;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; userdata: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; userdata: nk_handle); cdecl;
  end;

  { nk_style_toggle }
  nk_style_toggle = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    cursor_normal: nk_style_item;
    cursor_hover: nk_style_item;
    text_normal: nk_color;
    text_hover: nk_color;
    text_active: nk_color;
    text_background: nk_color;
    text_alignment: nk_flags;
    padding: nk_vec2;
    touch_padding: nk_vec2;
    spacing: Single;
    border: Single;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  { nk_style_selectable }
  nk_style_selectable = record
    normal: nk_style_item;
    hover: nk_style_item;
    pressed: nk_style_item;
    normal_active: nk_style_item;
    hover_active: nk_style_item;
    pressed_active: nk_style_item;
    text_normal: nk_color;
    text_hover: nk_color;
    text_pressed: nk_color;
    text_normal_active: nk_color;
    text_hover_active: nk_color;
    text_pressed_active: nk_color;
    text_background: nk_color;
    text_alignment: nk_flags;
    rounding: Single;
    padding: nk_vec2;
    touch_padding: nk_vec2;
    image_padding: nk_vec2;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  { nk_style_slider }
  nk_style_slider = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    bar_normal: nk_color;
    bar_hover: nk_color;
    bar_active: nk_color;
    bar_filled: nk_color;
    cursor_normal: nk_style_item;
    cursor_hover: nk_style_item;
    cursor_active: nk_style_item;
    border: Single;
    rounding: Single;
    bar_height: Single;
    padding: nk_vec2;
    spacing: nk_vec2;
    cursor_size: nk_vec2;
    show_buttons: Integer;
    inc_button: nk_style_button;
    dec_button: nk_style_button;
    inc_symbol: nk_symbol_type;
    dec_symbol: nk_symbol_type;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  { nk_style_progress }
  nk_style_progress = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    cursor_normal: nk_style_item;
    cursor_hover: nk_style_item;
    cursor_active: nk_style_item;
    cursor_border_color: nk_color;
    rounding: Single;
    border: Single;
    cursor_border: Single;
    cursor_rounding: Single;
    padding: nk_vec2;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  { nk_style_scrollbar }
  nk_style_scrollbar = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    cursor_normal: nk_style_item;
    cursor_hover: nk_style_item;
    cursor_active: nk_style_item;
    cursor_border_color: nk_color;
    border: Single;
    rounding: Single;
    border_cursor: Single;
    rounding_cursor: Single;
    padding: nk_vec2;
    show_buttons: Integer;
    inc_button: nk_style_button;
    dec_button: nk_style_button;
    inc_symbol: nk_symbol_type;
    dec_symbol: nk_symbol_type;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  { nk_style_edit }
  nk_style_edit = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    scrollbar: nk_style_scrollbar;
    cursor_normal: nk_color;
    cursor_hover: nk_color;
    cursor_text_normal: nk_color;
    cursor_text_hover: nk_color;
    text_normal: nk_color;
    text_hover: nk_color;
    text_active: nk_color;
    selected_normal: nk_color;
    selected_hover: nk_color;
    selected_text_normal: nk_color;
    selected_text_hover: nk_color;
    border: Single;
    rounding: Single;
    cursor_size: Single;
    scrollbar_size: nk_vec2;
    padding: nk_vec2;
    row_padding: Single;
  end;

  { nk_style_property }
  nk_style_property = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    label_normal: nk_color;
    label_hover: nk_color;
    label_active: nk_color;
    sym_left: nk_symbol_type;
    sym_right: nk_symbol_type;
    border: Single;
    rounding: Single;
    padding: nk_vec2;
    edit: nk_style_edit;
    inc_button: nk_style_button;
    dec_button: nk_style_button;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  { nk_style_chart }
  nk_style_chart = record
    background: nk_style_item;
    border_color: nk_color;
    selected_color: nk_color;
    color: nk_color;
    border: Single;
    rounding: Single;
    padding: nk_vec2;
  end;

  { nk_style_combo }
  nk_style_combo = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    label_normal: nk_color;
    label_hover: nk_color;
    label_active: nk_color;
    symbol_normal: nk_color;
    symbol_hover: nk_color;
    symbol_active: nk_color;
    button: nk_style_button;
    sym_normal: nk_symbol_type;
    sym_hover: nk_symbol_type;
    sym_active: nk_symbol_type;
    border: Single;
    rounding: Single;
    content_padding: nk_vec2;
    button_padding: nk_vec2;
    spacing: nk_vec2;
  end;

  { nk_style_tab }
  nk_style_tab = record
    background: nk_style_item;
    border_color: nk_color;
    text: nk_color;
    tab_maximize_button: nk_style_button;
    tab_minimize_button: nk_style_button;
    node_maximize_button: nk_style_button;
    node_minimize_button: nk_style_button;
    sym_minimize: nk_symbol_type;
    sym_maximize: nk_symbol_type;
    border: Single;
    rounding: Single;
    indent: Single;
    padding: nk_vec2;
    spacing: nk_vec2;
  end;

  { nk_style_window_header }
  nk_style_window_header = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    close_button: nk_style_button;
    minimize_button: nk_style_button;
    close_symbol: nk_symbol_type;
    minimize_symbol: nk_symbol_type;
    maximize_symbol: nk_symbol_type;
    label_normal: nk_color;
    label_hover: nk_color;
    label_active: nk_color;
    align: nk_style_header_align;
    padding: nk_vec2;
    label_padding: nk_vec2;
    spacing: nk_vec2;
  end;

  { nk_style_window }
  nk_style_window = record
    header: nk_style_window_header;
    fixed_background: nk_style_item;
    background: nk_color;
    border_color: nk_color;
    popup_border_color: nk_color;
    combo_border_color: nk_color;
    contextual_border_color: nk_color;
    menu_border_color: nk_color;
    group_border_color: nk_color;
    tooltip_border_color: nk_color;
    scaler: nk_style_item;
    border: Single;
    combo_border: Single;
    contextual_border: Single;
    menu_border: Single;
    group_border: Single;
    tooltip_border: Single;
    popup_border: Single;
    min_row_height_padding: Single;
    rounding: Single;
    spacing: nk_vec2;
    scrollbar_size: nk_vec2;
    min_size: nk_vec2;
    padding: nk_vec2;
    group_padding: nk_vec2;
    popup_padding: nk_vec2;
    combo_padding: nk_vec2;
    contextual_padding: nk_vec2;
    menu_padding: nk_vec2;
    tooltip_padding: nk_vec2;
  end;

  { nk_style }
  nk_style = record
    font: Pnk_user_font;
    cursors: array [0..6] of Pnk_cursor;
    cursor_active: Pnk_cursor;
    cursor_last: Pnk_cursor;
    cursor_visible: Integer;
    text: nk_style_text;
    button: nk_style_button;
    contextual_button: nk_style_button;
    menu_button: nk_style_button;
    option: nk_style_toggle;
    checkbox: nk_style_toggle;
    selectable: nk_style_selectable;
    slider: nk_style_slider;
    progress: nk_style_progress;
    property_: nk_style_property;
    edit: nk_style_edit;
    chart: nk_style_chart;
    scrollh: nk_style_scrollbar;
    scrollv: nk_style_scrollbar;
    tab: nk_style_tab;
    combo: nk_style_combo;
    window: nk_style_window;
  end;

  { nk_chart_slot }
  nk_chart_slot = record
    color: nk_color;
    highlight: nk_color;
    min: Single;
    max: Single;
    range: Single;
    count: Integer;
    last: nk_vec2;
    index: Integer;
  end;

  { nk_chart }
  nk_chart = record
    slot: Integer;
    x: Single;
    y: Single;
    w: Single;
    h: Single;
    slots: array [0..3] of nk_chart_slot;
  end;

  { nk_row_layout }
  nk_row_layout = record
    index: Integer;
    height: Single;
    min_height: Single;
    columns: Integer;
    ratio: PSingle;
    item_width: Single;
    item_height: Single;
    item_offset: Single;
    filled: Single;
    item: nk_rect;
    tree_depth: Integer;
    templates: array [0..15] of Single;
  end;

  { nk_popup_buffer }
  nk_popup_buffer = record
    begin_: nk_size;
    parent: nk_size;
    last: nk_size;
    end_: nk_size;
    active: nk_bool;
  end;

  { nk_menu_state }
  nk_menu_state = record
    x: Single;
    y: Single;
    w: Single;
    h: Single;
    offset: nk_scroll;
  end;

  { nk_panel }
  nk_panel = record
    flags: nk_flags;
    bounds: nk_rect;
    offset_x: Pnk_uint;
    offset_y: Pnk_uint;
    at_x: Single;
    at_y: Single;
    max_x: Single;
    footer_height: Single;
    header_height: Single;
    border: Single;
    has_scrolling: Cardinal;
    clip: nk_rect;
    menu: nk_menu_state;
    row: nk_row_layout;
    chart: nk_chart;
    buffer: Pnk_command_buffer;
    parent: Pnk_panel;
  end;

  { nk_popup_state }
  nk_popup_state = record
    win: Pnk_window;
    buf: nk_popup_buffer;
    name: nk_hash;
    active: nk_bool;
    combo_count: Cardinal;
    con_count: Cardinal;
    con_old: Cardinal;
    active_con: Cardinal;
    header: nk_rect;
  end;

  { nk_edit_state }
  nk_edit_state = record
    name: nk_hash;
    seq: Cardinal;
    old: Cardinal;
    active: Integer;
    prev: Integer;
    cursor: Integer;
    sel_start: Integer;
    sel_end: Integer;
    scrollbar: nk_scroll;
    mode: Byte;
    single_line: Byte;
  end;

  { nk_property_state }
  nk_property_state = record
    active: Integer;
    prev: Integer;
    buffer: array [0..63] of UTF8Char;
    length: Integer;
    cursor: Integer;
    select_start: Integer;
    select_end: Integer;
    name: nk_hash;
    seq: Cardinal;
    old: Cardinal;
    state: Integer;
  end;

  { nk_window }
  nk_window = record
    seq: Cardinal;
    name: nk_hash;
    name_string: array [0..63] of UTF8Char;
    flags: nk_flags;
    bounds: nk_rect;
    scrollbar: nk_scroll;
    buffer: nk_command_buffer;
    layout: Pnk_panel;
    scrollbar_hiding_timer: Single;
    property_: nk_property_state;
    popup: nk_popup_state;
    edit: nk_edit_state;
    scrolled: Cardinal;
    tables: Pnk_table;
    table_count: Cardinal;
    next: Pnk_window;
    prev: Pnk_window;
    parent: Pnk_window;
  end;

  { nk_config_stack_style_item_element }
  nk_config_stack_style_item_element = record
    address: Pnk_style_item;
    old_value: nk_style_item;
  end;

  { nk_config_stack_float_element }
  nk_config_stack_float_element = record
    address: PSingle;
    old_value: Single;
  end;

  { nk_config_stack_vec2_element }
  nk_config_stack_vec2_element = record
    address: Pnk_vec2;
    old_value: nk_vec2;
  end;

  { nk_config_stack_flags_element }
  nk_config_stack_flags_element = record
    address: Pnk_flags;
    old_value: nk_flags;
  end;

  { nk_config_stack_color_element }
  nk_config_stack_color_element = record
    address: Pnk_color;
    old_value: nk_color;
  end;

  { nk_config_stack_user_font_element }
  nk_config_stack_user_font_element = record
    address: PPnk_user_font;
    old_value: Pnk_user_font;
  end;

  { nk_config_stack_button_behavior_element }
  nk_config_stack_button_behavior_element = record
    address: Pnk_button_behavior;
    old_value: nk_button_behavior;
  end;

  { nk_config_stack_style_item }
  nk_config_stack_style_item = record
    head: Integer;
    elements: array [0..15] of nk_config_stack_style_item_element;
  end;

  { nk_config_stack_float }
  nk_config_stack_float = record
    head: Integer;
    elements: array [0..31] of nk_config_stack_float_element;
  end;

  { nk_config_stack_vec2 }
  nk_config_stack_vec2 = record
    head: Integer;
    elements: array [0..15] of nk_config_stack_vec2_element;
  end;

  { nk_config_stack_flags }
  nk_config_stack_flags = record
    head: Integer;
    elements: array [0..31] of nk_config_stack_flags_element;
  end;

  { nk_config_stack_color }
  nk_config_stack_color = record
    head: Integer;
    elements: array [0..31] of nk_config_stack_color_element;
  end;

  { nk_config_stack_user_font }
  nk_config_stack_user_font = record
    head: Integer;
    elements: array [0..7] of nk_config_stack_user_font_element;
  end;

  { nk_config_stack_button_behavior }
  nk_config_stack_button_behavior = record
    head: Integer;
    elements: array [0..7] of nk_config_stack_button_behavior_element;
  end;

  { nk_configuration_stacks }
  nk_configuration_stacks = record
    style_items: nk_config_stack_style_item;
    floats: nk_config_stack_float;
    vectors: nk_config_stack_vec2;
    flags: nk_config_stack_flags;
    colors: nk_config_stack_color;
    fonts: nk_config_stack_user_font;
    button_behaviors: nk_config_stack_button_behavior;
  end;

  { nk_table }
  nk_table = record
    seq: Cardinal;
    size: Cardinal;
    keys: array [0..58] of nk_hash;
    values: array [0..58] of nk_uint;
    next: Pnk_table;
    prev: Pnk_table;
  end;

  { nk_page_data }
  nk_page_data = record
    case Integer of
      0: (tbl: nk_table);
      1: (pan: nk_panel);
      2: (win: nk_window);
  end;

  { nk_page_element }
  nk_page_element = record
    data: nk_page_data;
    next: Pnk_page_element;
    prev: Pnk_page_element;
  end;

  { nk_page }
  nk_page = record
    size: Cardinal;
    next: Pnk_page;
    win: array [0..0] of nk_page_element;
  end;

  { nk_pool }
  nk_pool = record
    alloc: nk_allocator;
    page_count: Cardinal;
    pages: Pnk_page;
    freelist: Pnk_page_element;
    capacity: Cardinal;
    size: nk_size;
    cap: nk_size;
  end;

  { nk_context }
  nk_context = record
    input: nk_input;
    style: nk_style;
    memory: nk_buffer;
    clip: nk_clipboard;
    last_widget_state: nk_flags;
    button_behavior: nk_button_behavior;
    stacks: nk_configuration_stacks;
    delta_time_seconds: Single;
    text_edit: nk_text_edit;
    overlay: nk_command_buffer;
    build: Integer;
    use_pool: Integer;
    pool: nk_pool;
    begin_: Pnk_window;
    end_: Pnk_window;
    active: Pnk_window;
    current: Pnk_window;
    freelist: Pnk_page_element;
    count: Cardinal;
    seq: Cardinal;
  end;

  { al_run_main_ }
  al_run_main_ = function(p1: Integer; p2: PPUTF8Char): Integer; cdecl;

  { al_emit_user_event_dtor }
  al_emit_user_event_dtor = procedure(p1: PALLEGRO_USER_EVENT); cdecl;

  { al_register_assert_handler_handler }
  al_register_assert_handler_handler = procedure(const expr: PUTF8Char; const file_: PUTF8Char; line: Integer; const func: PUTF8Char); cdecl;

  { al_register_trace_handler_handler }
  al_register_trace_handler_handler = procedure(const p1: PUTF8Char); cdecl;

  { al_for_each_fs_entry_callback }
  al_for_each_fs_entry_callback = function(entry: PALLEGRO_FS_ENTRY; extra: Pointer): Integer; cdecl;

  { atexit_ptr_ }
  atexit_ptr_ = Pointer;

  { al_install_system_atexit_ptr }
  al_install_system_atexit_ptr = function(p1: atexit_ptr_): Integer; cdecl;

  { al_create_thread_proc }
  al_create_thread_proc = function(thread: PALLEGRO_THREAD; arg: Pointer): Pointer; cdecl;

  { al_create_thread_with_stacksize_proc }
  al_create_thread_with_stacksize_proc = function(thread: PALLEGRO_THREAD; arg: Pointer): Pointer; cdecl;

  { al_run_detached_thread_proc }
  al_run_detached_thread_proc = function(arg: Pointer): Pointer; cdecl;

  { al_set_mixer_postprocess_callback_cb }
  al_set_mixer_postprocess_callback_cb = procedure(buf: Pointer; samples: Cardinal; data: Pointer); cdecl;

  { al_register_sample_loader_loader }
  al_register_sample_loader_loader = function(const filename: PUTF8Char): PALLEGRO_SAMPLE; cdecl;

  { al_register_sample_saver_saver }
  al_register_sample_saver_saver = function(const filename: PUTF8Char; spl: PALLEGRO_SAMPLE): Boolean; cdecl;

  { al_register_audio_stream_loader_stream_loader }
  al_register_audio_stream_loader_stream_loader = function(const filename: PUTF8Char; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl;

  { al_register_sample_loader_f_loader }
  al_register_sample_loader_f_loader = function(fp: PALLEGRO_FILE): PALLEGRO_SAMPLE; cdecl;

  { al_register_sample_saver_f_saver }
  al_register_sample_saver_f_saver = function(fp: PALLEGRO_FILE; spl: PALLEGRO_SAMPLE): Boolean; cdecl;

  { al_register_audio_stream_loader_f_stream_loader }
  al_register_audio_stream_loader_f_stream_loader = function(fp: PALLEGRO_FILE; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl;

  { al_register_sample_identifier_identifier }
  al_register_sample_identifier_identifier = function(fp: PALLEGRO_FILE): Boolean; cdecl;

  { al_register_font_loader_load }
  al_register_font_loader_load = function(const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl;

  { al_do_multiline_text_cb }
  al_do_multiline_text_cb = function(line_num: Integer; const line: PUTF8Char; size: Integer; extra: Pointer): Boolean; cdecl;

  { al_do_multiline_ustr_cb }
  al_do_multiline_ustr_cb = function(line_num: Integer; const line: PALLEGRO_USTR; extra: Pointer): Boolean; cdecl;

  { al_triangulate_polygon_emit_triangle }
  al_triangulate_polygon_emit_triangle = procedure(p1: Integer; p2: Integer; p3: Integer; p4: Pointer); cdecl;

  { al_draw_soft_triangle_init }
  al_draw_soft_triangle_init = procedure(p1: UIntPtr; p2: PALLEGRO_VERTEX; p3: PALLEGRO_VERTEX; p4: PALLEGRO_VERTEX); cdecl;

  { al_draw_soft_triangle_first }
  al_draw_soft_triangle_first = procedure(p1: UIntPtr; p2: Integer; p3: Integer; p4: Integer; p5: Integer); cdecl;

  { al_draw_soft_triangle_step }
  al_draw_soft_triangle_step = procedure(p1: UIntPtr; p2: Integer); cdecl;

  { al_draw_soft_triangle_draw }
  al_draw_soft_triangle_draw = procedure(p1: UIntPtr; p2: Integer; p3: Integer; p4: Integer); cdecl;

  { al_draw_soft_line_first }
  al_draw_soft_line_first = procedure(p1: UIntPtr; p2: Integer; p3: Integer; p4: PALLEGRO_VERTEX; p5: PALLEGRO_VERTEX); cdecl;

  { al_draw_soft_line_step }
  al_draw_soft_line_step = procedure(p1: UIntPtr; p2: Integer); cdecl;

  { al_draw_soft_line_draw }
  al_draw_soft_line_draw = procedure(p1: UIntPtr; p2: Integer; p3: Integer); cdecl;

  { nk_plot_function_value_getter }
  nk_plot_function_value_getter = function(user: Pointer; index: Integer): Single; cdecl;

  { nk_combo_callback_item_getter }
  nk_combo_callback_item_getter = procedure(p1: Pointer; p2: Integer; p3: PPUTF8Char); cdecl;

  { nk_combobox_callback_item_getter }
  nk_combobox_callback_item_getter = procedure(p1: Pointer; p2: Integer; p3: PPUTF8Char); cdecl;

var
  al_get_allegro_version: function(): UInt32; cdecl;
  al_run_main: function(argc: Integer; argv: PPUTF8Char; p3: al_run_main_): Integer; cdecl;
  al_get_time: function(): Double; cdecl;
  al_rest: procedure(seconds: Double); cdecl;
  al_init_timeout: procedure(timeout: PALLEGRO_TIMEOUT; seconds: Double); cdecl;
  al_map_rgb: function(r: Byte; g: Byte; b: Byte): ALLEGRO_COLOR; cdecl;
  al_map_rgba: function(r: Byte; g: Byte; b: Byte; a: Byte): ALLEGRO_COLOR; cdecl;
  al_map_rgb_f: function(r: Single; g: Single; b: Single): ALLEGRO_COLOR; cdecl;
  al_map_rgba_f: function(r: Single; g: Single; b: Single; a: Single): ALLEGRO_COLOR; cdecl;
  al_premul_rgba: function(r: Byte; g: Byte; b: Byte; a: Byte): ALLEGRO_COLOR; cdecl;
  al_premul_rgba_f: function(r: Single; g: Single; b: Single; a: Single): ALLEGRO_COLOR; cdecl;
  al_unmap_rgb: procedure(color: ALLEGRO_COLOR; r: PByte; g: PByte; b: PByte); cdecl;
  al_unmap_rgba: procedure(color: ALLEGRO_COLOR; r: PByte; g: PByte; b: PByte; a: PByte); cdecl;
  al_unmap_rgb_f: procedure(color: ALLEGRO_COLOR; r: PSingle; g: PSingle; b: PSingle); cdecl;
  al_unmap_rgba_f: procedure(color: ALLEGRO_COLOR; r: PSingle; g: PSingle; b: PSingle; a: PSingle); cdecl;
  al_get_pixel_size: function(format: Integer): Integer; cdecl;
  al_get_pixel_format_bits: function(format: Integer): Integer; cdecl;
  al_get_pixel_block_size: function(format: Integer): Integer; cdecl;
  al_get_pixel_block_width: function(format: Integer): Integer; cdecl;
  al_get_pixel_block_height: function(format: Integer): Integer; cdecl;
  al_set_new_bitmap_format: procedure(format: Integer); cdecl;
  al_set_new_bitmap_flags: procedure(flags: Integer); cdecl;
  al_get_new_bitmap_format: function(): Integer; cdecl;
  al_get_new_bitmap_flags: function(): Integer; cdecl;
  al_add_new_bitmap_flag: procedure(flag: Integer); cdecl;
  al_get_new_bitmap_depth: function(): Integer; cdecl;
  al_set_new_bitmap_depth: procedure(depth: Integer); cdecl;
  al_get_new_bitmap_samples: function(): Integer; cdecl;
  al_set_new_bitmap_samples: procedure(samples: Integer); cdecl;
  al_get_new_bitmap_wrap: procedure(u: PALLEGRO_BITMAP_WRAP; v: PALLEGRO_BITMAP_WRAP); cdecl;
  al_set_new_bitmap_wrap: procedure(u: ALLEGRO_BITMAP_WRAP; v: ALLEGRO_BITMAP_WRAP); cdecl;
  al_get_bitmap_width: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_height: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_format: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_flags: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_depth: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_samples: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_create_bitmap: function(w: Integer; h: Integer): PALLEGRO_BITMAP; cdecl;
  al_destroy_bitmap: procedure(bitmap: PALLEGRO_BITMAP); cdecl;
  al_put_pixel: procedure(x: Integer; y: Integer; color: ALLEGRO_COLOR); cdecl;
  al_put_blended_pixel: procedure(x: Integer; y: Integer; color: ALLEGRO_COLOR); cdecl;
  al_get_pixel: function(bitmap: PALLEGRO_BITMAP; x: Integer; y: Integer): ALLEGRO_COLOR; cdecl;
  al_convert_mask_to_alpha: procedure(bitmap: PALLEGRO_BITMAP; mask_color: ALLEGRO_COLOR); cdecl;
  al_get_bitmap_blend_color: function(): ALLEGRO_COLOR; cdecl;
  al_get_bitmap_blender: procedure(op: PInteger; src: PInteger; dst: PInteger); cdecl;
  al_get_separate_bitmap_blender: procedure(op: PInteger; src: PInteger; dst: PInteger; alpha_op: PInteger; alpha_src: PInteger; alpha_dst: PInteger); cdecl;
  al_set_bitmap_blend_color: procedure(color: ALLEGRO_COLOR); cdecl;
  al_set_bitmap_blender: procedure(op: Integer; src: Integer; dst: Integer); cdecl;
  al_set_separate_bitmap_blender: procedure(op: Integer; src: Integer; dst: Integer; alpha_op: Integer; alpha_src: Integer; alpha_dst: Integer); cdecl;
  al_reset_bitmap_blender: procedure(); cdecl;
  al_set_clipping_rectangle: procedure(x: Integer; y: Integer; width: Integer; height: Integer); cdecl;
  al_reset_clipping_rectangle: procedure(); cdecl;
  al_get_clipping_rectangle: procedure(x: PInteger; y: PInteger; w: PInteger; h: PInteger); cdecl;
  al_create_sub_bitmap: function(parent: PALLEGRO_BITMAP; x: Integer; y: Integer; w: Integer; h: Integer): PALLEGRO_BITMAP; cdecl;
  al_is_sub_bitmap: function(bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  al_get_parent_bitmap: function(bitmap: PALLEGRO_BITMAP): PALLEGRO_BITMAP; cdecl;
  al_get_bitmap_x: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_y: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_reparent_bitmap: procedure(bitmap: PALLEGRO_BITMAP; parent: PALLEGRO_BITMAP; x: Integer; y: Integer; w: Integer; h: Integer); cdecl;
  al_clone_bitmap: function(bitmap: PALLEGRO_BITMAP): PALLEGRO_BITMAP; cdecl;
  al_convert_bitmap: procedure(bitmap: PALLEGRO_BITMAP); cdecl;
  al_convert_memory_bitmaps: procedure(); cdecl;
  al_backup_dirty_bitmap: procedure(bitmap: PALLEGRO_BITMAP); cdecl;
  al_draw_bitmap: procedure(bitmap: PALLEGRO_BITMAP; dx: Single; dy: Single; flags: Integer); cdecl;
  al_draw_bitmap_region: procedure(bitmap: PALLEGRO_BITMAP; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; flags: Integer); cdecl;
  al_draw_scaled_bitmap: procedure(bitmap: PALLEGRO_BITMAP; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; dw: Single; dh: Single; flags: Integer); cdecl;
  al_draw_rotated_bitmap: procedure(bitmap: PALLEGRO_BITMAP; cx: Single; cy: Single; dx: Single; dy: Single; angle: Single; flags: Integer); cdecl;
  al_draw_scaled_rotated_bitmap: procedure(bitmap: PALLEGRO_BITMAP; cx: Single; cy: Single; dx: Single; dy: Single; xscale: Single; yscale: Single; angle: Single; flags: Integer); cdecl;
  al_draw_tinted_bitmap: procedure(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; dx: Single; dy: Single; flags: Integer); cdecl;
  al_draw_tinted_bitmap_region: procedure(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; flags: Integer); cdecl;
  al_draw_tinted_scaled_bitmap: procedure(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; dw: Single; dh: Single; flags: Integer); cdecl;
  al_draw_tinted_rotated_bitmap: procedure(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; cx: Single; cy: Single; dx: Single; dy: Single; angle: Single; flags: Integer); cdecl;
  al_draw_tinted_scaled_rotated_bitmap: procedure(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; cx: Single; cy: Single; dx: Single; dy: Single; xscale: Single; yscale: Single; angle: Single; flags: Integer); cdecl;
  al_draw_tinted_scaled_rotated_bitmap_region: procedure(bitmap: PALLEGRO_BITMAP; sx: Single; sy: Single; sw: Single; sh: Single; tint: ALLEGRO_COLOR; cx: Single; cy: Single; dx: Single; dy: Single; xscale: Single; yscale: Single; angle: Single; flags: Integer); cdecl;
  al_ustr_new: function(const s: PUTF8Char): PALLEGRO_USTR; cdecl;
  al_ustr_new_from_buffer: function(const s: PUTF8Char; size: NativeUInt): PALLEGRO_USTR; cdecl;
  al_ustr_newf: function(const fmt: PUTF8Char): PALLEGRO_USTR varargs; cdecl;
  al_ustr_free: procedure(us: PALLEGRO_USTR); cdecl;
  al_cstr: function(const us: PALLEGRO_USTR): PUTF8Char; cdecl;
  al_ustr_to_buffer: procedure(const us: PALLEGRO_USTR; buffer: PUTF8Char; size: Integer); cdecl;
  al_cstr_dup: function(const us: PALLEGRO_USTR): PUTF8Char; cdecl;
  al_ustr_dup: function(const us: PALLEGRO_USTR): PALLEGRO_USTR; cdecl;
  al_ustr_dup_substr: function(const us: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): PALLEGRO_USTR; cdecl;
  al_ustr_empty_string: function(): PALLEGRO_USTR; cdecl;
  al_ref_cstr: function(info: PALLEGRO_USTR_INFO; const s: PUTF8Char): PALLEGRO_USTR; cdecl;
  al_ref_buffer: function(info: PALLEGRO_USTR_INFO; const s: PUTF8Char; size: NativeUInt): PALLEGRO_USTR; cdecl;
  al_ref_ustr: function(info: PALLEGRO_USTR_INFO; const us: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): PALLEGRO_USTR; cdecl;
  al_ustr_size: function(const us: PALLEGRO_USTR): NativeUInt; cdecl;
  al_ustr_length: function(const us: PALLEGRO_USTR): NativeUInt; cdecl;
  al_ustr_offset: function(const us: PALLEGRO_USTR; index: Integer): Integer; cdecl;
  al_ustr_next: function(const us: PALLEGRO_USTR; pos: PInteger): Boolean; cdecl;
  al_ustr_prev: function(const us: PALLEGRO_USTR; pos: PInteger): Boolean; cdecl;
  al_ustr_get: function(const us: PALLEGRO_USTR; pos: Integer): Int32; cdecl;
  al_ustr_get_next: function(const us: PALLEGRO_USTR; pos: PInteger): Int32; cdecl;
  al_ustr_prev_get: function(const us: PALLEGRO_USTR; pos: PInteger): Int32; cdecl;
  al_ustr_insert: function(us1: PALLEGRO_USTR; pos: Integer; const us2: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_insert_cstr: function(us: PALLEGRO_USTR; pos: Integer; const us2: PUTF8Char): Boolean; cdecl;
  al_ustr_insert_chr: function(us: PALLEGRO_USTR; pos: Integer; c: Int32): NativeUInt; cdecl;
  al_ustr_append: function(us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_append_cstr: function(us: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl;
  al_ustr_append_chr: function(us: PALLEGRO_USTR; c: Int32): NativeUInt; cdecl;
  al_ustr_appendf: function(us: PALLEGRO_USTR; const fmt: PUTF8Char): Boolean varargs; cdecl;
  al_ustr_vappendf: function(us: PALLEGRO_USTR; const fmt: PUTF8Char; ap: Pointer): Boolean; cdecl;
  al_ustr_remove_chr: function(us: PALLEGRO_USTR; pos: Integer): Boolean; cdecl;
  al_ustr_remove_range: function(us: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): Boolean; cdecl;
  al_ustr_truncate: function(us: PALLEGRO_USTR; start_pos: Integer): Boolean; cdecl;
  al_ustr_ltrim_ws: function(us: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_rtrim_ws: function(us: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_trim_ws: function(us: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_assign: function(us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_assign_substr: function(us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): Boolean; cdecl;
  al_ustr_assign_cstr: function(us1: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl;
  al_ustr_set_chr: function(us: PALLEGRO_USTR; pos: Integer; c: Int32): NativeUInt; cdecl;
  al_ustr_replace_range: function(us1: PALLEGRO_USTR; start_pos1: Integer; end_pos1: Integer; const us2: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_find_chr: function(const us: PALLEGRO_USTR; start_pos: Integer; c: Int32): Integer; cdecl;
  al_ustr_rfind_chr: function(const us: PALLEGRO_USTR; start_pos: Integer; c: Int32): Integer; cdecl;
  al_ustr_find_set: function(const us: PALLEGRO_USTR; start_pos: Integer; const accept: PALLEGRO_USTR): Integer; cdecl;
  al_ustr_find_set_cstr: function(const us: PALLEGRO_USTR; start_pos: Integer; const accept: PUTF8Char): Integer; cdecl;
  al_ustr_find_cset: function(const us: PALLEGRO_USTR; start_pos: Integer; const reject: PALLEGRO_USTR): Integer; cdecl;
  al_ustr_find_cset_cstr: function(const us: PALLEGRO_USTR; start_pos: Integer; const reject: PUTF8Char): Integer; cdecl;
  al_ustr_find_str: function(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PALLEGRO_USTR): Integer; cdecl;
  al_ustr_find_cstr: function(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PUTF8Char): Integer; cdecl;
  al_ustr_rfind_str: function(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PALLEGRO_USTR): Integer; cdecl;
  al_ustr_rfind_cstr: function(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PUTF8Char): Integer; cdecl;
  al_ustr_find_replace: function(us: PALLEGRO_USTR; start_pos: Integer; const find: PALLEGRO_USTR; const replace: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_find_replace_cstr: function(us: PALLEGRO_USTR; start_pos: Integer; const find: PUTF8Char; const replace: PUTF8Char): Boolean; cdecl;
  al_ustr_equal: function(const us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_compare: function(const u: PALLEGRO_USTR; const v: PALLEGRO_USTR): Integer; cdecl;
  al_ustr_ncompare: function(const us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR; n: Integer): Integer; cdecl;
  al_ustr_has_prefix: function(const u: PALLEGRO_USTR; const v: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_has_prefix_cstr: function(const u: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl;
  al_ustr_has_suffix: function(const u: PALLEGRO_USTR; const v: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_has_suffix_cstr: function(const us1: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl;
  al_utf8_width: function(c: Int32): NativeUInt; cdecl;
  al_utf8_encode: function(s: PUTF8Char; c: Int32): NativeUInt; cdecl;
  al_ustr_new_from_utf16: function(const s: PUInt16): PALLEGRO_USTR; cdecl;
  al_ustr_size_utf16: function(const us: PALLEGRO_USTR): NativeUInt; cdecl;
  al_ustr_encode_utf16: function(const us: PALLEGRO_USTR; s: PUInt16; n: NativeUInt): NativeUInt; cdecl;
  al_utf16_width: function(c: Integer): NativeUInt; cdecl;
  al_utf16_encode: function(s: PUInt16; c: Int32): NativeUInt; cdecl;
  al_create_path: function(const str: PUTF8Char): PALLEGRO_PATH; cdecl;
  al_create_path_for_directory: function(const str: PUTF8Char): PALLEGRO_PATH; cdecl;
  al_clone_path: function(const path: PALLEGRO_PATH): PALLEGRO_PATH; cdecl;
  al_get_path_num_components: function(const path: PALLEGRO_PATH): Integer; cdecl;
  al_get_path_component: function(const path: PALLEGRO_PATH; i: Integer): PUTF8Char; cdecl;
  al_replace_path_component: procedure(path: PALLEGRO_PATH; i: Integer; const s: PUTF8Char); cdecl;
  al_remove_path_component: procedure(path: PALLEGRO_PATH; i: Integer); cdecl;
  al_insert_path_component: procedure(path: PALLEGRO_PATH; i: Integer; const s: PUTF8Char); cdecl;
  al_get_path_tail: function(const path: PALLEGRO_PATH): PUTF8Char; cdecl;
  al_drop_path_tail: procedure(path: PALLEGRO_PATH); cdecl;
  al_append_path_component: procedure(path: PALLEGRO_PATH; const s: PUTF8Char); cdecl;
  al_join_paths: function(path: PALLEGRO_PATH; const tail: PALLEGRO_PATH): Boolean; cdecl;
  al_rebase_path: function(const head: PALLEGRO_PATH; tail: PALLEGRO_PATH): Boolean; cdecl;
  al_path_cstr: function(const path: PALLEGRO_PATH; delim: UTF8Char): PUTF8Char; cdecl;
  al_path_ustr: function(const path: PALLEGRO_PATH; delim: UTF8Char): PALLEGRO_USTR; cdecl;
  al_destroy_path: procedure(path: PALLEGRO_PATH); cdecl;
  al_set_path_drive: procedure(path: PALLEGRO_PATH; const drive: PUTF8Char); cdecl;
  al_get_path_drive: function(const path: PALLEGRO_PATH): PUTF8Char; cdecl;
  al_set_path_filename: procedure(path: PALLEGRO_PATH; const filename: PUTF8Char); cdecl;
  al_get_path_filename: function(const path: PALLEGRO_PATH): PUTF8Char; cdecl;
  al_get_path_extension: function(const path: PALLEGRO_PATH): PUTF8Char; cdecl;
  al_set_path_extension: function(path: PALLEGRO_PATH; const extension: PUTF8Char): Boolean; cdecl;
  al_get_path_basename: function(const path: PALLEGRO_PATH): PUTF8Char; cdecl;
  al_make_path_canonical: function(path: PALLEGRO_PATH): Boolean; cdecl;
  al_fopen: function(const path: PUTF8Char; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_fopen_interface: function(const vt: PALLEGRO_FILE_INTERFACE; const path: PUTF8Char; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_create_file_handle: function(const vt: PALLEGRO_FILE_INTERFACE; userdata: Pointer): PALLEGRO_FILE; cdecl;
  al_fclose: function(f: PALLEGRO_FILE): Boolean; cdecl;
  al_fread: function(f: PALLEGRO_FILE; ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
  al_fwrite: function(f: PALLEGRO_FILE; const ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
  al_fflush: function(f: PALLEGRO_FILE): Boolean; cdecl;
  al_ftell: function(f: PALLEGRO_FILE): Int64; cdecl;
  al_fseek: function(f: PALLEGRO_FILE; offset: Int64; whence: Integer): Boolean; cdecl;
  al_feof: function(f: PALLEGRO_FILE): Boolean; cdecl;
  al_ferror: function(f: PALLEGRO_FILE): Integer; cdecl;
  al_ferrmsg: function(f: PALLEGRO_FILE): PUTF8Char; cdecl;
  al_fclearerr: procedure(f: PALLEGRO_FILE); cdecl;
  al_fungetc: function(f: PALLEGRO_FILE; c: Integer): Integer; cdecl;
  al_fsize: function(f: PALLEGRO_FILE): Int64; cdecl;
  al_fgetc: function(f: PALLEGRO_FILE): Integer; cdecl;
  al_fputc: function(f: PALLEGRO_FILE; c: Integer): Integer; cdecl;
  al_fread16le: function(f: PALLEGRO_FILE): Int16; cdecl;
  al_fread16be: function(f: PALLEGRO_FILE): Int16; cdecl;
  al_fwrite16le: function(f: PALLEGRO_FILE; w: Int16): NativeUInt; cdecl;
  al_fwrite16be: function(f: PALLEGRO_FILE; w: Int16): NativeUInt; cdecl;
  al_fread32le: function(f: PALLEGRO_FILE): Int32; cdecl;
  al_fread32be: function(f: PALLEGRO_FILE): Int32; cdecl;
  al_fwrite32le: function(f: PALLEGRO_FILE; l: Int32): NativeUInt; cdecl;
  al_fwrite32be: function(f: PALLEGRO_FILE; l: Int32): NativeUInt; cdecl;
  al_fgets: function(f: PALLEGRO_FILE; const p: PUTF8Char; max: NativeUInt): PUTF8Char; cdecl;
  al_fget_ustr: function(f: PALLEGRO_FILE): PALLEGRO_USTR; cdecl;
  al_fputs: function(f: PALLEGRO_FILE; const p: PUTF8Char): Integer; cdecl;
  al_fprintf: function(f: PALLEGRO_FILE; const format: PUTF8Char): Integer varargs; cdecl;
  al_vfprintf: function(f: PALLEGRO_FILE; const format: PUTF8Char; args: Pointer): Integer; cdecl;
  al_fopen_fd: function(fd: Integer; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_make_temp_file: function(const tmpl: PUTF8Char; ret_path: PPALLEGRO_PATH): PALLEGRO_FILE; cdecl;
  al_fopen_slice: function(fp: PALLEGRO_FILE; initial_size: NativeUInt; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_get_new_file_interface: function(): PALLEGRO_FILE_INTERFACE; cdecl;
  al_set_new_file_interface: procedure(const file_interface: PALLEGRO_FILE_INTERFACE); cdecl;
  al_set_standard_file_interface: procedure(); cdecl;
  al_get_file_userdata: function(f: PALLEGRO_FILE): Pointer; cdecl;
  al_register_bitmap_loader: function(const ext: PUTF8Char; loader: ALLEGRO_IIO_LOADER_FUNCTION): Boolean; cdecl;
  al_register_bitmap_saver: function(const ext: PUTF8Char; saver: ALLEGRO_IIO_SAVER_FUNCTION): Boolean; cdecl;
  al_register_bitmap_loader_f: function(const ext: PUTF8Char; fs_loader: ALLEGRO_IIO_FS_LOADER_FUNCTION): Boolean; cdecl;
  al_register_bitmap_saver_f: function(const ext: PUTF8Char; fs_saver: ALLEGRO_IIO_FS_SAVER_FUNCTION): Boolean; cdecl;
  al_register_bitmap_identifier: function(const ext: PUTF8Char; identifier: ALLEGRO_IIO_IDENTIFIER_FUNCTION): Boolean; cdecl;
  al_load_bitmap: function(const filename: PUTF8Char): PALLEGRO_BITMAP; cdecl;
  al_load_bitmap_flags: function(const filename: PUTF8Char; flags: Integer): PALLEGRO_BITMAP; cdecl;
  al_load_bitmap_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char): PALLEGRO_BITMAP; cdecl;
  al_load_bitmap_flags_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char; flags: Integer): PALLEGRO_BITMAP; cdecl;
  al_save_bitmap: function(const filename: PUTF8Char; bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  al_save_bitmap_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char; bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  al_identify_bitmap_f: function(fp: PALLEGRO_FILE): PUTF8Char; cdecl;
  al_identify_bitmap: function(const filename: PUTF8Char): PUTF8Char; cdecl;
  al_lock_bitmap: function(bitmap: PALLEGRO_BITMAP; format: Integer; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl;
  al_lock_bitmap_region: function(bitmap: PALLEGRO_BITMAP; x: Integer; y: Integer; width: Integer; height: Integer; format: Integer; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl;
  al_lock_bitmap_blocked: function(bitmap: PALLEGRO_BITMAP; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl;
  al_lock_bitmap_region_blocked: function(bitmap: PALLEGRO_BITMAP; x_block: Integer; y_block: Integer; width_block: Integer; height_block: Integer; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl;
  al_unlock_bitmap: procedure(bitmap: PALLEGRO_BITMAP); cdecl;
  al_is_bitmap_locked: function(bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  al_set_blender: procedure(op: Integer; source: Integer; dest: Integer); cdecl;
  al_set_blend_color: procedure(color: ALLEGRO_COLOR); cdecl;
  al_get_blender: procedure(op: PInteger; source: PInteger; dest: PInteger); cdecl;
  al_get_blend_color: function(): ALLEGRO_COLOR; cdecl;
  al_set_separate_blender: procedure(op: Integer; source: Integer; dest: Integer; alpha_op: Integer; alpha_source: Integer; alpha_dest: Integer); cdecl;
  al_get_separate_blender: procedure(op: PInteger; source: PInteger; dest: PInteger; alpha_op: PInteger; alpha_src: PInteger; alpha_dest: PInteger); cdecl;
  al_init_user_event_source: procedure(p1: PALLEGRO_EVENT_SOURCE); cdecl;
  al_destroy_user_event_source: procedure(p1: PALLEGRO_EVENT_SOURCE); cdecl;
  al_emit_user_event: function(p1: PALLEGRO_EVENT_SOURCE; p2: PALLEGRO_EVENT; dtor: al_emit_user_event_dtor): Boolean; cdecl;
  al_unref_user_event: procedure(p1: PALLEGRO_USER_EVENT); cdecl;
  al_set_event_source_data: procedure(p1: PALLEGRO_EVENT_SOURCE; data: IntPtr); cdecl;
  al_get_event_source_data: function(const p1: PALLEGRO_EVENT_SOURCE): IntPtr; cdecl;
  al_create_event_queue: function(): PALLEGRO_EVENT_QUEUE; cdecl;
  al_destroy_event_queue: procedure(p1: PALLEGRO_EVENT_QUEUE); cdecl;
  al_is_event_source_registered: function(p1: PALLEGRO_EVENT_QUEUE; p2: PALLEGRO_EVENT_SOURCE): Boolean; cdecl;
  al_register_event_source: procedure(p1: PALLEGRO_EVENT_QUEUE; p2: PALLEGRO_EVENT_SOURCE); cdecl;
  al_unregister_event_source: procedure(p1: PALLEGRO_EVENT_QUEUE; p2: PALLEGRO_EVENT_SOURCE); cdecl;
  al_pause_event_queue: procedure(p1: PALLEGRO_EVENT_QUEUE; p2: Boolean); cdecl;
  al_is_event_queue_paused: function(const p1: PALLEGRO_EVENT_QUEUE): Boolean; cdecl;
  al_is_event_queue_empty: function(p1: PALLEGRO_EVENT_QUEUE): Boolean; cdecl;
  al_get_next_event: function(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT): Boolean; cdecl;
  al_peek_next_event: function(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT): Boolean; cdecl;
  al_drop_next_event: function(p1: PALLEGRO_EVENT_QUEUE): Boolean; cdecl;
  al_flush_event_queue: procedure(p1: PALLEGRO_EVENT_QUEUE); cdecl;
  al_wait_for_event: procedure(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT); cdecl;
  al_wait_for_event_timed: function(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT; secs: Single): Boolean; cdecl;
  al_wait_for_event_until: function(queue: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT; timeout: PALLEGRO_TIMEOUT): Boolean; cdecl;
  al_set_new_display_refresh_rate: procedure(refresh_rate: Integer); cdecl;
  al_set_new_display_flags: procedure(flags: Integer); cdecl;
  al_get_new_display_refresh_rate: function(): Integer; cdecl;
  al_get_new_display_flags: function(): Integer; cdecl;
  al_set_new_window_title: procedure(const title: PUTF8Char); cdecl;
  al_get_new_window_title: function(): PUTF8Char; cdecl;
  al_get_display_width: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_get_display_height: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_get_display_format: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_get_display_refresh_rate: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_get_display_flags: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_get_display_orientation: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_set_display_flag: function(display: PALLEGRO_DISPLAY; flag: Integer; onoff: Boolean): Boolean; cdecl;
  al_create_display: function(w: Integer; h: Integer): PALLEGRO_DISPLAY; cdecl;
  al_destroy_display: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_get_current_display: function(): PALLEGRO_DISPLAY; cdecl;
  al_set_target_bitmap: procedure(bitmap: PALLEGRO_BITMAP); cdecl;
  al_set_target_backbuffer: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_get_backbuffer: function(display: PALLEGRO_DISPLAY): PALLEGRO_BITMAP; cdecl;
  al_get_target_bitmap: function(): PALLEGRO_BITMAP; cdecl;
  al_acknowledge_resize: function(display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_resize_display: function(display: PALLEGRO_DISPLAY; width: Integer; height: Integer): Boolean; cdecl;
  al_flip_display: procedure(); cdecl;
  al_update_display_region: procedure(x: Integer; y: Integer; width: Integer; height: Integer); cdecl;
  al_is_compatible_bitmap: function(bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  al_wait_for_vsync: function(): Boolean; cdecl;
  al_get_display_event_source: function(display: PALLEGRO_DISPLAY): PALLEGRO_EVENT_SOURCE; cdecl;
  al_set_display_icon: procedure(display: PALLEGRO_DISPLAY; icon: PALLEGRO_BITMAP); cdecl;
  al_set_display_icons: procedure(display: PALLEGRO_DISPLAY; num_icons: Integer; icons: PPALLEGRO_BITMAP); cdecl;
  al_get_new_display_adapter: function(): Integer; cdecl;
  al_set_new_display_adapter: procedure(adapter: Integer); cdecl;
  al_set_new_window_position: procedure(x: Integer; y: Integer); cdecl;
  al_get_new_window_position: procedure(x: PInteger; y: PInteger); cdecl;
  al_set_window_position: procedure(display: PALLEGRO_DISPLAY; x: Integer; y: Integer); cdecl;
  al_get_window_position: procedure(display: PALLEGRO_DISPLAY; x: PInteger; y: PInteger); cdecl;
  al_get_win_window_handle: function(display: PALLEGRO_DISPLAY): HWND; cdecl;
  al_set_window_constraints: function(display: PALLEGRO_DISPLAY; min_w: Integer; min_h: Integer; max_w: Integer; max_h: Integer): Boolean; cdecl;
  al_get_window_constraints: function(display: PALLEGRO_DISPLAY; min_w: PInteger; min_h: PInteger; max_w: PInteger; max_h: PInteger): Boolean; cdecl;
  al_apply_window_constraints: procedure(display: PALLEGRO_DISPLAY; onoff: Boolean); cdecl;
  al_set_window_title: procedure(display: PALLEGRO_DISPLAY; const title: PUTF8Char); cdecl;
  al_set_new_display_option: procedure(option: Integer; value: Integer; importance: Integer); cdecl;
  al_get_new_display_option: function(option: Integer; importance: PInteger): Integer; cdecl;
  al_reset_new_display_options: procedure(); cdecl;
  al_set_display_option: procedure(display: PALLEGRO_DISPLAY; option: Integer; value: Integer); cdecl;
  al_get_display_option: function(display: PALLEGRO_DISPLAY; option: Integer): Integer; cdecl;
  al_hold_bitmap_drawing: procedure(hold: Boolean); cdecl;
  al_is_bitmap_drawing_held: function(): Boolean; cdecl;
  al_acknowledge_drawing_halt: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_acknowledge_drawing_resume: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_backup_dirty_bitmaps: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_get_clipboard_text: function(display: PALLEGRO_DISPLAY): PUTF8Char; cdecl;
  al_set_clipboard_text: function(display: PALLEGRO_DISPLAY; const text: PUTF8Char): Boolean; cdecl;
  al_clipboard_has_text: function(display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_create_config: function(): PALLEGRO_CONFIG; cdecl;
  al_add_config_section: procedure(config: PALLEGRO_CONFIG; const name: PUTF8Char); cdecl;
  al_set_config_value: procedure(config: PALLEGRO_CONFIG; const section: PUTF8Char; const key: PUTF8Char; const value: PUTF8Char); cdecl;
  al_add_config_comment: procedure(config: PALLEGRO_CONFIG; const section: PUTF8Char; const comment: PUTF8Char); cdecl;
  al_get_config_value: function(const config: PALLEGRO_CONFIG; const section: PUTF8Char; const key: PUTF8Char): PUTF8Char; cdecl;
  al_load_config_file: function(const filename: PUTF8Char): PALLEGRO_CONFIG; cdecl;
  al_load_config_file_f: function(filename: PALLEGRO_FILE): PALLEGRO_CONFIG; cdecl;
  al_save_config_file: function(const filename: PUTF8Char; const config: PALLEGRO_CONFIG): Boolean; cdecl;
  al_save_config_file_f: function(file_: PALLEGRO_FILE; const config: PALLEGRO_CONFIG): Boolean; cdecl;
  al_merge_config_into: procedure(master: PALLEGRO_CONFIG; const add: PALLEGRO_CONFIG); cdecl;
  al_merge_config: function(const cfg1: PALLEGRO_CONFIG; const cfg2: PALLEGRO_CONFIG): PALLEGRO_CONFIG; cdecl;
  al_destroy_config: procedure(config: PALLEGRO_CONFIG); cdecl;
  al_remove_config_section: function(config: PALLEGRO_CONFIG; const section: PUTF8Char): Boolean; cdecl;
  al_remove_config_key: function(config: PALLEGRO_CONFIG; const section: PUTF8Char; const key: PUTF8Char): Boolean; cdecl;
  al_get_first_config_section: function(const config: PALLEGRO_CONFIG; iterator: PPALLEGRO_CONFIG_SECTION): PUTF8Char; cdecl;
  al_get_next_config_section: function(iterator: PPALLEGRO_CONFIG_SECTION): PUTF8Char; cdecl;
  al_get_first_config_entry: function(const config: PALLEGRO_CONFIG; const section: PUTF8Char; iterator: PPALLEGRO_CONFIG_ENTRY): PUTF8Char; cdecl;
  al_get_next_config_entry: function(iterator: PPALLEGRO_CONFIG_ENTRY): PUTF8Char; cdecl;
  al_get_cpu_count: function(): Integer; cdecl;
  al_get_ram_size: function(): Integer; cdecl;
  _al_trace_prefix: function(const channel: PUTF8Char; level: Integer; const file_: PUTF8Char; line: Integer; const function_: PUTF8Char): Boolean; cdecl;
  _al_trace_suffix: procedure(const msg: PUTF8Char) varargs; cdecl;
  al_register_assert_handler: procedure(handler: al_register_assert_handler_handler); cdecl;
  al_register_trace_handler: procedure(handler: al_register_trace_handler_handler); cdecl;
  al_clear_to_color: procedure(color: ALLEGRO_COLOR); cdecl;
  al_clear_depth_buffer: procedure(x: Single); cdecl;
  al_draw_pixel: procedure(x: Single; y: Single; color: ALLEGRO_COLOR); cdecl;
  al_get_errno: function(): Integer; cdecl;
  al_set_errno: procedure(errnum: Integer); cdecl;
  al_fixsqrt: function(x: al_fixed): al_fixed; cdecl;
  al_fixhypot: function(x: al_fixed; y: al_fixed): al_fixed; cdecl;
  al_fixatan: function(x: al_fixed): al_fixed; cdecl;
  al_fixatan2: function(y: al_fixed; x: al_fixed): al_fixed; cdecl;
  al_create_fs_entry: function(const path: PUTF8Char): PALLEGRO_FS_ENTRY; cdecl;
  al_destroy_fs_entry: procedure(e: PALLEGRO_FS_ENTRY); cdecl;
  al_get_fs_entry_name: function(e: PALLEGRO_FS_ENTRY): PUTF8Char; cdecl;
  al_update_fs_entry: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
  al_get_fs_entry_mode: function(e: PALLEGRO_FS_ENTRY): UInt32; cdecl;
  al_get_fs_entry_atime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
  al_get_fs_entry_mtime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
  al_get_fs_entry_ctime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
  al_get_fs_entry_size: function(e: PALLEGRO_FS_ENTRY): off_t; cdecl;
  al_fs_entry_exists: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
  al_remove_fs_entry: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
  al_open_directory: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
  al_read_directory: function(e: PALLEGRO_FS_ENTRY): PALLEGRO_FS_ENTRY; cdecl;
  al_close_directory: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
  al_filename_exists: function(const path: PUTF8Char): Boolean; cdecl;
  al_remove_filename: function(const path: PUTF8Char): Boolean; cdecl;
  al_get_current_directory: function(): PUTF8Char; cdecl;
  al_change_directory: function(const path: PUTF8Char): Boolean; cdecl;
  al_make_directory: function(const path: PUTF8Char): Boolean; cdecl;
  al_open_fs_entry: function(e: PALLEGRO_FS_ENTRY; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_for_each_fs_entry: function(dir: PALLEGRO_FS_ENTRY; callback: al_for_each_fs_entry_callback; extra: Pointer): Integer; cdecl;
  al_get_fs_interface: function(): PALLEGRO_FS_INTERFACE; cdecl;
  al_set_fs_interface: procedure(const vtable: PALLEGRO_FS_INTERFACE); cdecl;
  al_set_standard_fs_interface: procedure(); cdecl;
  al_get_num_display_modes: function(): Integer; cdecl;
  al_get_display_mode: function(index: Integer; mode: PALLEGRO_DISPLAY_MODE): PALLEGRO_DISPLAY_MODE; cdecl;
  al_install_joystick: function(): Boolean; cdecl;
  al_uninstall_joystick: procedure(); cdecl;
  al_is_joystick_installed: function(): Boolean; cdecl;
  al_reconfigure_joysticks: function(): Boolean; cdecl;
  al_get_num_joysticks: function(): Integer; cdecl;
  al_get_joystick: function(joyn: Integer): PALLEGRO_JOYSTICK; cdecl;
  al_release_joystick: procedure(p1: PALLEGRO_JOYSTICK); cdecl;
  al_get_joystick_active: function(p1: PALLEGRO_JOYSTICK): Boolean; cdecl;
  al_get_joystick_name: function(p1: PALLEGRO_JOYSTICK): PUTF8Char; cdecl;
  al_get_joystick_num_sticks: function(p1: PALLEGRO_JOYSTICK): Integer; cdecl;
  al_get_joystick_stick_flags: function(p1: PALLEGRO_JOYSTICK; stick: Integer): Integer; cdecl;
  al_get_joystick_stick_name: function(p1: PALLEGRO_JOYSTICK; stick: Integer): PUTF8Char; cdecl;
  al_get_joystick_num_axes: function(p1: PALLEGRO_JOYSTICK; stick: Integer): Integer; cdecl;
  al_get_joystick_axis_name: function(p1: PALLEGRO_JOYSTICK; stick: Integer; axis: Integer): PUTF8Char; cdecl;
  al_get_joystick_num_buttons: function(p1: PALLEGRO_JOYSTICK): Integer; cdecl;
  al_get_joystick_button_name: function(p1: PALLEGRO_JOYSTICK; buttonn: Integer): PUTF8Char; cdecl;
  al_get_joystick_state: procedure(p1: PALLEGRO_JOYSTICK; ret_state: PALLEGRO_JOYSTICK_STATE); cdecl;
  al_get_joystick_event_source: function(): PALLEGRO_EVENT_SOURCE; cdecl;
  al_is_keyboard_installed: function(): Boolean; cdecl;
  al_install_keyboard: function(): Boolean; cdecl;
  al_uninstall_keyboard: procedure(); cdecl;
  al_set_keyboard_leds: function(leds: Integer): Boolean; cdecl;
  al_keycode_to_name: function(keycode: Integer): PUTF8Char; cdecl;
  al_get_keyboard_state: procedure(ret_state: PALLEGRO_KEYBOARD_STATE); cdecl;
  al_clear_keyboard_state: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_key_down: function(const p1: PALLEGRO_KEYBOARD_STATE; keycode: Integer): Boolean; cdecl;
  al_get_keyboard_event_source: function(): PALLEGRO_EVENT_SOURCE; cdecl;
  al_is_mouse_installed: function(): Boolean; cdecl;
  al_install_mouse: function(): Boolean; cdecl;
  al_uninstall_mouse: procedure(); cdecl;
  al_get_mouse_num_buttons: function(): Cardinal; cdecl;
  al_get_mouse_num_axes: function(): Cardinal; cdecl;
  al_set_mouse_xy: function(display: PALLEGRO_DISPLAY; x: Integer; y: Integer): Boolean; cdecl;
  al_set_mouse_z: function(z: Integer): Boolean; cdecl;
  al_set_mouse_w: function(w: Integer): Boolean; cdecl;
  al_set_mouse_axis: function(axis: Integer; value: Integer): Boolean; cdecl;
  al_get_mouse_state: procedure(ret_state: PALLEGRO_MOUSE_STATE); cdecl;
  al_mouse_button_down: function(const state: PALLEGRO_MOUSE_STATE; button: Integer): Boolean; cdecl;
  al_get_mouse_state_axis: function(const state: PALLEGRO_MOUSE_STATE; axis: Integer): Integer; cdecl;
  al_get_mouse_cursor_position: function(ret_x: PInteger; ret_y: PInteger): Boolean; cdecl;
  al_grab_mouse: function(display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_ungrab_mouse: function(): Boolean; cdecl;
  al_set_mouse_wheel_precision: procedure(precision: Integer); cdecl;
  al_get_mouse_wheel_precision: function(): Integer; cdecl;
  al_get_mouse_event_source: function(): PALLEGRO_EVENT_SOURCE; cdecl;
  al_is_touch_input_installed: function(): Boolean; cdecl;
  al_install_touch_input: function(): Boolean; cdecl;
  al_uninstall_touch_input: procedure(); cdecl;
  al_get_touch_input_state: procedure(ret_state: PALLEGRO_TOUCH_INPUT_STATE); cdecl;
  al_get_touch_input_event_source: function(): PALLEGRO_EVENT_SOURCE; cdecl;
  al_set_mouse_emulation_mode: procedure(mode: Integer); cdecl;
  al_get_mouse_emulation_mode: function(): Integer; cdecl;
  al_get_touch_input_mouse_emulation_event_source: function(): PALLEGRO_EVENT_SOURCE; cdecl;
  al_install_haptic: function(): Boolean; cdecl;
  al_uninstall_haptic: procedure(); cdecl;
  al_is_haptic_installed: function(): Boolean; cdecl;
  al_is_mouse_haptic: function(p1: PALLEGRO_MOUSE): Boolean; cdecl;
  al_is_joystick_haptic: function(p1: PALLEGRO_JOYSTICK): Boolean; cdecl;
  al_is_keyboard_haptic: function(p1: PALLEGRO_KEYBOARD): Boolean; cdecl;
  al_is_display_haptic: function(p1: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_is_touch_input_haptic: function(p1: PALLEGRO_TOUCH_INPUT): Boolean; cdecl;
  al_get_haptic_from_mouse: function(p1: PALLEGRO_MOUSE): PALLEGRO_HAPTIC; cdecl;
  al_get_haptic_from_joystick: function(p1: PALLEGRO_JOYSTICK): PALLEGRO_HAPTIC; cdecl;
  al_get_haptic_from_keyboard: function(p1: PALLEGRO_KEYBOARD): PALLEGRO_HAPTIC; cdecl;
  al_get_haptic_from_display: function(p1: PALLEGRO_DISPLAY): PALLEGRO_HAPTIC; cdecl;
  al_get_haptic_from_touch_input: function(p1: PALLEGRO_TOUCH_INPUT): PALLEGRO_HAPTIC; cdecl;
  al_release_haptic: function(p1: PALLEGRO_HAPTIC): Boolean; cdecl;
  al_is_haptic_active: function(p1: PALLEGRO_HAPTIC): Boolean; cdecl;
  al_get_haptic_capabilities: function(p1: PALLEGRO_HAPTIC): Integer; cdecl;
  al_is_haptic_capable: function(p1: PALLEGRO_HAPTIC; p2: Integer): Boolean; cdecl;
  al_set_haptic_gain: function(p1: PALLEGRO_HAPTIC; p2: Double): Boolean; cdecl;
  al_get_haptic_gain: function(p1: PALLEGRO_HAPTIC): Double; cdecl;
  al_set_haptic_autocenter: function(p1: PALLEGRO_HAPTIC; p2: Double): Boolean; cdecl;
  al_get_haptic_autocenter: function(p1: PALLEGRO_HAPTIC): Double; cdecl;
  al_get_max_haptic_effects: function(p1: PALLEGRO_HAPTIC): Integer; cdecl;
  al_is_haptic_effect_ok: function(p1: PALLEGRO_HAPTIC; p2: PALLEGRO_HAPTIC_EFFECT): Boolean; cdecl;
  al_upload_haptic_effect: function(p1: PALLEGRO_HAPTIC; p2: PALLEGRO_HAPTIC_EFFECT; p3: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl;
  al_play_haptic_effect: function(p1: PALLEGRO_HAPTIC_EFFECT_ID; p2: Integer): Boolean; cdecl;
  al_upload_and_play_haptic_effect: function(p1: PALLEGRO_HAPTIC; p2: PALLEGRO_HAPTIC_EFFECT; p3: PALLEGRO_HAPTIC_EFFECT_ID; p4: Integer): Boolean; cdecl;
  al_stop_haptic_effect: function(p1: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl;
  al_is_haptic_effect_playing: function(p1: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl;
  al_release_haptic_effect: function(p1: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl;
  al_get_haptic_effect_duration: function(p1: PALLEGRO_HAPTIC_EFFECT): Double; cdecl;
  al_rumble_haptic: function(p1: PALLEGRO_HAPTIC; p2: Double; p3: Double; p4: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl;
  al_set_memory_interface: procedure(iface: PALLEGRO_MEMORY_INTERFACE); cdecl;
  al_malloc_with_context: function(n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
  al_free_with_context: procedure(ptr: Pointer; line: Integer; const file_: PUTF8Char; const func: PUTF8Char); cdecl;
  al_realloc_with_context: function(ptr: Pointer; n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
  al_calloc_with_context: function(count: NativeUInt; n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
  al_get_num_video_adapters: function(): Integer; cdecl;
  al_get_monitor_info: function(adapter: Integer; info: PALLEGRO_MONITOR_INFO): Boolean; cdecl;
  al_get_monitor_dpi: function(adapter: Integer): Integer; cdecl;
  al_get_monitor_refresh_rate: function(adapter: Integer): Integer; cdecl;
  al_create_mouse_cursor: function(sprite: PALLEGRO_BITMAP; xfocus: Integer; yfocus: Integer): PALLEGRO_MOUSE_CURSOR; cdecl;
  al_destroy_mouse_cursor: procedure(p1: PALLEGRO_MOUSE_CURSOR); cdecl;
  al_set_mouse_cursor: function(display: PALLEGRO_DISPLAY; cursor: PALLEGRO_MOUSE_CURSOR): Boolean; cdecl;
  al_set_system_mouse_cursor: function(display: PALLEGRO_DISPLAY; cursor_id: ALLEGRO_SYSTEM_MOUSE_CURSOR): Boolean; cdecl;
  al_show_mouse_cursor: function(display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_hide_mouse_cursor: function(display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_set_render_state: procedure(state: ALLEGRO_RENDER_STATE; value: Integer); cdecl;
  al_use_transform: procedure(const trans: PALLEGRO_TRANSFORM); cdecl;
  al_use_projection_transform: procedure(const trans: PALLEGRO_TRANSFORM); cdecl;
  al_copy_transform: procedure(dest: PALLEGRO_TRANSFORM; const src: PALLEGRO_TRANSFORM); cdecl;
  al_identity_transform: procedure(trans: PALLEGRO_TRANSFORM); cdecl;
  al_build_transform: procedure(trans: PALLEGRO_TRANSFORM; x: Single; y: Single; sx: Single; sy: Single; theta: Single); cdecl;
  al_build_camera_transform: procedure(trans: PALLEGRO_TRANSFORM; position_x: Single; position_y: Single; position_z: Single; look_x: Single; look_y: Single; look_z: Single; up_x: Single; up_y: Single; up_z: Single); cdecl;
  al_translate_transform: procedure(trans: PALLEGRO_TRANSFORM; x: Single; y: Single); cdecl;
  al_translate_transform_3d: procedure(trans: PALLEGRO_TRANSFORM; x: Single; y: Single; z: Single); cdecl;
  al_rotate_transform: procedure(trans: PALLEGRO_TRANSFORM; theta: Single); cdecl;
  al_rotate_transform_3d: procedure(trans: PALLEGRO_TRANSFORM; x: Single; y: Single; z: Single; angle: Single); cdecl;
  al_scale_transform: procedure(trans: PALLEGRO_TRANSFORM; sx: Single; sy: Single); cdecl;
  al_scale_transform_3d: procedure(trans: PALLEGRO_TRANSFORM; sx: Single; sy: Single; sz: Single); cdecl;
  al_transform_coordinates: procedure(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle); cdecl;
  al_transform_coordinates_3d: procedure(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle; z: PSingle); cdecl;
  al_transform_coordinates_4d: procedure(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle; z: PSingle; w: PSingle); cdecl;
  al_transform_coordinates_3d_projective: procedure(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle; z: PSingle); cdecl;
  al_compose_transform: procedure(trans: PALLEGRO_TRANSFORM; const other: PALLEGRO_TRANSFORM); cdecl;
  al_get_current_transform: function(): PALLEGRO_TRANSFORM; cdecl;
  al_get_current_inverse_transform: function(): PALLEGRO_TRANSFORM; cdecl;
  al_get_current_projection_transform: function(): PALLEGRO_TRANSFORM; cdecl;
  al_invert_transform: procedure(trans: PALLEGRO_TRANSFORM); cdecl;
  al_transpose_transform: procedure(trans: PALLEGRO_TRANSFORM); cdecl;
  al_check_inverse: function(const trans: PALLEGRO_TRANSFORM; tol: Single): Integer; cdecl;
  al_orthographic_transform: procedure(trans: PALLEGRO_TRANSFORM; left: Single; top: Single; n: Single; right: Single; bottom: Single; f: Single); cdecl;
  al_perspective_transform: procedure(trans: PALLEGRO_TRANSFORM; left: Single; top: Single; n: Single; right: Single; bottom: Single; f: Single); cdecl;
  al_horizontal_shear_transform: procedure(trans: PALLEGRO_TRANSFORM; theta: Single); cdecl;
  al_vertical_shear_transform: procedure(trans: PALLEGRO_TRANSFORM; theta: Single); cdecl;
  al_create_shader: function(platform_: ALLEGRO_SHADER_PLATFORM): PALLEGRO_SHADER; cdecl;
  al_attach_shader_source: function(shader: PALLEGRO_SHADER; type_: ALLEGRO_SHADER_TYPE; const source: PUTF8Char): Boolean; cdecl;
  al_attach_shader_source_file: function(shader: PALLEGRO_SHADER; type_: ALLEGRO_SHADER_TYPE; const filename: PUTF8Char): Boolean; cdecl;
  al_build_shader: function(shader: PALLEGRO_SHADER): Boolean; cdecl;
  al_get_shader_log: function(shader: PALLEGRO_SHADER): PUTF8Char; cdecl;
  al_get_shader_platform: function(shader: PALLEGRO_SHADER): ALLEGRO_SHADER_PLATFORM; cdecl;
  al_use_shader: function(shader: PALLEGRO_SHADER): Boolean; cdecl;
  al_destroy_shader: procedure(shader: PALLEGRO_SHADER); cdecl;
  al_set_shader_sampler: function(const name: PUTF8Char; bitmap: PALLEGRO_BITMAP; unit_: Integer): Boolean; cdecl;
  al_set_shader_matrix: function(const name: PUTF8Char; const matrix: PALLEGRO_TRANSFORM): Boolean; cdecl;
  al_set_shader_int: function(const name: PUTF8Char; i: Integer): Boolean; cdecl;
  al_set_shader_float: function(const name: PUTF8Char; f: Single): Boolean; cdecl;
  al_set_shader_int_vector: function(const name: PUTF8Char; num_components: Integer; const i: PInteger; num_elems: Integer): Boolean; cdecl;
  al_set_shader_float_vector: function(const name: PUTF8Char; num_components: Integer; const f: PSingle; num_elems: Integer): Boolean; cdecl;
  al_set_shader_bool: function(const name: PUTF8Char; b: Boolean): Boolean; cdecl;
  al_get_default_shader_source: function(platform_: ALLEGRO_SHADER_PLATFORM; type_: ALLEGRO_SHADER_TYPE): PUTF8Char; cdecl;
  al_install_system: function(version: Integer; atexit_ptr: al_install_system_atexit_ptr): Boolean; cdecl;
  al_uninstall_system: procedure(); cdecl;
  al_is_system_installed: function(): Boolean; cdecl;
  al_get_system_driver: function(): PALLEGRO_SYSTEM; cdecl;
  al_get_system_config: function(): PALLEGRO_CONFIG; cdecl;
  al_get_system_id: function(): ALLEGRO_SYSTEM_ID; cdecl;
  al_get_standard_path: function(id: Integer): PALLEGRO_PATH; cdecl;
  al_set_exe_name: procedure(const path: PUTF8Char); cdecl;
  al_set_org_name: procedure(const org_name: PUTF8Char); cdecl;
  al_set_app_name: procedure(const app_name: PUTF8Char); cdecl;
  al_get_org_name: function(): PUTF8Char; cdecl;
  al_get_app_name: function(): PUTF8Char; cdecl;
  al_inhibit_screensaver: function(inhibit: Boolean): Boolean; cdecl;
  al_create_thread: function(proc: al_create_thread_proc; arg: Pointer): PALLEGRO_THREAD; cdecl;
  al_create_thread_with_stacksize: function(proc: al_create_thread_with_stacksize_proc; arg: Pointer; stacksize: NativeUInt): PALLEGRO_THREAD; cdecl;
  al_start_thread: procedure(outer: PALLEGRO_THREAD); cdecl;
  al_join_thread: procedure(outer: PALLEGRO_THREAD; ret_value: PPointer); cdecl;
  al_set_thread_should_stop: procedure(outer: PALLEGRO_THREAD); cdecl;
  al_get_thread_should_stop: function(outer: PALLEGRO_THREAD): Boolean; cdecl;
  al_destroy_thread: procedure(thread: PALLEGRO_THREAD); cdecl;
  al_run_detached_thread: procedure(proc: al_run_detached_thread_proc; arg: Pointer); cdecl;
  al_create_mutex: function(): PALLEGRO_MUTEX; cdecl;
  al_create_mutex_recursive: function(): PALLEGRO_MUTEX; cdecl;
  al_lock_mutex: procedure(mutex: PALLEGRO_MUTEX); cdecl;
  al_unlock_mutex: procedure(mutex: PALLEGRO_MUTEX); cdecl;
  al_destroy_mutex: procedure(mutex: PALLEGRO_MUTEX); cdecl;
  al_create_cond: function(): PALLEGRO_COND; cdecl;
  al_destroy_cond: procedure(cond: PALLEGRO_COND); cdecl;
  al_wait_cond: procedure(cond: PALLEGRO_COND; mutex: PALLEGRO_MUTEX); cdecl;
  al_wait_cond_until: function(cond: PALLEGRO_COND; mutex: PALLEGRO_MUTEX; const timeout: PALLEGRO_TIMEOUT): Integer; cdecl;
  al_broadcast_cond: procedure(cond: PALLEGRO_COND); cdecl;
  al_signal_cond: procedure(cond: PALLEGRO_COND); cdecl;
  al_create_timer: function(speed_secs: Double): PALLEGRO_TIMER; cdecl;
  al_destroy_timer: procedure(timer: PALLEGRO_TIMER); cdecl;
  al_start_timer: procedure(timer: PALLEGRO_TIMER); cdecl;
  al_stop_timer: procedure(timer: PALLEGRO_TIMER); cdecl;
  al_resume_timer: procedure(timer: PALLEGRO_TIMER); cdecl;
  al_get_timer_started: function(const timer: PALLEGRO_TIMER): Boolean; cdecl;
  al_get_timer_speed: function(const timer: PALLEGRO_TIMER): Double; cdecl;
  al_set_timer_speed: procedure(timer: PALLEGRO_TIMER; speed_secs: Double); cdecl;
  al_get_timer_count: function(const timer: PALLEGRO_TIMER): Int64; cdecl;
  al_set_timer_count: procedure(timer: PALLEGRO_TIMER; count: Int64); cdecl;
  al_add_timer_count: procedure(timer: PALLEGRO_TIMER; diff: Int64); cdecl;
  al_get_timer_event_source: function(timer: PALLEGRO_TIMER): PALLEGRO_EVENT_SOURCE; cdecl;
  al_store_state: procedure(state: PALLEGRO_STATE; flags: Integer); cdecl;
  al_restore_state: procedure(const state: PALLEGRO_STATE); cdecl;
  _WinMain: function(_main: Pointer; hInst: Pointer; hPrev: Pointer; Cmd: PUTF8Char; nShow: Integer): Integer; cdecl;
  al_create_sample: function(buf: Pointer; samples: Cardinal; freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF; free_buf: Boolean): PALLEGRO_SAMPLE; cdecl;
  al_destroy_sample: procedure(spl: PALLEGRO_SAMPLE); cdecl;
  al_create_sample_instance: function(data: PALLEGRO_SAMPLE): PALLEGRO_SAMPLE_INSTANCE; cdecl;
  al_destroy_sample_instance: procedure(spl: PALLEGRO_SAMPLE_INSTANCE); cdecl;
  al_get_sample_frequency: function(const spl: PALLEGRO_SAMPLE): Cardinal; cdecl;
  al_get_sample_length: function(const spl: PALLEGRO_SAMPLE): Cardinal; cdecl;
  al_get_sample_depth: function(const spl: PALLEGRO_SAMPLE): ALLEGRO_AUDIO_DEPTH; cdecl;
  al_get_sample_channels: function(const spl: PALLEGRO_SAMPLE): ALLEGRO_CHANNEL_CONF; cdecl;
  al_get_sample_data: function(const spl: PALLEGRO_SAMPLE): Pointer; cdecl;
  al_get_sample_instance_frequency: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Cardinal; cdecl;
  al_get_sample_instance_length: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Cardinal; cdecl;
  al_get_sample_instance_position: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Cardinal; cdecl;
  al_get_sample_instance_speed: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl;
  al_get_sample_instance_gain: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl;
  al_get_sample_instance_pan: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl;
  al_get_sample_instance_time: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl;
  al_get_sample_instance_depth: function(const spl: PALLEGRO_SAMPLE_INSTANCE): ALLEGRO_AUDIO_DEPTH; cdecl;
  al_get_sample_instance_channels: function(const spl: PALLEGRO_SAMPLE_INSTANCE): ALLEGRO_CHANNEL_CONF; cdecl;
  al_get_sample_instance_playmode: function(const spl: PALLEGRO_SAMPLE_INSTANCE): ALLEGRO_PLAYMODE; cdecl;
  al_get_sample_instance_playing: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl;
  al_get_sample_instance_attached: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl;
  al_set_sample_instance_position: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Cardinal): Boolean; cdecl;
  al_set_sample_instance_length: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Cardinal): Boolean; cdecl;
  al_set_sample_instance_speed: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Single): Boolean; cdecl;
  al_set_sample_instance_gain: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Single): Boolean; cdecl;
  al_set_sample_instance_pan: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Single): Boolean; cdecl;
  al_set_sample_instance_playmode: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: ALLEGRO_PLAYMODE): Boolean; cdecl;
  al_set_sample_instance_playing: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Boolean): Boolean; cdecl;
  al_detach_sample_instance: function(spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl;
  al_set_sample: function(spl: PALLEGRO_SAMPLE_INSTANCE; data: PALLEGRO_SAMPLE): Boolean; cdecl;
  al_get_sample: function(spl: PALLEGRO_SAMPLE_INSTANCE): PALLEGRO_SAMPLE; cdecl;
  al_play_sample_instance: function(spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl;
  al_stop_sample_instance: function(spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl;
  al_set_sample_instance_channel_matrix: function(spl: PALLEGRO_SAMPLE_INSTANCE; const matrix: PSingle): Boolean; cdecl;
  al_create_audio_stream: function(buffer_count: NativeUInt; samples: Cardinal; freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_AUDIO_STREAM; cdecl;
  al_destroy_audio_stream: procedure(stream: PALLEGRO_AUDIO_STREAM); cdecl;
  al_drain_audio_stream: procedure(stream: PALLEGRO_AUDIO_STREAM); cdecl;
  al_get_audio_stream_frequency: function(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl;
  al_get_audio_stream_length: function(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl;
  al_get_audio_stream_fragments: function(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl;
  al_get_available_audio_stream_fragments: function(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl;
  al_get_audio_stream_speed: function(const stream: PALLEGRO_AUDIO_STREAM): Single; cdecl;
  al_get_audio_stream_gain: function(const stream: PALLEGRO_AUDIO_STREAM): Single; cdecl;
  al_get_audio_stream_pan: function(const stream: PALLEGRO_AUDIO_STREAM): Single; cdecl;
  al_get_audio_stream_channels: function(const stream: PALLEGRO_AUDIO_STREAM): ALLEGRO_CHANNEL_CONF; cdecl;
  al_get_audio_stream_depth: function(const stream: PALLEGRO_AUDIO_STREAM): ALLEGRO_AUDIO_DEPTH; cdecl;
  al_get_audio_stream_playmode: function(const stream: PALLEGRO_AUDIO_STREAM): ALLEGRO_PLAYMODE; cdecl;
  al_get_audio_stream_playing: function(const spl: PALLEGRO_AUDIO_STREAM): Boolean; cdecl;
  al_get_audio_stream_attached: function(const spl: PALLEGRO_AUDIO_STREAM): Boolean; cdecl;
  al_get_audio_stream_played_samples: function(const stream: PALLEGRO_AUDIO_STREAM): UInt64; cdecl;
  al_get_audio_stream_fragment: function(const stream: PALLEGRO_AUDIO_STREAM): Pointer; cdecl;
  al_set_audio_stream_speed: function(stream: PALLEGRO_AUDIO_STREAM; val: Single): Boolean; cdecl;
  al_set_audio_stream_gain: function(stream: PALLEGRO_AUDIO_STREAM; val: Single): Boolean; cdecl;
  al_set_audio_stream_pan: function(stream: PALLEGRO_AUDIO_STREAM; val: Single): Boolean; cdecl;
  al_set_audio_stream_playmode: function(stream: PALLEGRO_AUDIO_STREAM; val: ALLEGRO_PLAYMODE): Boolean; cdecl;
  al_set_audio_stream_playing: function(stream: PALLEGRO_AUDIO_STREAM; val: Boolean): Boolean; cdecl;
  al_detach_audio_stream: function(stream: PALLEGRO_AUDIO_STREAM): Boolean; cdecl;
  al_set_audio_stream_fragment: function(stream: PALLEGRO_AUDIO_STREAM; val: Pointer): Boolean; cdecl;
  al_rewind_audio_stream: function(stream: PALLEGRO_AUDIO_STREAM): Boolean; cdecl;
  al_seek_audio_stream_secs: function(stream: PALLEGRO_AUDIO_STREAM; time: Double): Boolean; cdecl;
  al_get_audio_stream_position_secs: function(stream: PALLEGRO_AUDIO_STREAM): Double; cdecl;
  al_get_audio_stream_length_secs: function(stream: PALLEGRO_AUDIO_STREAM): Double; cdecl;
  al_set_audio_stream_loop_secs: function(stream: PALLEGRO_AUDIO_STREAM; start: Double; end_: Double): Boolean; cdecl;
  al_get_audio_stream_event_source: function(stream: PALLEGRO_AUDIO_STREAM): PALLEGRO_EVENT_SOURCE; cdecl;
  al_set_audio_stream_channel_matrix: function(stream: PALLEGRO_AUDIO_STREAM; const matrix: PSingle): Boolean; cdecl;
  al_create_mixer: function(freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_MIXER; cdecl;
  al_destroy_mixer: procedure(mixer: PALLEGRO_MIXER); cdecl;
  al_attach_sample_instance_to_mixer: function(stream: PALLEGRO_SAMPLE_INSTANCE; mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_attach_audio_stream_to_mixer: function(stream: PALLEGRO_AUDIO_STREAM; mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_attach_mixer_to_mixer: function(stream: PALLEGRO_MIXER; mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_set_mixer_postprocess_callback: function(mixer: PALLEGRO_MIXER; cb: al_set_mixer_postprocess_callback_cb; data: Pointer): Boolean; cdecl;
  al_get_mixer_frequency: function(const mixer: PALLEGRO_MIXER): Cardinal; cdecl;
  al_get_mixer_channels: function(const mixer: PALLEGRO_MIXER): ALLEGRO_CHANNEL_CONF; cdecl;
  al_get_mixer_depth: function(const mixer: PALLEGRO_MIXER): ALLEGRO_AUDIO_DEPTH; cdecl;
  al_get_mixer_quality: function(const mixer: PALLEGRO_MIXER): ALLEGRO_MIXER_QUALITY; cdecl;
  al_get_mixer_gain: function(const mixer: PALLEGRO_MIXER): Single; cdecl;
  al_get_mixer_playing: function(const mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_get_mixer_attached: function(const mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_set_mixer_frequency: function(mixer: PALLEGRO_MIXER; val: Cardinal): Boolean; cdecl;
  al_set_mixer_quality: function(mixer: PALLEGRO_MIXER; val: ALLEGRO_MIXER_QUALITY): Boolean; cdecl;
  al_set_mixer_gain: function(mixer: PALLEGRO_MIXER; gain: Single): Boolean; cdecl;
  al_set_mixer_playing: function(mixer: PALLEGRO_MIXER; val: Boolean): Boolean; cdecl;
  al_detach_mixer: function(mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_create_voice: function(freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_VOICE; cdecl;
  al_destroy_voice: procedure(voice: PALLEGRO_VOICE); cdecl;
  al_attach_sample_instance_to_voice: function(stream: PALLEGRO_SAMPLE_INSTANCE; voice: PALLEGRO_VOICE): Boolean; cdecl;
  al_attach_audio_stream_to_voice: function(stream: PALLEGRO_AUDIO_STREAM; voice: PALLEGRO_VOICE): Boolean; cdecl;
  al_attach_mixer_to_voice: function(mixer: PALLEGRO_MIXER; voice: PALLEGRO_VOICE): Boolean; cdecl;
  al_detach_voice: procedure(voice: PALLEGRO_VOICE); cdecl;
  al_get_voice_frequency: function(const voice: PALLEGRO_VOICE): Cardinal; cdecl;
  al_get_voice_position: function(const voice: PALLEGRO_VOICE): Cardinal; cdecl;
  al_get_voice_channels: function(const voice: PALLEGRO_VOICE): ALLEGRO_CHANNEL_CONF; cdecl;
  al_get_voice_depth: function(const voice: PALLEGRO_VOICE): ALLEGRO_AUDIO_DEPTH; cdecl;
  al_get_voice_playing: function(const voice: PALLEGRO_VOICE): Boolean; cdecl;
  al_set_voice_position: function(voice: PALLEGRO_VOICE; val: Cardinal): Boolean; cdecl;
  al_set_voice_playing: function(voice: PALLEGRO_VOICE; val: Boolean): Boolean; cdecl;
  al_install_audio: function(): Boolean; cdecl;
  al_uninstall_audio: procedure(); cdecl;
  al_is_audio_installed: function(): Boolean; cdecl;
  al_get_allegro_audio_version: function(): UInt32; cdecl;
  al_get_channel_count: function(conf: ALLEGRO_CHANNEL_CONF): NativeUInt; cdecl;
  al_get_audio_depth_size: function(conf: ALLEGRO_AUDIO_DEPTH): NativeUInt; cdecl;
  al_fill_silence: procedure(buf: Pointer; samples: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF); cdecl;
  al_get_num_audio_output_devices: function(): Integer; cdecl;
  al_get_audio_output_device: function(index: Integer): PALLEGRO_AUDIO_DEVICE; cdecl;
  al_get_audio_device_name: function(const device: PALLEGRO_AUDIO_DEVICE): PUTF8Char; cdecl;
  al_reserve_samples: function(reserve_samples: Integer): Boolean; cdecl;
  al_get_default_mixer: function(): PALLEGRO_MIXER; cdecl;
  al_set_default_mixer: function(mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_restore_default_mixer: function(): Boolean; cdecl;
  al_play_sample: function(data: PALLEGRO_SAMPLE; gain: Single; pan: Single; speed: Single; loop: ALLEGRO_PLAYMODE; ret_id: PALLEGRO_SAMPLE_ID): Boolean; cdecl;
  al_stop_sample: procedure(spl_id: PALLEGRO_SAMPLE_ID); cdecl;
  al_stop_samples: procedure(); cdecl;
  al_get_default_voice: function(): PALLEGRO_VOICE; cdecl;
  al_set_default_voice: procedure(voice: PALLEGRO_VOICE); cdecl;
  al_lock_sample_id: function(spl_id: PALLEGRO_SAMPLE_ID): PALLEGRO_SAMPLE_INSTANCE; cdecl;
  al_unlock_sample_id: procedure(spl_id: PALLEGRO_SAMPLE_ID); cdecl;
  al_register_sample_loader: function(const ext: PUTF8Char; loader: al_register_sample_loader_loader): Boolean; cdecl;
  al_register_sample_saver: function(const ext: PUTF8Char; saver: al_register_sample_saver_saver): Boolean; cdecl;
  al_register_audio_stream_loader: function(const ext: PUTF8Char; stream_loader: al_register_audio_stream_loader_stream_loader): Boolean; cdecl;
  al_register_sample_loader_f: function(const ext: PUTF8Char; loader: al_register_sample_loader_f_loader): Boolean; cdecl;
  al_register_sample_saver_f: function(const ext: PUTF8Char; saver: al_register_sample_saver_f_saver): Boolean; cdecl;
  al_register_audio_stream_loader_f: function(const ext: PUTF8Char; stream_loader: al_register_audio_stream_loader_f_stream_loader): Boolean; cdecl;
  al_register_sample_identifier: function(const ext: PUTF8Char; identifier: al_register_sample_identifier_identifier): Boolean; cdecl;
  al_load_sample: function(const filename: PUTF8Char): PALLEGRO_SAMPLE; cdecl;
  al_save_sample: function(const filename: PUTF8Char; spl: PALLEGRO_SAMPLE): Boolean; cdecl;
  al_load_audio_stream: function(const filename: PUTF8Char; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl;
  al_load_sample_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char): PALLEGRO_SAMPLE; cdecl;
  al_save_sample_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char; spl: PALLEGRO_SAMPLE): Boolean; cdecl;
  al_load_audio_stream_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl;
  al_identify_sample_f: function(fp: PALLEGRO_FILE): PUTF8Char; cdecl;
  al_identify_sample: function(const filename: PUTF8Char): PUTF8Char; cdecl;
  al_create_audio_recorder: function(fragment_count: NativeUInt; samples: Cardinal; freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_AUDIO_RECORDER; cdecl;
  al_start_audio_recorder: function(r: PALLEGRO_AUDIO_RECORDER): Boolean; cdecl;
  al_stop_audio_recorder: procedure(r: PALLEGRO_AUDIO_RECORDER); cdecl;
  al_is_audio_recorder_recording: function(r: PALLEGRO_AUDIO_RECORDER): Boolean; cdecl;
  al_get_audio_recorder_event_source: function(r: PALLEGRO_AUDIO_RECORDER): PALLEGRO_EVENT_SOURCE; cdecl;
  al_get_audio_recorder_event: function(event: PALLEGRO_EVENT): PALLEGRO_AUDIO_RECORDER_EVENT; cdecl;
  al_destroy_audio_recorder: procedure(r: PALLEGRO_AUDIO_RECORDER); cdecl;
  al_init_acodec_addon: function(): Boolean; cdecl;
  al_is_acodec_addon_initialized: function(): Boolean; cdecl;
  al_get_allegro_acodec_version: function(): UInt32; cdecl;
  al_get_allegro_color_version: function(): UInt32; cdecl;
  al_color_hsv_to_rgb: procedure(hue: Single; saturation: Single; value: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_hsl: procedure(red: Single; green: Single; blue: Single; hue: PSingle; saturation: PSingle; lightness: PSingle); cdecl;
  al_color_rgb_to_hsv: procedure(red: Single; green: Single; blue: Single; hue: PSingle; saturation: PSingle; value: PSingle); cdecl;
  al_color_hsl_to_rgb: procedure(hue: Single; saturation: Single; lightness: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_name_to_rgb: function(const name: PUTF8Char; r: PSingle; g: PSingle; b: PSingle): Boolean; cdecl;
  al_color_rgb_to_name: function(r: Single; g: Single; b: Single): PUTF8Char; cdecl;
  al_color_cmyk_to_rgb: procedure(cyan: Single; magenta: Single; yellow: Single; key: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_cmyk: procedure(red: Single; green: Single; blue: Single; cyan: PSingle; magenta: PSingle; yellow: PSingle; key: PSingle); cdecl;
  al_color_yuv_to_rgb: procedure(y: Single; u: Single; v: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_yuv: procedure(red: Single; green: Single; blue: Single; y: PSingle; u: PSingle; v: PSingle); cdecl;
  al_color_rgb_to_html: procedure(red: Single; green: Single; blue: Single; string_: PUTF8Char); cdecl;
  al_color_html_to_rgb: function(const string_: PUTF8Char; red: PSingle; green: PSingle; blue: PSingle): Boolean; cdecl;
  al_color_yuv: function(y: Single; u: Single; v: Single): ALLEGRO_COLOR; cdecl;
  al_color_cmyk: function(c: Single; m: Single; y: Single; k: Single): ALLEGRO_COLOR; cdecl;
  al_color_hsl: function(h: Single; s: Single; l: Single): ALLEGRO_COLOR; cdecl;
  al_color_hsv: function(h: Single; s: Single; v: Single): ALLEGRO_COLOR; cdecl;
  al_color_name: function(const name: PUTF8Char): ALLEGRO_COLOR; cdecl;
  al_color_html: function(const string_: PUTF8Char): ALLEGRO_COLOR; cdecl;
  al_color_xyz_to_rgb: procedure(x: Single; y: Single; z: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_xyz: procedure(red: Single; green: Single; blue: Single; x: PSingle; y: PSingle; z: PSingle); cdecl;
  al_color_xyz: function(x: Single; y: Single; z: Single): ALLEGRO_COLOR; cdecl;
  al_color_lab_to_rgb: procedure(l: Single; a: Single; b: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_lab: procedure(red: Single; green: Single; blue: Single; l: PSingle; a: PSingle; b: PSingle); cdecl;
  al_color_lab: function(l: Single; a: Single; b: Single): ALLEGRO_COLOR; cdecl;
  al_color_xyy_to_rgb: procedure(x: Single; y: Single; y2: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_xyy: procedure(red: Single; green: Single; blue: Single; x: PSingle; y: PSingle; y2: PSingle); cdecl;
  al_color_xyy: function(x: Single; y: Single; y2: Single): ALLEGRO_COLOR; cdecl;
  al_color_distance_ciede2000: function(c1: ALLEGRO_COLOR; c2: ALLEGRO_COLOR): Double; cdecl;
  al_color_lch_to_rgb: procedure(l: Single; c: Single; h: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_lch: procedure(red: Single; green: Single; blue: Single; l: PSingle; c: PSingle; h: PSingle); cdecl;
  al_color_lch: function(l: Single; c: Single; h: Single): ALLEGRO_COLOR; cdecl;
  al_is_color_valid: function(color: ALLEGRO_COLOR): Boolean; cdecl;
  al_color_oklab_to_rgb: procedure(l: Single; a: Single; b: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_oklab: procedure(red: Single; green: Single; blue: Single; l: PSingle; a: PSingle; b: PSingle); cdecl;
  al_color_oklab: function(l: Single; a: Single; b: Single): ALLEGRO_COLOR; cdecl;
  al_color_linear_to_rgb: procedure(x: Single; y: Single; z: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_linear: procedure(red: Single; green: Single; blue: Single; x: PSingle; y: PSingle; z: PSingle); cdecl;
  al_color_linear: function(r: Single; g: Single; b: Single): ALLEGRO_COLOR; cdecl;
  al_register_font_loader: function(const ext: PUTF8Char; load: al_register_font_loader_load): Boolean; cdecl;
  al_load_bitmap_font: function(const filename: PUTF8Char): PALLEGRO_FONT; cdecl;
  al_load_bitmap_font_flags: function(const filename: PUTF8Char; flags: Integer): PALLEGRO_FONT; cdecl;
  al_load_font: function(const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl;
  al_grab_font_from_bitmap: function(bmp: PALLEGRO_BITMAP; n: Integer; ranges: PInteger): PALLEGRO_FONT; cdecl;
  al_create_builtin_font: function(): PALLEGRO_FONT; cdecl;
  al_draw_ustr: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; flags: Integer; const ustr: PALLEGRO_USTR); cdecl;
  al_draw_text: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; flags: Integer; const text: PUTF8Char); cdecl;
  al_draw_justified_text: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x1: Single; x2: Single; y: Single; diff: Single; flags: Integer; const text: PUTF8Char); cdecl;
  al_draw_justified_ustr: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x1: Single; x2: Single; y: Single; diff: Single; flags: Integer; const text: PALLEGRO_USTR); cdecl;
  al_draw_textf: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; flags: Integer; const format: PUTF8Char) varargs; cdecl;
  al_draw_justified_textf: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x1: Single; x2: Single; y: Single; diff: Single; flags: Integer; const format: PUTF8Char) varargs; cdecl;
  al_get_text_width: function(const f: PALLEGRO_FONT; const str: PUTF8Char): Integer; cdecl;
  al_get_ustr_width: function(const f: PALLEGRO_FONT; const ustr: PALLEGRO_USTR): Integer; cdecl;
  al_get_font_line_height: function(const f: PALLEGRO_FONT): Integer; cdecl;
  al_get_font_ascent: function(const f: PALLEGRO_FONT): Integer; cdecl;
  al_get_font_descent: function(const f: PALLEGRO_FONT): Integer; cdecl;
  al_destroy_font: procedure(f: PALLEGRO_FONT); cdecl;
  al_get_ustr_dimensions: procedure(const f: PALLEGRO_FONT; const text: PALLEGRO_USTR; bbx: PInteger; bby: PInteger; bbw: PInteger; bbh: PInteger); cdecl;
  al_get_text_dimensions: procedure(const f: PALLEGRO_FONT; const text: PUTF8Char; bbx: PInteger; bby: PInteger; bbw: PInteger; bbh: PInteger); cdecl;
  al_init_font_addon: function(): Boolean; cdecl;
  al_is_font_addon_initialized: function(): Boolean; cdecl;
  al_shutdown_font_addon: procedure(); cdecl;
  al_get_allegro_font_version: function(): UInt32; cdecl;
  al_get_font_ranges: function(font: PALLEGRO_FONT; ranges_count: Integer; ranges: PInteger): Integer; cdecl;
  al_draw_glyph: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; codepoint: Integer); cdecl;
  al_get_glyph_width: function(const f: PALLEGRO_FONT; codepoint: Integer): Integer; cdecl;
  al_get_glyph_dimensions: function(const f: PALLEGRO_FONT; codepoint: Integer; bbx: PInteger; bby: PInteger; bbw: PInteger; bbh: PInteger): Boolean; cdecl;
  al_get_glyph_advance: function(const f: PALLEGRO_FONT; codepoint1: Integer; codepoint2: Integer): Integer; cdecl;
  al_get_glyph: function(const f: PALLEGRO_FONT; prev_codepoint: Integer; codepoint: Integer; glyph: PALLEGRO_GLYPH): Boolean; cdecl;
  al_draw_multiline_text: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; max_width: Single; line_height: Single; flags: Integer; const text: PUTF8Char); cdecl;
  al_draw_multiline_textf: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; max_width: Single; line_height: Single; flags: Integer; const format: PUTF8Char) varargs; cdecl;
  al_draw_multiline_ustr: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; max_width: Single; line_height: Single; flags: Integer; const text: PALLEGRO_USTR); cdecl;
  al_do_multiline_text: procedure(const font: PALLEGRO_FONT; max_width: Single; const text: PUTF8Char; cb: al_do_multiline_text_cb; extra: Pointer); cdecl;
  al_do_multiline_ustr: procedure(const font: PALLEGRO_FONT; max_width: Single; const ustr: PALLEGRO_USTR; cb: al_do_multiline_ustr_cb; extra: Pointer); cdecl;
  al_set_fallback_font: procedure(font: PALLEGRO_FONT; fallback: PALLEGRO_FONT); cdecl;
  al_get_fallback_font: function(font: PALLEGRO_FONT): PALLEGRO_FONT; cdecl;
  al_init_image_addon: function(): Boolean; cdecl;
  al_is_image_addon_initialized: function(): Boolean; cdecl;
  al_shutdown_image_addon: procedure(); cdecl;
  al_get_allegro_image_version: function(): UInt32; cdecl;
  al_open_memfile: function(mem: Pointer; size: Int64; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_get_allegro_memfile_version: function(): UInt32; cdecl;
  al_init_native_dialog_addon: function(): Boolean; cdecl;
  al_is_native_dialog_addon_initialized: function(): Boolean; cdecl;
  al_shutdown_native_dialog_addon: procedure(); cdecl;
  al_create_native_file_dialog: function(const initial_path: PUTF8Char; const title: PUTF8Char; const patterns: PUTF8Char; mode: Integer): PALLEGRO_FILECHOOSER; cdecl;
  al_show_native_file_dialog: function(display: PALLEGRO_DISPLAY; dialog: PALLEGRO_FILECHOOSER): Boolean; cdecl;
  al_get_native_file_dialog_count: function(const dialog: PALLEGRO_FILECHOOSER): Integer; cdecl;
  al_get_native_file_dialog_path: function(const dialog: PALLEGRO_FILECHOOSER; index: NativeUInt): PUTF8Char; cdecl;
  al_destroy_native_file_dialog: procedure(dialog: PALLEGRO_FILECHOOSER); cdecl;
  al_show_native_message_box: function(display: PALLEGRO_DISPLAY; const title: PUTF8Char; const heading: PUTF8Char; const text: PUTF8Char; const buttons: PUTF8Char; flags: Integer): Integer; cdecl;
  al_open_native_text_log: function(const title: PUTF8Char; flags: Integer): PALLEGRO_TEXTLOG; cdecl;
  al_close_native_text_log: procedure(textlog: PALLEGRO_TEXTLOG); cdecl;
  al_append_native_text_log: procedure(textlog: PALLEGRO_TEXTLOG; const format: PUTF8Char) varargs; cdecl;
  al_get_native_text_log_event_source: function(textlog: PALLEGRO_TEXTLOG): PALLEGRO_EVENT_SOURCE; cdecl;
  al_create_menu: function(): PALLEGRO_MENU; cdecl;
  al_create_popup_menu: function(): PALLEGRO_MENU; cdecl;
  al_build_menu: function(info: PALLEGRO_MENU_INFO): PALLEGRO_MENU; cdecl;
  al_append_menu_item: function(parent: PALLEGRO_MENU; const title: PUTF8Char; id: UInt16; flags: Integer; icon: PALLEGRO_BITMAP; submenu: PALLEGRO_MENU): Integer; cdecl;
  al_insert_menu_item: function(parent: PALLEGRO_MENU; pos: Integer; const title: PUTF8Char; id: UInt16; flags: Integer; icon: PALLEGRO_BITMAP; submenu: PALLEGRO_MENU): Integer; cdecl;
  al_remove_menu_item: function(menu: PALLEGRO_MENU; pos: Integer): Boolean; cdecl;
  al_clone_menu: function(menu: PALLEGRO_MENU): PALLEGRO_MENU; cdecl;
  al_clone_menu_for_popup: function(menu: PALLEGRO_MENU): PALLEGRO_MENU; cdecl;
  al_destroy_menu: procedure(menu: PALLEGRO_MENU); cdecl;
  al_get_menu_item_caption: function(menu: PALLEGRO_MENU; pos: Integer): PUTF8Char; cdecl;
  al_set_menu_item_caption: procedure(menu: PALLEGRO_MENU; pos: Integer; const caption: PUTF8Char); cdecl;
  al_get_menu_item_flags: function(menu: PALLEGRO_MENU; pos: Integer): Integer; cdecl;
  al_set_menu_item_flags: procedure(menu: PALLEGRO_MENU; pos: Integer; flags: Integer); cdecl;
  al_get_menu_item_icon: function(menu: PALLEGRO_MENU; pos: Integer): PALLEGRO_BITMAP; cdecl;
  al_set_menu_item_icon: procedure(menu: PALLEGRO_MENU; pos: Integer; icon: PALLEGRO_BITMAP); cdecl;
  al_toggle_menu_item_flags: function(menu: PALLEGRO_MENU; pos: Integer; flags: Integer): Integer; cdecl;
  al_find_menu: function(haystack: PALLEGRO_MENU; id: UInt16): PALLEGRO_MENU; cdecl;
  al_find_menu_item: function(haystack: PALLEGRO_MENU; id: UInt16; menu: PPALLEGRO_MENU; index: PInteger): Boolean; cdecl;
  al_get_default_menu_event_source: function(): PALLEGRO_EVENT_SOURCE; cdecl;
  al_enable_menu_event_source: function(menu: PALLEGRO_MENU): PALLEGRO_EVENT_SOURCE; cdecl;
  al_disable_menu_event_source: procedure(menu: PALLEGRO_MENU); cdecl;
  al_get_display_menu: function(display: PALLEGRO_DISPLAY): PALLEGRO_MENU; cdecl;
  al_set_display_menu: function(display: PALLEGRO_DISPLAY; menu: PALLEGRO_MENU): Boolean; cdecl;
  al_popup_menu: function(popup: PALLEGRO_MENU; display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_remove_display_menu: function(display: PALLEGRO_DISPLAY): PALLEGRO_MENU; cdecl;
  al_get_allegro_native_dialog_version: function(): UInt32; cdecl;
  al_set_physfs_file_interface: procedure(); cdecl;
  al_get_allegro_physfs_version: function(): UInt32; cdecl;
  al_get_allegro_primitives_version: function(): UInt32; cdecl;
  al_init_primitives_addon: function(): Boolean; cdecl;
  al_is_primitives_addon_initialized: function(): Boolean; cdecl;
  al_shutdown_primitives_addon: procedure(); cdecl;
  al_draw_prim: function(const vtxs: Pointer; const decl: PALLEGRO_VERTEX_DECL; texture: PALLEGRO_BITMAP; start: Integer; end_: Integer; type_: Integer): Integer; cdecl;
  al_draw_indexed_prim: function(const vtxs: Pointer; const decl: PALLEGRO_VERTEX_DECL; texture: PALLEGRO_BITMAP; const indices: PInteger; num_vtx: Integer; type_: Integer): Integer; cdecl;
  al_draw_vertex_buffer: function(vertex_buffer: PALLEGRO_VERTEX_BUFFER; texture: PALLEGRO_BITMAP; start: Integer; end_: Integer; type_: Integer): Integer; cdecl;
  al_draw_indexed_buffer: function(vertex_buffer: PALLEGRO_VERTEX_BUFFER; texture: PALLEGRO_BITMAP; index_buffer: PALLEGRO_INDEX_BUFFER; start: Integer; end_: Integer; type_: Integer): Integer; cdecl;
  al_create_vertex_decl: function(const elements: PALLEGRO_VERTEX_ELEMENT; stride: Integer): PALLEGRO_VERTEX_DECL; cdecl;
  al_destroy_vertex_decl: procedure(decl: PALLEGRO_VERTEX_DECL); cdecl;
  al_create_vertex_buffer: function(decl: PALLEGRO_VERTEX_DECL; const initial_data: Pointer; num_vertices: Integer; flags: Integer): PALLEGRO_VERTEX_BUFFER; cdecl;
  al_destroy_vertex_buffer: procedure(buffer: PALLEGRO_VERTEX_BUFFER); cdecl;
  al_lock_vertex_buffer: function(buffer: PALLEGRO_VERTEX_BUFFER; offset: Integer; length: Integer; flags: Integer): Pointer; cdecl;
  al_unlock_vertex_buffer: procedure(buffer: PALLEGRO_VERTEX_BUFFER); cdecl;
  al_get_vertex_buffer_size: function(buffer: PALLEGRO_VERTEX_BUFFER): Integer; cdecl;
  al_create_index_buffer: function(index_size: Integer; const initial_data: Pointer; num_indices: Integer; flags: Integer): PALLEGRO_INDEX_BUFFER; cdecl;
  al_destroy_index_buffer: procedure(buffer: PALLEGRO_INDEX_BUFFER); cdecl;
  al_lock_index_buffer: function(buffer: PALLEGRO_INDEX_BUFFER; offset: Integer; length: Integer; flags: Integer): Pointer; cdecl;
  al_unlock_index_buffer: procedure(buffer: PALLEGRO_INDEX_BUFFER); cdecl;
  al_get_index_buffer_size: function(buffer: PALLEGRO_INDEX_BUFFER): Integer; cdecl;
  al_triangulate_polygon: function(const vertices: PSingle; vertex_stride: NativeUInt; const vertex_counts: PInteger; emit_triangle: al_triangulate_polygon_emit_triangle; userdata: Pointer): Boolean; cdecl;
  al_draw_soft_triangle: procedure(v1: PALLEGRO_VERTEX; v2: PALLEGRO_VERTEX; v3: PALLEGRO_VERTEX; state: UIntPtr; init: al_draw_soft_triangle_init; first: al_draw_soft_triangle_first; step: al_draw_soft_triangle_step; draw: al_draw_soft_triangle_draw); cdecl;
  al_draw_soft_line: procedure(v1: PALLEGRO_VERTEX; v2: PALLEGRO_VERTEX; state: UIntPtr; first: al_draw_soft_line_first; step: al_draw_soft_line_step; draw: al_draw_soft_line_draw); cdecl;
  al_draw_line: procedure(x1: Single; y1: Single; x2: Single; y2: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_triangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; x3: Single; y3: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_rectangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_rounded_rectangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_calculate_arc: procedure(dest: PSingle; stride: Integer; cx: Single; cy: Single; rx: Single; ry: Single; start_theta: Single; delta_theta: Single; thickness: Single; num_points: Integer); cdecl;
  al_draw_circle: procedure(cx: Single; cy: Single; r: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_ellipse: procedure(cx: Single; cy: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_arc: procedure(cx: Single; cy: Single; r: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_elliptical_arc: procedure(cx: Single; cy: Single; rx: Single; ry: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_pieslice: procedure(cx: Single; cy: Single; r: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_calculate_spline: procedure(dest: PSingle; stride: Integer; points: PSingle; thickness: Single; num_segments: Integer); cdecl;
  al_draw_spline: procedure(points: PSingle; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_calculate_ribbon: procedure(dest: PSingle; dest_stride: Integer; const points: PSingle; points_stride: Integer; thickness: Single; num_segments: Integer); cdecl;
  al_draw_ribbon: procedure(const points: PSingle; points_stride: Integer; color: ALLEGRO_COLOR; thickness: Single; num_segments: Integer); cdecl;
  al_draw_filled_triangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; x3: Single; y3: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_rectangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_ellipse: procedure(cx: Single; cy: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_circle: procedure(cx: Single; cy: Single; r: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_pieslice: procedure(cx: Single; cy: Single; r: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_rounded_rectangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_polyline: procedure(const vertices: PSingle; vertex_stride: Integer; vertex_count: Integer; join_style: Integer; cap_style: Integer; color: ALLEGRO_COLOR; thickness: Single; miter_limit: Single); cdecl;
  al_draw_polygon: procedure(const vertices: PSingle; vertex_count: Integer; join_style: Integer; color: ALLEGRO_COLOR; thickness: Single; miter_limit: Single); cdecl;
  al_draw_filled_polygon: procedure(const vertices: PSingle; vertex_count: Integer; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_polygon_with_holes: procedure(const vertices: PSingle; const vertex_counts: PInteger; color: ALLEGRO_COLOR); cdecl;
  al_load_ttf_font: function(const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl;
  al_load_ttf_font_f: function(file_: PALLEGRO_FILE; const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl;
  al_load_ttf_font_stretch: function(const filename: PUTF8Char; w: Integer; h: Integer; flags: Integer): PALLEGRO_FONT; cdecl;
  al_load_ttf_font_stretch_f: function(file_: PALLEGRO_FILE; const filename: PUTF8Char; w: Integer; h: Integer; flags: Integer): PALLEGRO_FONT; cdecl;
  al_init_ttf_addon: function(): Boolean; cdecl;
  al_is_ttf_addon_initialized: function(): Boolean; cdecl;
  al_shutdown_ttf_addon: procedure(); cdecl;
  al_get_allegro_ttf_version: function(): UInt32; cdecl;
  al_open_video: function(const filename: PUTF8Char): PALLEGRO_VIDEO; cdecl;
  al_close_video: procedure(video: PALLEGRO_VIDEO); cdecl;
  al_start_video: procedure(video: PALLEGRO_VIDEO; mixer: PALLEGRO_MIXER); cdecl;
  al_start_video_with_voice: procedure(video: PALLEGRO_VIDEO; voice: PALLEGRO_VOICE); cdecl;
  al_get_video_event_source: function(video: PALLEGRO_VIDEO): PALLEGRO_EVENT_SOURCE; cdecl;
  al_set_video_playing: procedure(video: PALLEGRO_VIDEO; playing: Boolean); cdecl;
  al_is_video_playing: function(video: PALLEGRO_VIDEO): Boolean; cdecl;
  al_get_video_audio_rate: function(video: PALLEGRO_VIDEO): Double; cdecl;
  al_get_video_fps: function(video: PALLEGRO_VIDEO): Double; cdecl;
  al_get_video_scaled_width: function(video: PALLEGRO_VIDEO): Single; cdecl;
  al_get_video_scaled_height: function(video: PALLEGRO_VIDEO): Single; cdecl;
  al_get_video_frame: function(video: PALLEGRO_VIDEO): PALLEGRO_BITMAP; cdecl;
  al_get_video_position: function(video: PALLEGRO_VIDEO; which: ALLEGRO_VIDEO_POSITION_TYPE): Double; cdecl;
  al_seek_video: function(video: PALLEGRO_VIDEO; pos_in_seconds: Double): Boolean; cdecl;
  al_init_video_addon: function(): Boolean; cdecl;
  al_is_video_addon_initialized: function(): Boolean; cdecl;
  al_shutdown_video_addon: procedure(); cdecl;
  al_get_allegro_video_version: function(): UInt32; cdecl;
  al_identify_video_f: function(fp: PALLEGRO_FILE): PUTF8Char; cdecl;
  al_identify_video: function(const filename: PUTF8Char): PUTF8Char; cdecl;
  crc32: function(crc: Cardinal; const buf: PByte; len: Cardinal): Cardinal; cdecl;
  zipOpen: function(const pathname: PUTF8Char; append: Integer): zipFile; cdecl;
  zipOpenNewFileInZip3: function(file_: zipFile; const filename: PUTF8Char; const zipfi: Pzip_fileinfo; const extrafield_local: Pointer; intsize_extrafield_local: Cardinal; const extrafield_global: Pointer; intsize_extrafield_global: Cardinal; const comment: PUTF8Char; method: Integer; level: Integer; raw: Integer; windowBits: Integer; memLevel: Integer; strategy: Integer; const password: PUTF8Char; crcForCrypting: Cardinal): Integer; cdecl;
  zipWriteInFileInZip: function(file_: zipFile; const buf: Pointer; len: Cardinal): Integer; cdecl;
  zipCloseFileInZip: function(file_: zipFile): Integer; cdecl;
  zipClose: function(file_: zipFile; const global_comment: PUTF8Char): Integer; cdecl;
  PHYSFS_init: function(const argv0: PUTF8Char): Integer; cdecl;
  PHYSFS_deinit: function(): Integer; cdecl;
  PHYSFS_getWriteDir: function(): PUTF8Char; cdecl;
  PHYSFS_setWriteDir: function(const newDir: PUTF8Char): Integer; cdecl;
  PHYSFS_mount: function(const newDir: PUTF8Char; const mountPoint: PUTF8Char; appendToPath: Integer): Integer; cdecl;
  PHYSFS_unmount: function(const oldDir: PUTF8Char): Integer; cdecl;
  nk_init_fixed: function(p1: Pnk_context; memory: Pointer; size: nk_size; const p4: Pnk_user_font): nk_bool; cdecl;
  nk_init: function(p1: Pnk_context; p2: Pnk_allocator; const p3: Pnk_user_font): nk_bool; cdecl;
  nk_init_custom: function(p1: Pnk_context; cmds: Pnk_buffer; pool: Pnk_buffer; const p4: Pnk_user_font): nk_bool; cdecl;
  nk_clear: procedure(p1: Pnk_context); cdecl;
  nk_free: procedure(p1: Pnk_context); cdecl;
  nk_input_begin: procedure(p1: Pnk_context); cdecl;
  nk_input_motion: procedure(p1: Pnk_context; x: Integer; y: Integer); cdecl;
  nk_input_key: procedure(p1: Pnk_context; p2: nk_keys; down: nk_bool); cdecl;
  nk_input_button: procedure(p1: Pnk_context; p2: nk_buttons; x: Integer; y: Integer; down: nk_bool); cdecl;
  nk_input_scroll: procedure(p1: Pnk_context; val: nk_vec2); cdecl;
  nk_input_char: procedure(p1: Pnk_context; p2: UTF8Char); cdecl;
  nk_input_glyph: procedure(p1: Pnk_context; const p2: nk_glyph); cdecl;
  nk_input_unicode: procedure(p1: Pnk_context; p2: nk_rune); cdecl;
  nk_input_end: procedure(p1: Pnk_context); cdecl;
  nk__begin: function(p1: Pnk_context): Pnk_command; cdecl;
  nk__next: function(p1: Pnk_context; const p2: Pnk_command): Pnk_command; cdecl;
  nk_begin: function(ctx: Pnk_context; const title: PUTF8Char; bounds: nk_rect; flags: nk_flags): nk_bool; cdecl;
  nk_begin_titled: function(ctx: Pnk_context; const name: PUTF8Char; const title: PUTF8Char; bounds: nk_rect; flags: nk_flags): nk_bool; cdecl;
  nk_end: procedure(ctx: Pnk_context); cdecl;
  nk_window_find: function(ctx: Pnk_context; const name: PUTF8Char): Pnk_window; cdecl;
  nk_window_get_bounds: function(const ctx: Pnk_context): nk_rect; cdecl;
  nk_window_get_position: function(const ctx: Pnk_context): nk_vec2; cdecl;
  nk_window_get_size: function(const p1: Pnk_context): nk_vec2; cdecl;
  nk_window_get_width: function(const p1: Pnk_context): Single; cdecl;
  nk_window_get_height: function(const p1: Pnk_context): Single; cdecl;
  nk_window_get_panel: function(p1: Pnk_context): Pnk_panel; cdecl;
  nk_window_get_content_region: function(p1: Pnk_context): nk_rect; cdecl;
  nk_window_get_content_region_min: function(p1: Pnk_context): nk_vec2; cdecl;
  nk_window_get_content_region_max: function(p1: Pnk_context): nk_vec2; cdecl;
  nk_window_get_content_region_size: function(p1: Pnk_context): nk_vec2; cdecl;
  nk_window_get_canvas: function(p1: Pnk_context): Pnk_command_buffer; cdecl;
  nk_window_get_scroll: procedure(p1: Pnk_context; offset_x: Pnk_uint; offset_y: Pnk_uint); cdecl;
  nk_window_has_focus: function(const p1: Pnk_context): nk_bool; cdecl;
  nk_window_is_hovered: function(p1: Pnk_context): nk_bool; cdecl;
  nk_window_is_collapsed: function(ctx: Pnk_context; const name: PUTF8Char): nk_bool; cdecl;
  nk_window_is_closed: function(p1: Pnk_context; const p2: PUTF8Char): nk_bool; cdecl;
  nk_window_is_hidden: function(p1: Pnk_context; const p2: PUTF8Char): nk_bool; cdecl;
  nk_window_is_active: function(p1: Pnk_context; const p2: PUTF8Char): nk_bool; cdecl;
  nk_window_is_any_hovered: function(p1: Pnk_context): nk_bool; cdecl;
  nk_item_is_any_active: function(p1: Pnk_context): nk_bool; cdecl;
  nk_window_set_bounds: procedure(p1: Pnk_context; const name: PUTF8Char; bounds: nk_rect); cdecl;
  nk_window_set_position: procedure(p1: Pnk_context; const name: PUTF8Char; pos: nk_vec2); cdecl;
  nk_window_set_size: procedure(p1: Pnk_context; const name: PUTF8Char; p3: nk_vec2); cdecl;
  nk_window_set_focus: procedure(p1: Pnk_context; const name: PUTF8Char); cdecl;
  nk_window_set_scroll: procedure(p1: Pnk_context; offset_x: nk_uint; offset_y: nk_uint); cdecl;
  nk_window_close: procedure(ctx: Pnk_context; const name: PUTF8Char); cdecl;
  nk_window_collapse: procedure(p1: Pnk_context; const name: PUTF8Char; state: nk_collapse_states); cdecl;
  nk_window_collapse_if: procedure(p1: Pnk_context; const name: PUTF8Char; p3: nk_collapse_states; cond: Integer); cdecl;
  nk_window_show: procedure(p1: Pnk_context; const name: PUTF8Char; p3: nk_show_states); cdecl;
  nk_window_show_if: procedure(p1: Pnk_context; const name: PUTF8Char; p3: nk_show_states; cond: Integer); cdecl;
  nk_layout_set_min_row_height: procedure(p1: Pnk_context; height: Single); cdecl;
  nk_layout_reset_min_row_height: procedure(p1: Pnk_context); cdecl;
  nk_layout_widget_bounds: function(p1: Pnk_context): nk_rect; cdecl;
  nk_layout_ratio_from_pixel: function(p1: Pnk_context; pixel_width: Single): Single; cdecl;
  nk_layout_row_dynamic: procedure(ctx: Pnk_context; height: Single; cols: Integer); cdecl;
  nk_layout_row_static: procedure(ctx: Pnk_context; height: Single; item_width: Integer; cols: Integer); cdecl;
  nk_layout_row_begin: procedure(ctx: Pnk_context; fmt: nk_layout_format; row_height: Single; cols: Integer); cdecl;
  nk_layout_row_push: procedure(p1: Pnk_context; value: Single); cdecl;
  nk_layout_row_end: procedure(p1: Pnk_context); cdecl;
  nk_layout_row: procedure(p1: Pnk_context; p2: nk_layout_format; height: Single; cols: Integer; const ratio: PSingle); cdecl;
  nk_layout_row_template_begin: procedure(p1: Pnk_context; row_height: Single); cdecl;
  nk_layout_row_template_push_dynamic: procedure(p1: Pnk_context); cdecl;
  nk_layout_row_template_push_variable: procedure(p1: Pnk_context; min_width: Single); cdecl;
  nk_layout_row_template_push_static: procedure(p1: Pnk_context; width: Single); cdecl;
  nk_layout_row_template_end: procedure(p1: Pnk_context); cdecl;
  nk_layout_space_begin: procedure(p1: Pnk_context; p2: nk_layout_format; height: Single; widget_count: Integer); cdecl;
  nk_layout_space_push: procedure(p1: Pnk_context; bounds: nk_rect); cdecl;
  nk_layout_space_end: procedure(p1: Pnk_context); cdecl;
  nk_layout_space_bounds: function(p1: Pnk_context): nk_rect; cdecl;
  nk_layout_space_to_screen: function(p1: Pnk_context; p2: nk_vec2): nk_vec2; cdecl;
  nk_layout_space_to_local: function(p1: Pnk_context; p2: nk_vec2): nk_vec2; cdecl;
  nk_layout_space_rect_to_screen: function(p1: Pnk_context; p2: nk_rect): nk_rect; cdecl;
  nk_layout_space_rect_to_local: function(p1: Pnk_context; p2: nk_rect): nk_rect; cdecl;
  nk_spacer: procedure(p1: Pnk_context); cdecl;
  nk_group_begin: function(p1: Pnk_context; const title: PUTF8Char; p3: nk_flags): nk_bool; cdecl;
  nk_group_begin_titled: function(p1: Pnk_context; const name: PUTF8Char; const title: PUTF8Char; p4: nk_flags): nk_bool; cdecl;
  nk_group_end: procedure(p1: Pnk_context); cdecl;
  nk_group_scrolled_offset_begin: function(p1: Pnk_context; x_offset: Pnk_uint; y_offset: Pnk_uint; const title: PUTF8Char; flags: nk_flags): nk_bool; cdecl;
  nk_group_scrolled_begin: function(p1: Pnk_context; off: Pnk_scroll; const title: PUTF8Char; p4: nk_flags): nk_bool; cdecl;
  nk_group_scrolled_end: procedure(p1: Pnk_context); cdecl;
  nk_group_get_scroll: procedure(p1: Pnk_context; const id: PUTF8Char; x_offset: Pnk_uint; y_offset: Pnk_uint); cdecl;
  nk_group_set_scroll: procedure(p1: Pnk_context; const id: PUTF8Char; x_offset: nk_uint; y_offset: nk_uint); cdecl;
  nk_tree_push_hashed: function(p1: Pnk_context; p2: nk_tree_type; const title: PUTF8Char; initial_state: nk_collapse_states; const hash: PUTF8Char; len: Integer; seed: Integer): nk_bool; cdecl;
  nk_tree_image_push_hashed: function(p1: Pnk_context; p2: nk_tree_type; p3: nk_image; const title: PUTF8Char; initial_state: nk_collapse_states; const hash: PUTF8Char; len: Integer; seed: Integer): nk_bool; cdecl;
  nk_tree_pop: procedure(p1: Pnk_context); cdecl;
  nk_tree_state_push: function(p1: Pnk_context; p2: nk_tree_type; const title: PUTF8Char; state: Pnk_collapse_states): nk_bool; cdecl;
  nk_tree_state_image_push: function(p1: Pnk_context; p2: nk_tree_type; p3: nk_image; const title: PUTF8Char; state: Pnk_collapse_states): nk_bool; cdecl;
  nk_tree_state_pop: procedure(p1: Pnk_context); cdecl;
  nk_tree_element_push_hashed: function(p1: Pnk_context; p2: nk_tree_type; const title: PUTF8Char; initial_state: nk_collapse_states; selected: Pnk_bool; const hash: PUTF8Char; len: Integer; seed: Integer): nk_bool; cdecl;
  nk_tree_element_image_push_hashed: function(p1: Pnk_context; p2: nk_tree_type; p3: nk_image; const title: PUTF8Char; initial_state: nk_collapse_states; selected: Pnk_bool; const hash: PUTF8Char; len: Integer; seed: Integer): nk_bool; cdecl;
  nk_tree_element_pop: procedure(p1: Pnk_context); cdecl;
  nk_list_view_begin: function(p1: Pnk_context; out_: Pnk_list_view; const id: PUTF8Char; p4: nk_flags; row_height: Integer; row_count: Integer): nk_bool; cdecl;
  nk_list_view_end: procedure(p1: Pnk_list_view); cdecl;
  nk_widget: function(p1: Pnk_rect; const p2: Pnk_context): nk_widget_layout_states; cdecl;
  nk_widget_fitting: function(p1: Pnk_rect; p2: Pnk_context; p3: nk_vec2): nk_widget_layout_states; cdecl;
  nk_widget_bounds: function(p1: Pnk_context): nk_rect; cdecl;
  nk_widget_position: function(p1: Pnk_context): nk_vec2; cdecl;
  nk_widget_size: function(p1: Pnk_context): nk_vec2; cdecl;
  nk_widget_width: function(p1: Pnk_context): Single; cdecl;
  nk_widget_height: function(p1: Pnk_context): Single; cdecl;
  nk_widget_is_hovered: function(p1: Pnk_context): nk_bool; cdecl;
  nk_widget_is_mouse_clicked: function(p1: Pnk_context; p2: nk_buttons): nk_bool; cdecl;
  nk_widget_has_mouse_click_down: function(p1: Pnk_context; p2: nk_buttons; down: nk_bool): nk_bool; cdecl;
  nk_spacing: procedure(p1: Pnk_context; cols: Integer); cdecl;
  nk_text: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; p4: nk_flags); cdecl;
  nk_text_colored: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; p4: nk_flags; p5: nk_color); cdecl;
  nk_text_wrap: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: Integer); cdecl;
  nk_text_wrap_colored: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; p4: nk_color); cdecl;
  nk_label: procedure(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags); cdecl;
  nk_label_colored: procedure(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; p4: nk_color); cdecl;
  nk_label_wrap: procedure(p1: Pnk_context; const p2: PUTF8Char); cdecl;
  nk_label_colored_wrap: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: nk_color); cdecl;
  nk_image_rtn: procedure(p1: Pnk_context; p2: nk_image); cdecl;
  nk_image_color: procedure(p1: Pnk_context; p2: nk_image; p3: nk_color); cdecl;
  nk_button_text: function(p1: Pnk_context; const title: PUTF8Char; len: Integer): nk_bool; cdecl;
  nk_button_label: function(p1: Pnk_context; const title: PUTF8Char): nk_bool; cdecl;
  nk_button_color: function(p1: Pnk_context; p2: nk_color): nk_bool; cdecl;
  nk_button_symbol: function(p1: Pnk_context; p2: nk_symbol_type): nk_bool; cdecl;
  nk_button_image: function(p1: Pnk_context; img: nk_image): nk_bool; cdecl;
  nk_button_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; text_alignment: nk_flags): nk_bool; cdecl;
  nk_button_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;
  nk_button_image_label: function(p1: Pnk_context; img: nk_image; const p3: PUTF8Char; text_alignment: nk_flags): nk_bool; cdecl;
  nk_button_image_text: function(p1: Pnk_context; img: nk_image; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;
  nk_button_text_styled: function(p1: Pnk_context; const p2: Pnk_style_button; const title: PUTF8Char; len: Integer): nk_bool; cdecl;
  nk_button_label_styled: function(p1: Pnk_context; const p2: Pnk_style_button; const title: PUTF8Char): nk_bool; cdecl;
  nk_button_symbol_styled: function(p1: Pnk_context; const p2: Pnk_style_button; p3: nk_symbol_type): nk_bool; cdecl;
  nk_button_image_styled: function(p1: Pnk_context; const p2: Pnk_style_button; img: nk_image): nk_bool; cdecl;
  nk_button_symbol_text_styled: function(p1: Pnk_context; const p2: Pnk_style_button; p3: nk_symbol_type; const p4: PUTF8Char; p5: Integer; alignment: nk_flags): nk_bool; cdecl;
  nk_button_symbol_label_styled: function(ctx: Pnk_context; const style: Pnk_style_button; symbol: nk_symbol_type; const title: PUTF8Char; align: nk_flags): nk_bool; cdecl;
  nk_button_image_label_styled: function(p1: Pnk_context; const p2: Pnk_style_button; img: nk_image; const p4: PUTF8Char; text_alignment: nk_flags): nk_bool; cdecl;
  nk_button_image_text_styled: function(p1: Pnk_context; const p2: Pnk_style_button; img: nk_image; const p4: PUTF8Char; p5: Integer; alignment: nk_flags): nk_bool; cdecl;
  nk_button_set_behavior: procedure(p1: Pnk_context; p2: nk_button_behavior); cdecl;
  nk_button_push_behavior: function(p1: Pnk_context; p2: nk_button_behavior): nk_bool; cdecl;
  nk_button_pop_behavior: function(p1: Pnk_context): nk_bool; cdecl;
  nk_check_label: function(p1: Pnk_context; const p2: PUTF8Char; active: nk_bool): nk_bool; cdecl;
  nk_check_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; active: nk_bool): nk_bool; cdecl;
  nk_check_flags_label: function(p1: Pnk_context; const p2: PUTF8Char; flags: Cardinal; value: Cardinal): Cardinal; cdecl;
  nk_check_flags_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; flags: Cardinal; value: Cardinal): Cardinal; cdecl;
  nk_checkbox_label: function(p1: Pnk_context; const p2: PUTF8Char; active: Pnk_bool): nk_bool; cdecl;
  nk_checkbox_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; active: Pnk_bool): nk_bool; cdecl;
  nk_checkbox_flags_label: function(p1: Pnk_context; const p2: PUTF8Char; flags: PCardinal; value: Cardinal): nk_bool; cdecl;
  nk_checkbox_flags_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; flags: PCardinal; value: Cardinal): nk_bool; cdecl;
  nk_radio_label: function(p1: Pnk_context; const p2: PUTF8Char; active: Pnk_bool): nk_bool; cdecl;
  nk_radio_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; active: Pnk_bool): nk_bool; cdecl;
  nk_option_label: function(p1: Pnk_context; const p2: PUTF8Char; active: nk_bool): nk_bool; cdecl;
  nk_option_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; active: nk_bool): nk_bool; cdecl;
  nk_selectable_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;
  nk_selectable_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;
  nk_selectable_image_label: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;
  nk_selectable_image_text: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; p4: Integer; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;
  nk_selectable_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;
  nk_selectable_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;
  nk_select_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; value: nk_bool): nk_bool; cdecl;
  nk_select_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags; value: nk_bool): nk_bool; cdecl;
  nk_select_image_label: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; align: nk_flags; value: nk_bool): nk_bool; cdecl;
  nk_select_image_text: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; p4: Integer; align: nk_flags; value: nk_bool): nk_bool; cdecl;
  nk_select_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; align: nk_flags; value: nk_bool): nk_bool; cdecl;
  nk_select_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; align: nk_flags; value: nk_bool): nk_bool; cdecl;
  nk_slide_float: function(p1: Pnk_context; min: Single; val: Single; max: Single; step: Single): Single; cdecl;
  nk_slide_int: function(p1: Pnk_context; min: Integer; val: Integer; max: Integer; step: Integer): Integer; cdecl;
  nk_slider_float: function(p1: Pnk_context; min: Single; val: PSingle; max: Single; step: Single): nk_bool; cdecl;
  nk_slider_int: function(p1: Pnk_context; min: Integer; val: PInteger; max: Integer; step: Integer): nk_bool; cdecl;
  nk_progress: function(p1: Pnk_context; cur: Pnk_size; max: nk_size; modifyable: nk_bool): nk_bool; cdecl;
  nk_prog: function(p1: Pnk_context; cur: nk_size; max: nk_size; modifyable: nk_bool): nk_size; cdecl;
  nk_color_picker: function(p1: Pnk_context; p2: nk_colorf; p3: nk_color_format): nk_colorf; cdecl;
  nk_color_pick: function(p1: Pnk_context; p2: Pnk_colorf; p3: nk_color_format): nk_bool; cdecl;
  nk_property_int: procedure(p1: Pnk_context; const name: PUTF8Char; min: Integer; val: PInteger; max: Integer; step: Integer; inc_per_pixel: Single); cdecl;
  nk_property_float: procedure(p1: Pnk_context; const name: PUTF8Char; min: Single; val: PSingle; max: Single; step: Single; inc_per_pixel: Single); cdecl;
  nk_property_double: procedure(p1: Pnk_context; const name: PUTF8Char; min: Double; val: PDouble; max: Double; step: Double; inc_per_pixel: Single); cdecl;
  nk_propertyi: function(p1: Pnk_context; const name: PUTF8Char; min: Integer; val: Integer; max: Integer; step: Integer; inc_per_pixel: Single): Integer; cdecl;
  nk_propertyf: function(p1: Pnk_context; const name: PUTF8Char; min: Single; val: Single; max: Single; step: Single; inc_per_pixel: Single): Single; cdecl;
  nk_propertyd: function(p1: Pnk_context; const name: PUTF8Char; min: Double; val: Double; max: Double; step: Double; inc_per_pixel: Single): Double; cdecl;
  nk_edit_string: function(p1: Pnk_context; p2: nk_flags; buffer: PUTF8Char; len: PInteger; max: Integer; p6: nk_plugin_filter): nk_flags; cdecl;
  nk_edit_string_zero_terminated: function(p1: Pnk_context; p2: nk_flags; buffer: PUTF8Char; max: Integer; p5: nk_plugin_filter): nk_flags; cdecl;
  nk_edit_buffer: function(p1: Pnk_context; p2: nk_flags; p3: Pnk_text_edit; p4: nk_plugin_filter): nk_flags; cdecl;
  nk_edit_focus: procedure(p1: Pnk_context; flags: nk_flags); cdecl;
  nk_edit_unfocus: procedure(p1: Pnk_context); cdecl;
  nk_chart_begin: function(p1: Pnk_context; p2: nk_chart_type; num: Integer; min: Single; max: Single): nk_bool; cdecl;
  nk_chart_begin_colored: function(p1: Pnk_context; p2: nk_chart_type; p3: nk_color; active: nk_color; num: Integer; min: Single; max: Single): nk_bool; cdecl;
  nk_chart_add_slot: procedure(ctx: Pnk_context; const p2: nk_chart_type; count: Integer; min_value: Single; max_value: Single); cdecl;
  nk_chart_add_slot_colored: procedure(ctx: Pnk_context; const p2: nk_chart_type; p3: nk_color; active: nk_color; count: Integer; min_value: Single; max_value: Single); cdecl;
  nk_chart_push: function(p1: Pnk_context; p2: Single): nk_flags; cdecl;
  nk_chart_push_slot: function(p1: Pnk_context; p2: Single; p3: Integer): nk_flags; cdecl;
  nk_chart_end: procedure(p1: Pnk_context); cdecl;
  nk_plot: procedure(p1: Pnk_context; p2: nk_chart_type; const values: PSingle; count: Integer; offset: Integer); cdecl;
  nk_plot_function: procedure(p1: Pnk_context; p2: nk_chart_type; userdata: Pointer; value_getter: nk_plot_function_value_getter; count: Integer; offset: Integer); cdecl;
  nk_popup_begin: function(p1: Pnk_context; p2: nk_popup_type; const p3: PUTF8Char; p4: nk_flags; bounds: nk_rect): nk_bool; cdecl;
  nk_popup_close: procedure(p1: Pnk_context); cdecl;
  nk_popup_end: procedure(p1: Pnk_context); cdecl;
  nk_popup_get_scroll: procedure(p1: Pnk_context; offset_x: Pnk_uint; offset_y: Pnk_uint); cdecl;
  nk_popup_set_scroll: procedure(p1: Pnk_context; offset_x: nk_uint; offset_y: nk_uint); cdecl;
  nk_combo: function(p1: Pnk_context; items: PPUTF8Char; count: Integer; selected: Integer; item_height: Integer; size: nk_vec2): Integer; cdecl;
  nk_combo_separator: function(p1: Pnk_context; const items_separated_by_separator: PUTF8Char; separator: Integer; selected: Integer; count: Integer; item_height: Integer; size: nk_vec2): Integer; cdecl;
  nk_combo_string: function(p1: Pnk_context; const items_separated_by_zeros: PUTF8Char; selected: Integer; count: Integer; item_height: Integer; size: nk_vec2): Integer; cdecl;
  nk_combo_callback: function(p1: Pnk_context; item_getter: nk_combo_callback_item_getter; userdata: Pointer; selected: Integer; count: Integer; item_height: Integer; size: nk_vec2): Integer; cdecl;
  nk_combobox: procedure(p1: Pnk_context; items: PPUTF8Char; count: Integer; selected: PInteger; item_height: Integer; size: nk_vec2); cdecl;
  nk_combobox_string: procedure(p1: Pnk_context; const items_separated_by_zeros: PUTF8Char; selected: PInteger; count: Integer; item_height: Integer; size: nk_vec2); cdecl;
  nk_combobox_separator: procedure(p1: Pnk_context; const items_separated_by_separator: PUTF8Char; separator: Integer; selected: PInteger; count: Integer; item_height: Integer; size: nk_vec2); cdecl;
  nk_combobox_callback: procedure(p1: Pnk_context; item_getter: nk_combobox_callback_item_getter; p3: Pointer; selected: PInteger; count: Integer; item_height: Integer; size: nk_vec2); cdecl;
  nk_combo_begin_text: function(p1: Pnk_context; const selected: PUTF8Char; p3: Integer; size: nk_vec2): nk_bool; cdecl;
  nk_combo_begin_label: function(p1: Pnk_context; const selected: PUTF8Char; size: nk_vec2): nk_bool; cdecl;
  nk_combo_begin_color: function(p1: Pnk_context; color: nk_color; size: nk_vec2): nk_bool; cdecl;
  nk_combo_begin_symbol: function(p1: Pnk_context; p2: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;
  nk_combo_begin_symbol_label: function(p1: Pnk_context; const selected: PUTF8Char; p3: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;
  nk_combo_begin_symbol_text: function(p1: Pnk_context; const selected: PUTF8Char; p3: Integer; p4: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;
  nk_combo_begin_image: function(p1: Pnk_context; img: nk_image; size: nk_vec2): nk_bool; cdecl;
  nk_combo_begin_image_label: function(p1: Pnk_context; const selected: PUTF8Char; p3: nk_image; size: nk_vec2): nk_bool; cdecl;
  nk_combo_begin_image_text: function(p1: Pnk_context; const selected: PUTF8Char; p3: Integer; p4: nk_image; size: nk_vec2): nk_bool; cdecl;
  nk_combo_item_label: function(p1: Pnk_context; const p2: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;
  nk_combo_item_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; alignment: nk_flags): nk_bool; cdecl;
  nk_combo_item_image_label: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;
  nk_combo_item_image_text: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;
  nk_combo_item_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;
  nk_combo_item_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;
  nk_combo_close: procedure(p1: Pnk_context); cdecl;
  nk_combo_end: procedure(p1: Pnk_context); cdecl;
  nk_contextual_begin: function(p1: Pnk_context; p2: nk_flags; p3: nk_vec2; trigger_bounds: nk_rect): nk_bool; cdecl;
  nk_contextual_item_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags): nk_bool; cdecl;
  nk_contextual_item_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags): nk_bool; cdecl;
  nk_contextual_item_image_label: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;
  nk_contextual_item_image_text: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; len: Integer; alignment: nk_flags): nk_bool; cdecl;
  nk_contextual_item_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;
  nk_contextual_item_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;
  nk_contextual_close: procedure(p1: Pnk_context); cdecl;
  nk_contextual_end: procedure(p1: Pnk_context); cdecl;
  nk_tooltip: procedure(p1: Pnk_context; const p2: PUTF8Char); cdecl;
  nk_tooltip_begin: function(p1: Pnk_context; width: Single): nk_bool; cdecl;
  nk_tooltip_end: procedure(p1: Pnk_context); cdecl;
  nk_menubar_begin: procedure(p1: Pnk_context); cdecl;
  nk_menubar_end: procedure(p1: Pnk_context); cdecl;
  nk_menu_begin_text: function(p1: Pnk_context; const title: PUTF8Char; title_len: Integer; align: nk_flags; size: nk_vec2): nk_bool; cdecl;
  nk_menu_begin_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; size: nk_vec2): nk_bool; cdecl;
  nk_menu_begin_image: function(p1: Pnk_context; const p2: PUTF8Char; p3: nk_image; size: nk_vec2): nk_bool; cdecl;
  nk_menu_begin_image_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags; p5: nk_image; size: nk_vec2): nk_bool; cdecl;
  nk_menu_begin_image_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; p4: nk_image; size: nk_vec2): nk_bool; cdecl;
  nk_menu_begin_symbol: function(p1: Pnk_context; const p2: PUTF8Char; p3: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;
  nk_menu_begin_symbol_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags; p5: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;
  nk_menu_begin_symbol_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; p4: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;
  nk_menu_item_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags): nk_bool; cdecl;
  nk_menu_item_label: function(p1: Pnk_context; const p2: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;
  nk_menu_item_image_label: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;
  nk_menu_item_image_text: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; len: Integer; alignment: nk_flags): nk_bool; cdecl;
  nk_menu_item_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;
  nk_menu_item_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;
  nk_menu_close: procedure(p1: Pnk_context); cdecl;
  nk_menu_end: procedure(p1: Pnk_context); cdecl;
  nk_style_default: procedure(p1: Pnk_context); cdecl;
  nk_style_from_table: procedure(p1: Pnk_context; const p2: Pnk_color); cdecl;
  nk_style_load_cursor: procedure(p1: Pnk_context; p2: nk_style_cursor; const p3: Pnk_cursor); cdecl;
  nk_style_load_all_cursors: procedure(p1: Pnk_context; p2: Pnk_cursor); cdecl;
  nk_style_get_color_by_name: function(p1: nk_style_colors): PUTF8Char; cdecl;
  nk_style_set_font: procedure(p1: Pnk_context; const p2: Pnk_user_font); cdecl;
  nk_style_set_cursor: function(p1: Pnk_context; p2: nk_style_cursor): nk_bool; cdecl;
  nk_style_show_cursor: procedure(p1: Pnk_context); cdecl;
  nk_style_hide_cursor: procedure(p1: Pnk_context); cdecl;
  nk_style_push_font: function(p1: Pnk_context; const p2: Pnk_user_font): nk_bool; cdecl;
  nk_style_push_float: function(p1: Pnk_context; p2: PSingle; p3: Single): nk_bool; cdecl;
  nk_style_push_vec2: function(p1: Pnk_context; p2: Pnk_vec2; p3: nk_vec2): nk_bool; cdecl;
  nk_style_push_style_item: function(p1: Pnk_context; p2: Pnk_style_item; p3: nk_style_item): nk_bool; cdecl;
  nk_style_push_flags: function(p1: Pnk_context; p2: Pnk_flags; p3: nk_flags): nk_bool; cdecl;
  nk_style_push_color: function(p1: Pnk_context; p2: Pnk_color; p3: nk_color): nk_bool; cdecl;
  nk_style_pop_font: function(p1: Pnk_context): nk_bool; cdecl;
  nk_style_pop_float: function(p1: Pnk_context): nk_bool; cdecl;
  nk_style_pop_vec2: function(p1: Pnk_context): nk_bool; cdecl;
  nk_style_pop_style_item: function(p1: Pnk_context): nk_bool; cdecl;
  nk_style_pop_flags: function(p1: Pnk_context): nk_bool; cdecl;
  nk_style_pop_color: function(p1: Pnk_context): nk_bool; cdecl;
  nk_rgb_rtn: function(r: Integer; g: Integer; b: Integer): nk_color; cdecl;
  nk_rgb_iv: function(const rgb: PInteger): nk_color; cdecl;
  nk_rgb_bv: function(const rgb: Pnk_byte): nk_color; cdecl;
  nk_rgb_f: function(r: Single; g: Single; b: Single): nk_color; cdecl;
  nk_rgb_fv: function(const rgb: PSingle): nk_color; cdecl;
  nk_rgb_cf: function(c: nk_colorf): nk_color; cdecl;
  nk_rgb_hex: function(const rgb: PUTF8Char): nk_color; cdecl;
  nk_rgba_rtn: function(r: Integer; g: Integer; b: Integer; a: Integer): nk_color; cdecl;
  nk_rgba_u32: function(p1: nk_uint): nk_color; cdecl;
  nk_rgba_iv: function(const rgba: PInteger): nk_color; cdecl;
  nk_rgba_bv: function(const rgba: Pnk_byte): nk_color; cdecl;
  nk_rgba_f: function(r: Single; g: Single; b: Single; a: Single): nk_color; cdecl;
  nk_rgba_fv: function(const rgba: PSingle): nk_color; cdecl;
  nk_rgba_cf: function(c: nk_colorf): nk_color; cdecl;
  nk_rgba_hex: function(const rgb: PUTF8Char): nk_color; cdecl;
  nk_hsva_colorf: function(h: Single; s: Single; v: Single; a: Single): nk_colorf; cdecl;
  nk_hsva_colorfv: function(c: PSingle): nk_colorf; cdecl;
  nk_colorf_hsva_f: procedure(out_h: PSingle; out_s: PSingle; out_v: PSingle; out_a: PSingle; in_: nk_colorf); cdecl;
  nk_colorf_hsva_fv: procedure(hsva: PSingle; in_: nk_colorf); cdecl;
  nk_hsv: function(h: Integer; s: Integer; v: Integer): nk_color; cdecl;
  nk_hsv_iv: function(const hsv: PInteger): nk_color; cdecl;
  nk_hsv_bv: function(const hsv: Pnk_byte): nk_color; cdecl;
  nk_hsv_f: function(h: Single; s: Single; v: Single): nk_color; cdecl;
  nk_hsv_fv: function(const hsv: PSingle): nk_color; cdecl;
  nk_hsva: function(h: Integer; s: Integer; v: Integer; a: Integer): nk_color; cdecl;
  nk_hsva_iv: function(const hsva: PInteger): nk_color; cdecl;
  nk_hsva_bv: function(const hsva: Pnk_byte): nk_color; cdecl;
  nk_hsva_f: function(h: Single; s: Single; v: Single; a: Single): nk_color; cdecl;
  nk_hsva_fv: function(const hsva: PSingle): nk_color; cdecl;
  nk_color_f: procedure(r: PSingle; g: PSingle; b: PSingle; a: PSingle; p5: nk_color); cdecl;
  nk_color_fv: procedure(rgba_out: PSingle; p2: nk_color); cdecl;
  nk_color_cf: function(p1: nk_color): nk_colorf; cdecl;
  nk_color_d: procedure(r: PDouble; g: PDouble; b: PDouble; a: PDouble; p5: nk_color); cdecl;
  nk_color_dv: procedure(rgba_out: PDouble; p2: nk_color); cdecl;
  nk_color_u32: function(p1: nk_color): nk_uint; cdecl;
  nk_color_hex_rgba: procedure(output: PUTF8Char; p2: nk_color); cdecl;
  nk_color_hex_rgb: procedure(output: PUTF8Char; p2: nk_color); cdecl;
  nk_color_hsv_i: procedure(out_h: PInteger; out_s: PInteger; out_v: PInteger; p4: nk_color); cdecl;
  nk_color_hsv_b: procedure(out_h: Pnk_byte; out_s: Pnk_byte; out_v: Pnk_byte; p4: nk_color); cdecl;
  nk_color_hsv_iv: procedure(hsv_out: PInteger; p2: nk_color); cdecl;
  nk_color_hsv_bv: procedure(hsv_out: Pnk_byte; p2: nk_color); cdecl;
  nk_color_hsv_f: procedure(out_h: PSingle; out_s: PSingle; out_v: PSingle; p4: nk_color); cdecl;
  nk_color_hsv_fv: procedure(hsv_out: PSingle; p2: nk_color); cdecl;
  nk_color_hsva_i: procedure(h: PInteger; s: PInteger; v: PInteger; a: PInteger; p5: nk_color); cdecl;
  nk_color_hsva_b: procedure(h: Pnk_byte; s: Pnk_byte; v: Pnk_byte; a: Pnk_byte; p5: nk_color); cdecl;
  nk_color_hsva_iv: procedure(hsva_out: PInteger; p2: nk_color); cdecl;
  nk_color_hsva_bv: procedure(hsva_out: Pnk_byte; p2: nk_color); cdecl;
  nk_color_hsva_f: procedure(out_h: PSingle; out_s: PSingle; out_v: PSingle; out_a: PSingle; p5: nk_color); cdecl;
  nk_color_hsva_fv: procedure(hsva_out: PSingle; p2: nk_color); cdecl;
  nk_handle_ptr: function(p1: Pointer): nk_handle; cdecl;
  nk_handle_id: function(p1: Integer): nk_handle; cdecl;
  nk_image_handle: function(p1: nk_handle): nk_image; cdecl;
  nk_image_ptr: function(p1: Pointer): nk_image; cdecl;
  nk_image_id: function(p1: Integer): nk_image; cdecl;
  nk_image_is_subimage: function(const img: Pnk_image): nk_bool; cdecl;
  nk_subimage_ptr: function(p1: Pointer; w: nk_ushort; h: nk_ushort; sub_region: nk_rect): nk_image; cdecl;
  nk_subimage_id: function(p1: Integer; w: nk_ushort; h: nk_ushort; sub_region: nk_rect): nk_image; cdecl;
  nk_subimage_handle: function(p1: nk_handle; w: nk_ushort; h: nk_ushort; sub_region: nk_rect): nk_image; cdecl;
  nk_nine_slice_handle: function(p1: nk_handle; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;
  nk_nine_slice_ptr: function(p1: Pointer; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;
  nk_nine_slice_id: function(p1: Integer; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;
  nk_nine_slice_is_sub9slice: function(const img: Pnk_nine_slice): Integer; cdecl;
  nk_sub9slice_ptr: function(p1: Pointer; w: nk_ushort; h: nk_ushort; sub_region: nk_rect; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;
  nk_sub9slice_id: function(p1: Integer; w: nk_ushort; h: nk_ushort; sub_region: nk_rect; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;
  nk_sub9slice_handle: function(p1: nk_handle; w: nk_ushort; h: nk_ushort; sub_region: nk_rect; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;
  nk_murmur_hash: function(const key: Pointer; len: Integer; seed: nk_hash): nk_hash; cdecl;
  nk_triangle_from_direction: procedure(result: Pnk_vec2; r: nk_rect; pad_x: Single; pad_y: Single; p5: nk_heading); cdecl;
  nk_vec2_rtn: function(x: Single; y: Single): nk_vec2; cdecl;
  nk_vec2i_rtn: function(x: Integer; y: Integer): nk_vec2; cdecl;
  nk_vec2v: function(const xy: PSingle): nk_vec2; cdecl;
  nk_vec2iv: function(const xy: PInteger): nk_vec2; cdecl;
  nk_get_null_rect: function(): nk_rect; cdecl;
  nk_rect_rtn: function(x: Single; y: Single; w: Single; h: Single): nk_rect; cdecl;
  nk_recti_rtn: function(x: Integer; y: Integer; w: Integer; h: Integer): nk_rect; cdecl;
  nk_recta: function(pos: nk_vec2; size: nk_vec2): nk_rect; cdecl;
  nk_rectv: function(const xywh: PSingle): nk_rect; cdecl;
  nk_rectiv: function(const xywh: PInteger): nk_rect; cdecl;
  nk_rect_pos: function(p1: nk_rect): nk_vec2; cdecl;
  nk_rect_size: function(p1: nk_rect): nk_vec2; cdecl;
  nk_strlen: function(const str: PUTF8Char): Integer; cdecl;
  nk_stricmp: function(const s1: PUTF8Char; const s2: PUTF8Char): Integer; cdecl;
  nk_stricmpn: function(const s1: PUTF8Char; const s2: PUTF8Char; n: Integer): Integer; cdecl;
  nk_strtoi: function(const str: PUTF8Char; endptr: PPUTF8Char): Integer; cdecl;
  nk_strtof: function(const str: PUTF8Char; endptr: PPUTF8Char): Single; cdecl;
  nk_strtod: function(const str: PUTF8Char; endptr: PPUTF8Char): Double; cdecl;
  nk_strfilter: function(const text: PUTF8Char; const regexp: PUTF8Char): Integer; cdecl;
  nk_strmatch_fuzzy_string: function(const str: PUTF8Char; const pattern: PUTF8Char; out_score: PInteger): Integer; cdecl;
  nk_strmatch_fuzzy_text: function(const txt: PUTF8Char; txt_len: Integer; const pattern: PUTF8Char; out_score: PInteger): Integer; cdecl;
  nk_utf_decode: function(const p1: PUTF8Char; p2: Pnk_rune; p3: Integer): Integer; cdecl;
  nk_utf_encode: function(p1: nk_rune; p2: PUTF8Char; p3: Integer): Integer; cdecl;
  nk_utf_len: function(const p1: PUTF8Char; byte_len: Integer): Integer; cdecl;
  nk_utf_at: function(const buffer: PUTF8Char; length: Integer; index: Integer; unicode: Pnk_rune; len: PInteger): PUTF8Char; cdecl;
  nk_buffer_init: procedure(p1: Pnk_buffer; const p2: Pnk_allocator; size: nk_size); cdecl;
  nk_buffer_init_fixed: procedure(p1: Pnk_buffer; memory: Pointer; size: nk_size); cdecl;
  nk_buffer_info: procedure(p1: Pnk_memory_status; p2: Pnk_buffer); cdecl;
  nk_buffer_push: procedure(p1: Pnk_buffer; type_: nk_buffer_allocation_type; const memory: Pointer; size: nk_size; align: nk_size); cdecl;
  nk_buffer_mark: procedure(p1: Pnk_buffer; type_: nk_buffer_allocation_type); cdecl;
  nk_buffer_reset: procedure(p1: Pnk_buffer; type_: nk_buffer_allocation_type); cdecl;
  nk_buffer_clear: procedure(p1: Pnk_buffer); cdecl;
  nk_buffer_free: procedure(p1: Pnk_buffer); cdecl;
  nk_buffer_memory: function(p1: Pnk_buffer): Pointer; cdecl;
  nk_buffer_memory_const: function(const p1: Pnk_buffer): Pointer; cdecl;
  nk_buffer_total: function(p1: Pnk_buffer): nk_size; cdecl;
  nk_str_init: procedure(p1: Pnk_str; const p2: Pnk_allocator; size: nk_size); cdecl;
  nk_str_init_fixed: procedure(p1: Pnk_str; memory: Pointer; size: nk_size); cdecl;
  nk_str_clear: procedure(p1: Pnk_str); cdecl;
  nk_str_free: procedure(p1: Pnk_str); cdecl;
  nk_str_append_text_char: function(p1: Pnk_str; const p2: PUTF8Char; p3: Integer): Integer; cdecl;
  nk_str_append_str_char: function(p1: Pnk_str; const p2: PUTF8Char): Integer; cdecl;
  nk_str_append_text_utf8: function(p1: Pnk_str; const p2: PUTF8Char; p3: Integer): Integer; cdecl;
  nk_str_append_str_utf8: function(p1: Pnk_str; const p2: PUTF8Char): Integer; cdecl;
  nk_str_append_text_runes: function(p1: Pnk_str; const p2: Pnk_rune; p3: Integer): Integer; cdecl;
  nk_str_append_str_runes: function(p1: Pnk_str; const p2: Pnk_rune): Integer; cdecl;
  nk_str_insert_at_char: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char; p4: Integer): Integer; cdecl;
  nk_str_insert_at_rune: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char; p4: Integer): Integer; cdecl;
  nk_str_insert_text_char: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char; p4: Integer): Integer; cdecl;
  nk_str_insert_str_char: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char): Integer; cdecl;
  nk_str_insert_text_utf8: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char; p4: Integer): Integer; cdecl;
  nk_str_insert_str_utf8: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char): Integer; cdecl;
  nk_str_insert_text_runes: function(p1: Pnk_str; pos: Integer; const p3: Pnk_rune; p4: Integer): Integer; cdecl;
  nk_str_insert_str_runes: function(p1: Pnk_str; pos: Integer; const p3: Pnk_rune): Integer; cdecl;
  nk_str_remove_chars: procedure(p1: Pnk_str; len: Integer); cdecl;
  nk_str_remove_runes: procedure(str: Pnk_str; len: Integer); cdecl;
  nk_str_delete_chars: procedure(p1: Pnk_str; pos: Integer; len: Integer); cdecl;
  nk_str_delete_runes: procedure(p1: Pnk_str; pos: Integer; len: Integer); cdecl;
  nk_str_at_char: function(p1: Pnk_str; pos: Integer): PUTF8Char; cdecl;
  nk_str_at_rune: function(p1: Pnk_str; pos: Integer; unicode: Pnk_rune; len: PInteger): PUTF8Char; cdecl;
  nk_str_rune_at: function(const p1: Pnk_str; pos: Integer): nk_rune; cdecl;
  nk_str_at_char_const: function(const p1: Pnk_str; pos: Integer): PUTF8Char; cdecl;
  nk_str_at_const: function(const p1: Pnk_str; pos: Integer; unicode: Pnk_rune; len: PInteger): PUTF8Char; cdecl;
  nk_str_get: function(p1: Pnk_str): PUTF8Char; cdecl;
  nk_str_get_const: function(const p1: Pnk_str): PUTF8Char; cdecl;
  nk_str_len: function(p1: Pnk_str): Integer; cdecl;
  nk_str_len_char: function(p1: Pnk_str): Integer; cdecl;
  nk_filter_default: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;
  nk_filter_ascii: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;
  nk_filter_float: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;
  nk_filter_decimal: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;
  nk_filter_hex: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;
  nk_filter_oct: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;
  nk_filter_binary: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;
  nk_textedit_init: procedure(p1: Pnk_text_edit; p2: Pnk_allocator; size: nk_size); cdecl;
  nk_textedit_init_fixed: procedure(p1: Pnk_text_edit; memory: Pointer; size: nk_size); cdecl;
  nk_textedit_free: procedure(p1: Pnk_text_edit); cdecl;
  nk_textedit_text: procedure(p1: Pnk_text_edit; const p2: PUTF8Char; total_len: Integer); cdecl;
  nk_textedit_delete: procedure(p1: Pnk_text_edit; where: Integer; len: Integer); cdecl;
  nk_textedit_delete_selection: procedure(p1: Pnk_text_edit); cdecl;
  nk_textedit_select_all: procedure(p1: Pnk_text_edit); cdecl;
  nk_textedit_cut: function(p1: Pnk_text_edit): nk_bool; cdecl;
  nk_textedit_paste: function(p1: Pnk_text_edit; const p2: PUTF8Char; len: Integer): nk_bool; cdecl;
  nk_textedit_undo: procedure(p1: Pnk_text_edit); cdecl;
  nk_textedit_redo: procedure(p1: Pnk_text_edit); cdecl;
  nk_stroke_line: procedure(b: Pnk_command_buffer; x0: Single; y0: Single; x1: Single; y1: Single; line_thickness: Single; p7: nk_color); cdecl;
  nk_stroke_curve: procedure(p1: Pnk_command_buffer; p2: Single; p3: Single; p4: Single; p5: Single; p6: Single; p7: Single; p8: Single; p9: Single; line_thickness: Single; p11: nk_color); cdecl;
  nk_stroke_rect: procedure(p1: Pnk_command_buffer; p2: nk_rect; rounding: Single; line_thickness: Single; p5: nk_color); cdecl;
  nk_stroke_circle: procedure(p1: Pnk_command_buffer; p2: nk_rect; line_thickness: Single; p4: nk_color); cdecl;
  nk_stroke_arc: procedure(p1: Pnk_command_buffer; cx: Single; cy: Single; radius: Single; a_min: Single; a_max: Single; line_thickness: Single; p8: nk_color); cdecl;
  nk_stroke_triangle: procedure(p1: Pnk_command_buffer; p2: Single; p3: Single; p4: Single; p5: Single; p6: Single; p7: Single; line_thichness: Single; p9: nk_color); cdecl;
  nk_stroke_polyline: procedure(p1: Pnk_command_buffer; points: PSingle; point_count: Integer; line_thickness: Single; col: nk_color); cdecl;
  nk_stroke_polygon: procedure(p1: Pnk_command_buffer; p2: PSingle; point_count: Integer; line_thickness: Single; p5: nk_color); cdecl;
  nk_fill_rect: procedure(p1: Pnk_command_buffer; p2: nk_rect; rounding: Single; p4: nk_color); cdecl;
  nk_fill_rect_multi_color: procedure(p1: Pnk_command_buffer; p2: nk_rect; left: nk_color; top: nk_color; right: nk_color; bottom: nk_color); cdecl;
  nk_fill_circle: procedure(p1: Pnk_command_buffer; p2: nk_rect; p3: nk_color); cdecl;
  nk_fill_arc: procedure(p1: Pnk_command_buffer; cx: Single; cy: Single; radius: Single; a_min: Single; a_max: Single; p7: nk_color); cdecl;
  nk_fill_triangle: procedure(p1: Pnk_command_buffer; x0: Single; y0: Single; x1: Single; y1: Single; x2: Single; y2: Single; p8: nk_color); cdecl;
  nk_fill_polygon: procedure(p1: Pnk_command_buffer; p2: PSingle; point_count: Integer; p4: nk_color); cdecl;
  nk_draw_image: procedure(p1: Pnk_command_buffer; p2: nk_rect; const p3: Pnk_image; p4: nk_color); cdecl;
  nk_draw_nine_slice: procedure(p1: Pnk_command_buffer; p2: nk_rect; const p3: Pnk_nine_slice; p4: nk_color); cdecl;
  nk_draw_text: procedure(p1: Pnk_command_buffer; p2: nk_rect; const text: PUTF8Char; len: Integer; const p5: Pnk_user_font; p6: nk_color; p7: nk_color); cdecl;
  nk_push_scissor: procedure(p1: Pnk_command_buffer; p2: nk_rect); cdecl;
  nk_push_custom: procedure(p1: Pnk_command_buffer; p2: nk_rect; p3: nk_command_custom_callback; usr: nk_handle); cdecl;
  nk_input_has_mouse_click: function(const p1: Pnk_input; p2: nk_buttons): nk_bool; cdecl;
  nk_input_has_mouse_click_in_rect: function(const p1: Pnk_input; p2: nk_buttons; p3: nk_rect): nk_bool; cdecl;
  nk_input_has_mouse_click_down_in_rect: function(const p1: Pnk_input; p2: nk_buttons; p3: nk_rect; down: nk_bool): nk_bool; cdecl;
  nk_input_is_mouse_click_in_rect: function(const p1: Pnk_input; p2: nk_buttons; p3: nk_rect): nk_bool; cdecl;
  nk_input_is_mouse_click_down_in_rect: function(const i: Pnk_input; id: nk_buttons; b: nk_rect; down: nk_bool): nk_bool; cdecl;
  nk_input_any_mouse_click_in_rect: function(const p1: Pnk_input; p2: nk_rect): nk_bool; cdecl;
  nk_input_is_mouse_prev_hovering_rect: function(const p1: Pnk_input; p2: nk_rect): nk_bool; cdecl;
  nk_input_is_mouse_hovering_rect: function(const p1: Pnk_input; p2: nk_rect): nk_bool; cdecl;
  nk_input_mouse_clicked: function(const p1: Pnk_input; p2: nk_buttons; p3: nk_rect): nk_bool; cdecl;
  nk_input_is_mouse_down: function(const p1: Pnk_input; p2: nk_buttons): nk_bool; cdecl;
  nk_input_is_mouse_pressed: function(const p1: Pnk_input; p2: nk_buttons): nk_bool; cdecl;
  nk_input_is_mouse_released: function(const p1: Pnk_input; p2: nk_buttons): nk_bool; cdecl;
  nk_input_is_key_pressed: function(const p1: Pnk_input; p2: nk_keys): nk_bool; cdecl;
  nk_input_is_key_released: function(const p1: Pnk_input; p2: nk_keys): nk_bool; cdecl;
  nk_input_is_key_down: function(const p1: Pnk_input; p2: nk_keys): nk_bool; cdecl;
  nk_style_item_color_rtn: function(p1: nk_color): nk_style_item; cdecl;
  nk_style_item_image_rtn: function(img: nk_image): nk_style_item; cdecl;
  nk_style_item_nine_slice_rtn: function(slice: nk_nine_slice): nk_style_item; cdecl;
  nk_style_item_hide: function(): nk_style_item; cdecl;

{$ENDREGION}

{$REGION '  === SPEECHLIB ============================================================='}
const
  SVEStartInputStream = $00000002;
  SVEEndInputStream   = $00000004;
  SVEVoiceChange      = $00000008;
  SVEBookmark         = $00000010;
  SVEWordBoundary     = $00000020;
  SVEPhoneme          = $00000040;
  SVESentenceBoundary = $00000080;
  SVEViseme           = $00000100;
  SVEAudioLevel       = $00000200;
  SVEPrivate          = $00008000;
  SVEAllEvents        = $000083FE;

  SVSFDefault          = $00000000;
  SVSFlagsAsync        = $00000001;
  SVSFPurgeBeforeSpeak = $00000002;
  SVSFIsFilename       = $00000004;
  SVSFIsXML            = $00000008;
  SVSFIsNotXML         = $00000010;
  SVSFPersistXML       = $00000020;
  SVSFNLPSpeakPunc     = $00000040;
  SVSFParseSapi        = $00000080;
  SVSFParseSsml        = $00000100;
  SVSFParseAutodetect  = $00000000;
  SVSFNLPMask          = $00000040;
  SVSFParseMask        = $00000180;
  SVSFVoiceMask        = $000001FF;
  SVSFUnusedFlags      = $FFFFFE00;

  SRSEDone       = $00000001;
  SRSEIsSpeaking = $00000002;

type
  SpeechVisemeFeature          = TOleEnum;
  SpeechVisemeType             = TOleEnum;
  SpeechDataKeyLocation        = TOleEnum;
  SpeechTokenContext           = TOleEnum;
  SpeechTokenShellFolder       = TOleEnum;
  SpeechRunState               = TOleEnum;
  SpeechAudioFormatType        = TOleEnum;
  SpeechStreamSeekPositionType = TOleEnum;
  SpeechVoiceEvents            = TOleEnum;
  SpeechVoicePriority          = TOleEnum;
  SpeechVoiceSpeakFlags        = TOleEnum;

  { ISpeechObjectToken }
  ISpeechObjectToken = interface;

  { ISpeechDataKey }
  ISpeechDataKey = interface(IDispatch)
    ['{CE17C09B-4EFA-44D5-A4C9-59D9585AB0CD}']
    procedure SetBinaryValue(const ValueName: WideString; Value: OleVariant); safecall;
    function GetBinaryValue(const ValueName: WideString): OleVariant; safecall;
    procedure SetStringValue(const ValueName: WideString; const Value: WideString); safecall;
    function GetStringValue(const ValueName: WideString): WideString; safecall;
    procedure SetLongValue(const ValueName: WideString; Value: Integer); safecall;
    function GetLongValue(const ValueName: WideString): Integer; safecall;
    function OpenKey(const SubKeyName: WideString): ISpeechDataKey; safecall;
    function CreateKey(const SubKeyName: WideString): ISpeechDataKey; safecall;
    procedure DeleteKey(const SubKeyName: WideString); safecall;
    procedure DeleteValue(const ValueName: WideString); safecall;
    function EnumKeys(Index: Integer): WideString; safecall;
    function EnumValues(Index: Integer): WideString; safecall;
  end;

  {  ISpeechObjectTokens }
  ISpeechObjectTokens = interface(IDispatch)
    ['{9285B776-2E7B-4BC0-B53E-580EB6FA967F}']
    function Get_Count: Integer; safecall;
    function Item(Index: Integer): ISpeechObjectToken; safecall;
    function Get__NewEnum: IUnknown; safecall;
    property Count: Integer read Get_Count;
    property _NewEnum: IUnknown read Get__NewEnum;
  end;

  { ISpeechObjectTokenCategory }
  ISpeechObjectTokenCategory = interface(IDispatch)
    ['{CA7EAC50-2D01-4145-86D4-5AE7D70F4469}']
    function Get_Id: WideString; safecall;
    procedure Set_Default(const TokenId: WideString); safecall;
    function Get_Default: WideString; safecall;
    procedure SetId(const Id: WideString; CreateIfNotExist: WordBool); safecall;
    function GetDataKey(Location: SpeechDataKeyLocation): ISpeechDataKey; safecall;
    function EnumerateTokens(const RequiredAttributes: WideString; const OptionalAttributes: WideString): ISpeechObjectTokens; safecall;
    property Id: WideString read Get_Id;
    property Default: WideString read Get_Default write Set_Default;
  end;

  { ISpeechObjectToken }
  ISpeechObjectToken = interface(IDispatch)
    ['{C74A3ADC-B727-4500-A84A-B526721C8B8C}']
    function Get_Id: WideString; safecall;
    function Get_DataKey: ISpeechDataKey; safecall;
    function Get_Category: ISpeechObjectTokenCategory; safecall;
    function GetDescription(Locale: Integer): WideString; safecall;
    procedure SetId(const Id: WideString; const CategoryID: WideString; CreateIfNotExist: WordBool); safecall;
    function GetAttribute(const AttributeName: WideString): WideString; safecall;
    function CreateInstance(const pUnkOuter: IUnknown; ClsContext: SpeechTokenContext): IUnknown; safecall;
    procedure Remove(const ObjectStorageCLSID: WideString); safecall;
    function GetStorageFileName(const ObjectStorageCLSID: WideString; const KeyName: WideString; const FileName: WideString; Folder: SpeechTokenShellFolder): WideString; safecall;
    procedure RemoveStorageFileName(const ObjectStorageCLSID: WideString; const KeyName: WideString; DeleteFile: WordBool); safecall;
    function IsUISupported(const TypeOfUI: WideString; const ExtraData: OleVariant; const Object_: IUnknown): WordBool; safecall;
    procedure DisplayUI(hWnd: Integer; const Title: WideString; const TypeOfUI: WideString; const ExtraData: OleVariant; const Object_: IUnknown); safecall;
    function MatchesAttributes(const Attributes: WideString): WordBool; safecall;
    property Id: WideString read Get_Id;
    property DataKey: ISpeechDataKey read Get_DataKey;
    property Category: ISpeechObjectTokenCategory read Get_Category;
  end;

  { ISpeechVoiceStatus }
  ISpeechVoiceStatus = interface(IDispatch)
    ['{8BE47B07-57F6-11D2-9EEE-00C04F797396}']
    function Get_CurrentStreamNumber: Integer; safecall;
    function Get_LastStreamNumberQueued: Integer; safecall;
    function Get_LastHResult: Integer; safecall;
    function Get_RunningState: SpeechRunState; safecall;
    function Get_InputWordPosition: Integer; safecall;
    function Get_InputWordLength: Integer; safecall;
    function Get_InputSentencePosition: Integer; safecall;
    function Get_InputSentenceLength: Integer; safecall;
    function Get_LastBookmark: WideString; safecall;
    function Get_LastBookmarkId: Integer; safecall;
    function Get_PhonemeId: Smallint; safecall;
    function Get_VisemeId: Smallint; safecall;
    property CurrentStreamNumber: Integer read Get_CurrentStreamNumber;
    property LastStreamNumberQueued: Integer read Get_LastStreamNumberQueued;
    property LastHResult: Integer read Get_LastHResult;
    property RunningState: SpeechRunState read Get_RunningState;
    property InputWordPosition: Integer read Get_InputWordPosition;
    property InputWordLength: Integer read Get_InputWordLength;
    property InputSentencePosition: Integer read Get_InputSentencePosition;
    property InputSentenceLength: Integer read Get_InputSentenceLength;
    property LastBookmark: WideString read Get_LastBookmark;
    property LastBookmarkId: Integer read Get_LastBookmarkId;
    property PhonemeId: Smallint read Get_PhonemeId;
    property VisemeId: Smallint read Get_VisemeId;
  end;

  { ISpeechWaveFormatEx }
  ISpeechWaveFormatEx = interface(IDispatch)
    ['{7A1EF0D5-1581-4741-88E4-209A49F11A10}']
    function Get_FormatTag: Smallint; safecall;
    procedure Set_FormatTag(FormatTag: Smallint); safecall;
    function Get_Channels: Smallint; safecall;
    procedure Set_Channels(Channels: Smallint); safecall;
    function Get_SamplesPerSec: Integer; safecall;
    procedure Set_SamplesPerSec(SamplesPerSec: Integer); safecall;
    function Get_AvgBytesPerSec: Integer; safecall;
    procedure Set_AvgBytesPerSec(AvgBytesPerSec: Integer); safecall;
    function Get_BlockAlign: Smallint; safecall;
    procedure Set_BlockAlign(BlockAlign: Smallint); safecall;
    function Get_BitsPerSample: Smallint; safecall;
    procedure Set_BitsPerSample(BitsPerSample: Smallint); safecall;
    function Get_ExtraData: OleVariant; safecall;
    procedure Set_ExtraData(ExtraData: OleVariant); safecall;
    property FormatTag: Smallint read Get_FormatTag write Set_FormatTag;
    property Channels: Smallint read Get_Channels write Set_Channels;
    property SamplesPerSec: Integer read Get_SamplesPerSec write Set_SamplesPerSec;
    property AvgBytesPerSec: Integer read Get_AvgBytesPerSec write Set_AvgBytesPerSec;
    property BlockAlign: Smallint read Get_BlockAlign write Set_BlockAlign;
    property BitsPerSample: Smallint read Get_BitsPerSample write Set_BitsPerSample;
    property ExtraData: OleVariant read Get_ExtraData write Set_ExtraData;
  end;

  { ISpeechAudioFormat }
  ISpeechAudioFormat = interface(IDispatch)
    ['{E6E9C590-3E18-40E3-8299-061F98BDE7C7}']
    function Get_type_: SpeechAudioFormatType; safecall;
    procedure Set_type_(AudioFormat: SpeechAudioFormatType); safecall;
    function Get_Guid: WideString; safecall;
    procedure Set_Guid(const Guid: WideString); safecall;
    function GetWaveFormatEx: ISpeechWaveFormatEx; safecall;
    procedure SetWaveFormatEx(const SpeechWaveFormatEx: ISpeechWaveFormatEx); safecall;
    property type_: SpeechAudioFormatType read Get_type_ write Set_type_;
    property Guid: WideString read Get_Guid write Set_Guid;
  end;

  { ISpeechBaseStream }
  ISpeechBaseStream = interface(IDispatch)
    ['{6450336F-7D49-4CED-8097-49D6DEE37294}']
    function Get_Format: ISpeechAudioFormat; safecall;
    procedure _Set_Format(const AudioFormat: ISpeechAudioFormat); safecall;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer): Integer; safecall;
    function Write(Buffer: OleVariant): Integer; safecall;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType): OleVariant; safecall;
    property Format: ISpeechAudioFormat read Get_Format write _Set_Format;
  end;

  { ISpeechVoice }
  ISpeechVoice = interface(IDispatch)
    ['{269316D8-57BD-11D2-9EEE-00C04F797396}']
    function Get_Status: ISpeechVoiceStatus; safecall;
    function Get_Voice: ISpeechObjectToken; safecall;
    procedure _Set_Voice(const Voice: ISpeechObjectToken); safecall;
    function Get_AudioOutput: ISpeechObjectToken; safecall;
    procedure _Set_AudioOutput(const AudioOutput: ISpeechObjectToken); safecall;
    function Get_AudioOutputStream: ISpeechBaseStream; safecall;
    procedure _Set_AudioOutputStream(const AudioOutputStream: ISpeechBaseStream); safecall;
    function Get_Rate: Integer; safecall;
    procedure Set_Rate(Rate: Integer); safecall;
    function Get_Volume: Integer; safecall;
    procedure Set_Volume(Volume: Integer); safecall;
    procedure Set_AllowAudioOutputFormatChangesOnNextSet(Allow: WordBool); safecall;
    function Get_AllowAudioOutputFormatChangesOnNextSet: WordBool; safecall;
    function Get_EventInterests: SpeechVoiceEvents; safecall;
    procedure Set_EventInterests(EventInterestFlags: SpeechVoiceEvents); safecall;
    procedure Set_Priority(Priority: SpeechVoicePriority); safecall;
    function Get_Priority: SpeechVoicePriority; safecall;
    procedure Set_AlertBoundary(Boundary: SpeechVoiceEvents); safecall;
    function Get_AlertBoundary: SpeechVoiceEvents; safecall;
    procedure Set_SynchronousSpeakTimeout(msTimeout: Integer); safecall;
    function Get_SynchronousSpeakTimeout: Integer; safecall;
    function Speak(const Text: WideString; Flags: SpeechVoiceSpeakFlags): Integer; safecall;
    function SpeakStream(const Stream: ISpeechBaseStream; Flags: SpeechVoiceSpeakFlags): Integer; safecall;
    procedure Pause; safecall;
    procedure Resume; safecall;
    function Skip(const type_: WideString; NumItems: Integer): Integer; safecall;
    function GetVoices(const RequiredAttributes: WideString; const OptionalAttributes: WideString): ISpeechObjectTokens; safecall;
    function GetAudioOutputs(const RequiredAttributes: WideString; const OptionalAttributes: WideString): ISpeechObjectTokens; safecall;
    function WaitUntilDone(msTimeout: Integer): WordBool; safecall;
    function SpeakCompleteEvent: Integer; safecall;
    function IsUISupported(const TypeOfUI: WideString; const ExtraData: OleVariant): WordBool; safecall;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString; const TypeOfUI: WideString; const ExtraData: OleVariant); safecall;
    property Status: ISpeechVoiceStatus read Get_Status;
    property Voice: ISpeechObjectToken read Get_Voice write _Set_Voice;
    property AudioOutput: ISpeechObjectToken read Get_AudioOutput write _Set_AudioOutput;
    property AudioOutputStream: ISpeechBaseStream read Get_AudioOutputStream write _Set_AudioOutputStream;
    property Rate: Integer read Get_Rate write Set_Rate;
    property Volume: Integer read Get_Volume write Set_Volume;
    property AllowAudioOutputFormatChangesOnNextSet: WordBool read Get_AllowAudioOutputFormatChangesOnNextSet write Set_AllowAudioOutputFormatChangesOnNextSet;
    property EventInterests: SpeechVoiceEvents read Get_EventInterests write Set_EventInterests;
    property Priority: SpeechVoicePriority read Get_Priority write Set_Priority;
    property AlertBoundary: SpeechVoiceEvents read Get_AlertBoundary write Set_AlertBoundary;
    property SynchronousSpeakTimeout: Integer read Get_SynchronousSpeakTimeout write Set_SynchronousSpeakTimeout;
  end;

  TSpVoiceStartStream   = procedure(ASender: TObject; StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpVoiceEndStream     = procedure(ASender: TObject; StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpVoiceVoiceChange   = procedure(ASender: TObject; StreamNumber: Integer; StreamPosition: OleVariant; const VoiceObjectToken: ISpeechObjectToken) of object;
  TSpVoiceBookmark      = procedure(ASender: TObject; StreamNumber: Integer; StreamPosition: OleVariant; const Bookmark: WideString; BookmarkId: Integer) of object;
  TSpVoiceWord          = procedure(ASender: TObject; StreamNumber: Integer; StreamPosition: OleVariant; CharacterPosition: Integer; Length: Integer) of object;
  TSpVoiceSentence      = procedure(ASender: TObject; StreamNumber: Integer; StreamPosition: OleVariant; CharacterPosition: Integer; Length: Integer) of object;
  TSpVoicePhoneme       = procedure(ASender: TObject; StreamNumber: Integer; StreamPosition: OleVariant; Duration: Integer; NextPhoneId: Smallint; Feature: SpeechVisemeFeature; CurrentPhoneId: Smallint) of object;
  TSpVoiceViseme        = procedure(ASender: TObject; StreamNumber: Integer; StreamPosition: OleVariant; Duration: Integer; NextVisemeId: SpeechVisemeType; Feature: SpeechVisemeFeature; CurrentVisemeId: SpeechVisemeType) of object;
  TSpVoiceAudioLevel    = procedure(ASender: TObject; StreamNumber: Integer; StreamPosition: OleVariant; AudioLevel: Integer) of object;
  TSpVoiceEnginePrivate = procedure(ASender: TObject; StreamNumber: Integer; StreamPosition: Integer; EngineData: OleVariant) of object;

  { TSpVoice }
  TSpVoice = class(TOleServer)
  private
    FOnStartStream: TSpVoiceStartStream;
    FOnEndStream: TSpVoiceEndStream;
    FOnVoiceChange: TSpVoiceVoiceChange;
    FOnBookmark: TSpVoiceBookmark;
    FOnWord: TSpVoiceWord;
    FOnSentence: TSpVoiceSentence;
    FOnPhoneme: TSpVoicePhoneme;
    FOnViseme: TSpVoiceViseme;
    FOnAudioLevel: TSpVoiceAudioLevel;
    FOnEnginePrivate: TSpVoiceEnginePrivate;
    FIntf: ISpeechVoice;
    function GetDefaultInterface: ISpeechVoice;
  protected
    procedure InitServerData; override;
    procedure InvokeEvent(dispid: TDispID; var Params: TVariantArray); override;
    function Get_Status: ISpeechVoiceStatus;
    function Get_Voice: ISpeechObjectToken;
    procedure _Set_Voice(const Voice: ISpeechObjectToken);
    function Get_AudioOutput: ISpeechObjectToken;
    procedure _Set_AudioOutput(const AudioOutput: ISpeechObjectToken);
    function Get_AudioOutputStream: ISpeechBaseStream;
    procedure _Set_AudioOutputStream(const AudioOutputStream: ISpeechBaseStream);
    function Get_Rate: Integer;
    procedure Set_Rate(Rate: Integer);
    function Get_Volume: Integer;
    procedure Set_Volume(Volume: Integer);
    procedure Set_AllowAudioOutputFormatChangesOnNextSet(Allow: WordBool);
    function Get_AllowAudioOutputFormatChangesOnNextSet: WordBool;
    function Get_EventInterests: SpeechVoiceEvents;
    procedure Set_EventInterests(EventInterestFlags: SpeechVoiceEvents);
    procedure Set_Priority(Priority: SpeechVoicePriority);
    function Get_Priority: SpeechVoicePriority;
    procedure Set_AlertBoundary(Boundary: SpeechVoiceEvents);
    function Get_AlertBoundary: SpeechVoiceEvents;
    procedure Set_SynchronousSpeakTimeout(msTimeout: Integer);
    function Get_SynchronousSpeakTimeout: Integer;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechVoice);
    procedure Disconnect; override;
    function Speak(const Text: WideString; Flags: SpeechVoiceSpeakFlags): Integer;
    function SpeakStream(const Stream: ISpeechBaseStream; Flags: SpeechVoiceSpeakFlags): Integer;
    procedure Pause;
    procedure Resume;
    function Skip(const type_: WideString; NumItems: Integer): Integer;
    function GetVoices(const RequiredAttributes: WideString; const OptionalAttributes: WideString): ISpeechObjectTokens;
    function GetAudioOutputs(const RequiredAttributes: WideString; const OptionalAttributes: WideString): ISpeechObjectTokens;
    function WaitUntilDone(msTimeout: Integer): WordBool;
    function SpeakCompleteEvent: Integer;
    function IsUISupported(const TypeOfUI: WideString): WordBool; overload;
    function IsUISupported(const TypeOfUI: WideString; const ExtraData: OleVariant): WordBool; overload;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString; const TypeOfUI: WideString); overload;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString; const TypeOfUI: WideString; const ExtraData: OleVariant); overload;
    property DefaultInterface: ISpeechVoice read GetDefaultInterface;
    property Status: ISpeechVoiceStatus read Get_Status;
    property Voice: ISpeechObjectToken read Get_Voice write _Set_Voice;
    property AudioOutput: ISpeechObjectToken read Get_AudioOutput write _Set_AudioOutput;
    property AudioOutputStream: ISpeechBaseStream read Get_AudioOutputStream  write _Set_AudioOutputStream;
    property AllowAudioOutputFormatChangesOnNextSet: WordBool read Get_AllowAudioOutputFormatChangesOnNextSet write Set_AllowAudioOutputFormatChangesOnNextSet;
    property Rate: Integer read Get_Rate write Set_Rate; property Volume: Integer read Get_Volume write Set_Volume;
    property EventInterests: SpeechVoiceEvents read Get_EventInterests write Set_EventInterests;
    property Priority: SpeechVoicePriority read Get_Priority write Set_Priority;
    property AlertBoundary: SpeechVoiceEvents read Get_AlertBoundary write Set_AlertBoundary;
    property SynchronousSpeakTimeout: Integer read Get_SynchronousSpeakTimeout write Set_SynchronousSpeakTimeout;
  published
    property OnStartStream: TSpVoiceStartStream read FOnStartStream write FOnStartStream;
    property OnEndStream: TSpVoiceEndStream read FOnEndStream write FOnEndStream;
    property OnVoiceChange: TSpVoiceVoiceChange read FOnVoiceChange write FOnVoiceChange;
    property OnBookmark: TSpVoiceBookmark read FOnBookmark write FOnBookmark;
    property OnWord: TSpVoiceWord read FOnWord write FOnWord;
    property OnSentence: TSpVoiceSentence read FOnSentence write FOnSentence;
    property OnPhoneme: TSpVoicePhoneme read FOnPhoneme write FOnPhoneme;
    property OnViseme: TSpVoiceViseme read FOnViseme write FOnViseme;
    property OnAudioLevel: TSpVoiceAudioLevel read FOnAudioLevel write FOnAudioLevel;
    property OnEnginePrivate: TSpVoiceEnginePrivate read FOnEnginePrivate write FOnEnginePrivate;
    end;
{$ENDREGION}

{$REGION '  === PASLIBS ==============================================================='}
{ Database }
type
  TDatabase = type Pointer;
var
  gv_database_create: function: TDatabase;
  gv_database_destroy: procedure(var aDatabase: TDatabase);
  gv_database_setupmysql: procedure(aDatabase: TDatabase; const aServer: WideString; aPort: Integer; const aDatabaseName: WideString; const aUserName: WideString; const aPassword: WideString);
  gv_database_setupsqlite: procedure(aDatabase: TDatabase; const aDatabaseName: WideString; aPassword: WideString);
  gv_database_open: procedure(aDatabase: TDatabase);
  gv_database_close: procedure(aDatabase: TDatabase);
  gv_database_connected: function(aDatabase: TDatabase): Boolean;
  gv_database_execsql: function(aDatabase: TDatabase; const aSQL: WideString; const aParams: array of const): LongInt;
  gv_database_execsql_scalar: function(aDatabase: TDatabase; const aSQL: WideString; const aParams: array of const): WideString;
  gv_database_query: function(aDatabase: TDatabase; const aSQL: WideString; const aParams: array of const): LongInt;
  gv_database_query_field_count: function(aDatabase: TDatabase): Integer;
  gv_databaes_query_record_count: function(aDatabase: TDatabase): Integer;
  gv_database_query_bof: function(aDatabase: TDatabase): Boolean;
  gv_database_query_eof: function(aDatabase: TDatabase): Boolean;
  gv_database_query_next: procedure(aDatabase: TDatabase);
  gv_database_query_prev: procedure(aDatabase: TDatabase);
  gv_database_query_last: procedure(aDatabase: TDatabase);
  gv_database_query_first: procedure(aDatabase: TDatabase);
  gv_database_query_field: function(aDatabase: TDatabase; const aName: WideString): WideString;
  gv_database_last_error: function(aDatabase: TDatabase): WideString;
{$ENDREGION}

{$REGION '  === GAMEVISION ============================================================'}
{ --- COMMON ---------------------------------------------------------------- }
const
  // GameVision Constants
  GAMEVISION_VERSION_MAJOR = '0';
  GAMEVISION_VERSION_MINOR = '1';
  GAMEVISION_VERSION_PATCH = '0';
  GAMEVISION_VERSION       = GAMEVISION_VERSION_MAJOR + '.' +
                             GAMEVISION_VERSION_MINOR + '.' +
                             GAMEVISION_VERSION_PATCH;

  // File Extentions Constatns
  GV_FILEEXT_LOG = 'log';
  GV_FILEEXT_INI = 'ini';
  GV_FILEEXT_PNG = 'png';

  // Common Character
  GV_CR = #13;  // carrage return
  GV_LF = #10;  // line feed

  // Display Constants
  GV_DISPLAY_DEFAULT_DPI = 96;

  // ID Constants
  GV_ID_NIL = -1;

  // Degree/Radian conversion
  GV_RAD2DEG = 180.0 / PI;
  GV_DEG2RAD = PI / 180.0;

  { Misc }
  GV_EPSILON = 0.00001;

type

  { TGVPrintEvent }
  TGVPrintEvent = procedure(const aMsg: string; const aArgs: array of const) of object;

  { TGVSeek }
  TGVSeek = (AtStart, AtCurrent, AtEnd);

  { TGVHAlign }
  TGVHAlign = (Left, Center, Right);

  { TGVVAlign }
  TGVVAlign = (Top, Center, Bottom);

{ --- VECTOR ---------------------------------------------------------------- }
type
  { TGVVector }
  TGVVector = record
    X,Y,Z, W: Single;
    constructor Create(aX, aY: Single); overload;
    constructor Create(aX, aY, aZ: Single); overload;
    constructor Create(aX, aY, aZ, aW: Single); overload;
    procedure Assign(aX, aY: Single); overload;
    procedure Assign(aX, aY, aZ: Single); overload;
    procedure Assign(aX, aY, aZ, aW: Single); overload;
    procedure Assign(aVector: TGVVector); overload;
    procedure Clear;
    procedure Add(aVector: TGVVector); inline;
    procedure Subtract(aVector: TGVVector);
    procedure Multiply(aVector: TGVVector);
    procedure Divide(aVector: TGVVector);
    function  Magnitude: Single;
    function  MagnitudeTruncate(aMaxMagitude: Single): TGVVector;
    function  Distance(aVector: TGVVector): Single;
    procedure Normalize;
    function  Angle(aVector: TGVVector): Single;
    procedure Thrust(aAngle: Single; aSpeed: Single);
    function  MagnitudeSquared: Single;
    function  DotProduct(aVector: TGVVector): Single;
    procedure Scale(aValue: Single);
    procedure DivideBy(aValue: Single);
    function  Project(aVector: TGVVector): TGVVector;
    procedure Negate;
  end;

  { PGVVector }
  PGVVector = ^TGVVector;

{ --- RECTANGLE ------------------------------------------------------------- }
  { TGVRectangle }
  TGVRectangle = record
    X, Y, Width, Height: Single;
    constructor Create(aX, aY, aWidth, aHeight: Single);
    procedure Assign(aX, aY, aWidth, aHeight: Single); overload;
    procedure Assign(aRectangle: TGVRectangle); overload;
    procedure Clear;
    function Intersect(aRect: TGVRectangle): Boolean;
  end;

  { PGVRectangle }
  PGVRectangle = ^TGVRectangle;

{ --- COLOR -----------------------------------------------------------------
type
  { TGVColor }
  TGVColor = record
    Red,Green,Blue,Alpha: Single;
    function Make(aRed: Byte; aGreen: Byte; aBlue: Byte; aAlpha: Byte): TGVColor; overload;
    function Make(aRed: Single; aGreen: Single; aBlue: Single; aAlpha: Single): TGVColor; overload;
    function Make(const aName: string): TGVColor; overload;
    function Fade(aTo: TGVColor; aPos: Single): TGVColor;
    function Equal(aColor: TGVColor): Boolean;
  end;

  { PGVColor }
  PGVColor = ^TGVColor;

{$REGION 'Common Colors'}
const
  ALICEBLUE           : TGVColor = (Red:$F0/$FF; Green:$F8/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  ANTIQUEWHITE        : TGVColor = (Red:$FA/$FF; Green:$EB/$FF; Blue:$D7/$FF; Alpha:$FF/$FF);
  AQUA                : TGVColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  AQUAMARINE          : TGVColor = (Red:$7F/$FF; Green:$FF/$FF; Blue:$D4/$FF; Alpha:$FF/$FF);
  AZURE               : TGVColor = (Red:$F0/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  BEIGE               : TGVColor = (Red:$F5/$FF; Green:$F5/$FF; Blue:$DC/$FF; Alpha:$FF/$FF);
  BISQUE              : TGVColor = (Red:$FF/$FF; Green:$E4/$FF; Blue:$C4/$FF; Alpha:$FF/$FF);
  BLACK               : TGVColor = (Red:$00/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  BLANCHEDALMOND      : TGVColor = (Red:$FF/$FF; Green:$EB/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  BLUE                : TGVColor = (Red:$00/$FF; Green:$00/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  BLUEVIOLET          : TGVColor = (Red:$8A/$FF; Green:$2B/$FF; Blue:$E2/$FF; Alpha:$FF/$FF);
  BROWN               : TGVColor = (Red:$A5/$FF; Green:$2A/$FF; Blue:$2A/$FF; Alpha:$FF/$FF);
  BURLYWOOD           : TGVColor = (Red:$DE/$FF; Green:$B8/$FF; Blue:$87/$FF; Alpha:$FF/$FF);
  CADETBLUE           : TGVColor = (Red:$5F/$FF; Green:$9E/$FF; Blue:$A0/$FF; Alpha:$FF/$FF);
  CHARTREUSE          : TGVColor = (Red:$7F/$FF; Green:$FF/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  CHOCOLATE           : TGVColor = (Red:$D2/$FF; Green:$69/$FF; Blue:$1E/$FF; Alpha:$FF/$FF);
  CORAL               : TGVColor = (Red:$FF/$FF; Green:$7F/$FF; Blue:$50/$FF; Alpha:$FF/$FF);
  CORNFLOWERBLUE      : TGVColor = (Red:$64/$FF; Green:$95/$FF; Blue:$ED/$FF; Alpha:$FF/$FF);
  CORNSILK            : TGVColor = (Red:$FF/$FF; Green:$F8/$FF; Blue:$DC/$FF; Alpha:$FF/$FF);
  CRIMSON             : TGVColor = (Red:$DC/$FF; Green:$14/$FF; Blue:$3C/$FF; Alpha:$FF/$FF);
  CYAN                : TGVColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  DARKBLUE            : TGVColor = (Red:$00/$FF; Green:$00/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKCYAN            : TGVColor = (Red:$00/$FF; Green:$8B/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKGOLDENROD       : TGVColor = (Red:$B8/$FF; Green:$86/$FF; Blue:$0B/$FF; Alpha:$FF/$FF);
  DARKGRAY            : TGVColor = (Red:$A9/$FF; Green:$A9/$FF; Blue:$A9/$FF; Alpha:$FF/$FF);
  DARKGREEN           : TGVColor = (Red:$00/$FF; Green:$64/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  DARKGREY            : TGVColor = (Red:$A9/$FF; Green:$A9/$FF; Blue:$A9/$FF; Alpha:$FF/$FF);
  DARKKHAKI           : TGVColor = (Red:$BD/$FF; Green:$B7/$FF; Blue:$6B/$FF; Alpha:$FF/$FF);
  DARKMAGENTA         : TGVColor = (Red:$8B/$FF; Green:$00/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKOLIVEGREEN      : TGVColor = (Red:$55/$FF; Green:$6B/$FF; Blue:$2F/$FF; Alpha:$FF/$FF);
  DARKORANGE          : TGVColor = (Red:$FF/$FF; Green:$8C/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  DARKORCHID          : TGVColor = (Red:$99/$FF; Green:$32/$FF; Blue:$CC/$FF; Alpha:$FF/$FF);
  DARKRED             : TGVColor = (Red:$8B/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  DARKSALMON          : TGVColor = (Red:$E9/$FF; Green:$96/$FF; Blue:$7A/$FF; Alpha:$FF/$FF);
  DARKSEAGREEN        : TGVColor = (Red:$8F/$FF; Green:$BC/$FF; Blue:$8F/$FF; Alpha:$FF/$FF);
  DARKSLATEBLUE       : TGVColor = (Red:$48/$FF; Green:$3D/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKSLATEGRAY       : TGVColor = (Red:$2F/$FF; Green:$4F/$FF; Blue:$4F/$FF; Alpha:$FF/$FF);
  DARKSLATEGREY       : TGVColor = (Red:$2F/$FF; Green:$4F/$FF; Blue:$4F/$FF; Alpha:$FF/$FF);
  DARKTURQUOISE       : TGVColor = (Red:$00/$FF; Green:$CE/$FF; Blue:$D1/$FF; Alpha:$FF/$FF);
  DARKVIOLET          : TGVColor = (Red:$94/$FF; Green:$00/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  DEEPPINK            : TGVColor = (Red:$FF/$FF; Green:$14/$FF; Blue:$93/$FF; Alpha:$FF/$FF);
  DEEPSKYBLUE         : TGVColor = (Red:$00/$FF; Green:$BF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  DIMGRAY             : TGVColor = (Red:$69/$FF; Green:$69/$FF; Blue:$69/$FF; Alpha:$FF/$FF);
  DIMGREY             : TGVColor = (Red:$69/$FF; Green:$69/$FF; Blue:$69/$FF; Alpha:$FF/$FF);
  DODGERBLUE          : TGVColor = (Red:$1E/$FF; Green:$90/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  FIREBRICK           : TGVColor = (Red:$B2/$FF; Green:$22/$FF; Blue:$22/$FF; Alpha:$FF/$FF);
  FLORALWHITE         : TGVColor = (Red:$FF/$FF; Green:$FA/$FF; Blue:$F0/$FF; Alpha:$FF/$FF);
  FORESTGREEN         : TGVColor = (Red:$22/$FF; Green:$8B/$FF; Blue:$22/$FF; Alpha:$FF/$FF);
  FUCHSIA             : TGVColor = (Red:$FF/$FF; Green:$00/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  GAINSBORO           : TGVColor = (Red:$DC/$FF; Green:$DC/$FF; Blue:$DC/$FF; Alpha:$FF/$FF);
  GHOSTWHITE          : TGVColor = (Red:$F8/$FF; Green:$F8/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  GOLD                : TGVColor = (Red:$FF/$FF; Green:$D7/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  GOLDENROD           : TGVColor = (Red:$DA/$FF; Green:$A5/$FF; Blue:$20/$FF; Alpha:$FF/$FF);
  GRAY                : TGVColor = (Red:$80/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  GREEN               : TGVColor = (Red:$00/$FF; Green:$80/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  GREENYELLOW         : TGVColor = (Red:$AD/$FF; Green:$FF/$FF; Blue:$2F/$FF; Alpha:$FF/$FF);
  GREY                : TGVColor = (Red:$80/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  HONEYDEW            : TGVColor = (Red:$F0/$FF; Green:$FF/$FF; Blue:$F0/$FF; Alpha:$FF/$FF);
  HOTPINK             : TGVColor = (Red:$FF/$FF; Green:$69/$FF; Blue:$B4/$FF; Alpha:$FF/$FF);
  INDIANRED           : TGVColor = (Red:$CD/$FF; Green:$5C/$FF; Blue:$5C/$FF; Alpha:$FF/$FF);
  INDIGO              : TGVColor = (Red:$4B/$FF; Green:$00/$FF; Blue:$82/$FF; Alpha:$FF/$FF);
  IVORY               : TGVColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$F0/$FF; Alpha:$FF/$FF);
  KHAKI               : TGVColor = (Red:$F0/$FF; Green:$E6/$FF; Blue:$8C/$FF; Alpha:$FF/$FF);
  LAVENDER            : TGVColor = (Red:$E6/$FF; Green:$E6/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  LAVENDERBLUSH       : TGVColor = (Red:$FF/$FF; Green:$F0/$FF; Blue:$F5/$FF; Alpha:$FF/$FF);
  LAWNGREEN           : TGVColor = (Red:$7C/$FF; Green:$FC/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  LEMONCHIFFON        : TGVColor = (Red:$FF/$FF; Green:$FA/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  LIGHTBLUE           : TGVColor = (Red:$AD/$FF; Green:$D8/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  LIGHTCORAL          : TGVColor = (Red:$F0/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  LIGHTCYAN           : TGVColor = (Red:$E0/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  LIGHTGOLDENRODYELLOW: TGVColor = (Red:$FA/$FF; Green:$FA/$FF; Blue:$D2/$FF; Alpha:$FF/$FF);
  LIGHTGRAY           : TGVColor = (Red:$D3/$FF; Green:$D3/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  LIGHTGREEN          : TGVColor = (Red:$90/$FF; Green:$EE/$FF; Blue:$90/$FF; Alpha:$FF/$FF);
  LIGHTGREY           : TGVColor = (Red:$D3/$FF; Green:$D3/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  LIGHTPINK           : TGVColor = (Red:$FF/$FF; Green:$B6/$FF; Blue:$C1/$FF; Alpha:$FF/$FF);
  LIGHTSALMON         : TGVColor = (Red:$FF/$FF; Green:$A0/$FF; Blue:$7A/$FF; Alpha:$FF/$FF);
  LIGHTSEAGREEN       : TGVColor = (Red:$20/$FF; Green:$B2/$FF; Blue:$AA/$FF; Alpha:$FF/$FF);
  LIGHTSKYBLUE        : TGVColor = (Red:$87/$FF; Green:$CE/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  LIGHTSLATEGRAY      : TGVColor = (Red:$77/$FF; Green:$88/$FF; Blue:$99/$FF; Alpha:$FF/$FF);
  LIGHTSLATEGREY      : TGVColor = (Red:$77/$FF; Green:$88/$FF; Blue:$99/$FF; Alpha:$FF/$FF);
  LIGHTSTEELBLUE      : TGVColor = (Red:$B0/$FF; Green:$C4/$FF; Blue:$DE/$FF; Alpha:$FF/$FF);
  LIGHTYELLOW         : TGVColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$E0/$FF; Alpha:$FF/$FF);
  LIME                : TGVColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  LIMEGREEN           : TGVColor = (Red:$32/$FF; Green:$CD/$FF; Blue:$32/$FF; Alpha:$FF/$FF);
  LINEN               : TGVColor = (Red:$FA/$FF; Green:$F0/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  MAGENTA             : TGVColor = (Red:$FF/$FF; Green:$00/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  MAROON              : TGVColor = (Red:$80/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  MEDIUMAQUAMARINE    : TGVColor = (Red:$66/$FF; Green:$CD/$FF; Blue:$AA/$FF; Alpha:$FF/$FF);
  MEDIUMBLUE          : TGVColor = (Red:$00/$FF; Green:$00/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  MEDIUMORCHID        : TGVColor = (Red:$BA/$FF; Green:$55/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  MEDIUMPURPLE        : TGVColor = (Red:$93/$FF; Green:$70/$FF; Blue:$DB/$FF; Alpha:$FF/$FF);
  MEDIUMSEAGREEN      : TGVColor = (Red:$3C/$FF; Green:$B3/$FF; Blue:$71/$FF; Alpha:$FF/$FF);
  MEDIUMSLATEBLUE     : TGVColor = (Red:$7B/$FF; Green:$68/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  MEDIUMSPRINGGREEN   : TGVColor = (Red:$00/$FF; Green:$FA/$FF; Blue:$9A/$FF; Alpha:$FF/$FF);
  MEDIUMTURQUOISE     : TGVColor = (Red:$48/$FF; Green:$D1/$FF; Blue:$CC/$FF; Alpha:$FF/$FF);
  MEDIUMVIOLETRED     : TGVColor = (Red:$C7/$FF; Green:$15/$FF; Blue:$85/$FF; Alpha:$FF/$FF);
  MIDNIGHTBLUE        : TGVColor = (Red:$19/$FF; Green:$19/$FF; Blue:$70/$FF; Alpha:$FF/$FF);
  MINTCREAM           : TGVColor = (Red:$F5/$FF; Green:$FF/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  MISTYROSE           : TGVColor = (Red:$FF/$FF; Green:$E4/$FF; Blue:$E1/$FF; Alpha:$FF/$FF);
  MOCCASIN            : TGVColor = (Red:$FF/$FF; Green:$E4/$FF; Blue:$B5/$FF; Alpha:$FF/$FF);
  NAVAJOWHITE         : TGVColor = (Red:$FF/$FF; Green:$DE/$FF; Blue:$AD/$FF; Alpha:$FF/$FF);
  NAVY                : TGVColor = (Red:$00/$FF; Green:$00/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  OLDLACE             : TGVColor = (Red:$FD/$FF; Green:$F5/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  OLIVE               : TGVColor = (Red:$80/$FF; Green:$80/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  OLIVEDRAB           : TGVColor = (Red:$6B/$FF; Green:$8E/$FF; Blue:$23/$FF; Alpha:$FF/$FF);
  ORANGE              : TGVColor = (Red:$FF/$FF; Green:$A5/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  ORANGERED           : TGVColor = (Red:$FF/$FF; Green:$45/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  ORCHID              : TGVColor = (Red:$DA/$FF; Green:$70/$FF; Blue:$D6/$FF; Alpha:$FF/$FF);
  PALEGOLDENROD       : TGVColor = (Red:$EE/$FF; Green:$E8/$FF; Blue:$AA/$FF; Alpha:$FF/$FF);
  PALEGREEN           : TGVColor = (Red:$98/$FF; Green:$FB/$FF; Blue:$98/$FF; Alpha:$FF/$FF);
  PALETURQUOISE       : TGVColor = (Red:$AF/$FF; Green:$EE/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  PALEVIOLETRED       : TGVColor = (Red:$DB/$FF; Green:$70/$FF; Blue:$93/$FF; Alpha:$FF/$FF);
  PAPAYAWHIP          : TGVColor = (Red:$FF/$FF; Green:$EF/$FF; Blue:$D5/$FF; Alpha:$FF/$FF);
  PEACHPUFF           : TGVColor = (Red:$FF/$FF; Green:$DA/$FF; Blue:$B9/$FF; Alpha:$FF/$FF);
  PERU                : TGVColor = (Red:$CD/$FF; Green:$85/$FF; Blue:$3F/$FF; Alpha:$FF/$FF);
  PINK                : TGVColor = (Red:$FF/$FF; Green:$C0/$FF; Blue:$CB/$FF; Alpha:$FF/$FF);
  PLUM                : TGVColor = (Red:$DD/$FF; Green:$A0/$FF; Blue:$DD/$FF; Alpha:$FF/$FF);
  POWDERBLUE          : TGVColor = (Red:$B0/$FF; Green:$E0/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  PURPLE              : TGVColor = (Red:$80/$FF; Green:$00/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  REBECCAPURPLE       : TGVColor = (Red:$66/$FF; Green:$33/$FF; Blue:$99/$FF; Alpha:$FF/$FF);
  RED                 : TGVColor = (Red:$FF/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  ROSYBROWN           : TGVColor = (Red:$BC/$FF; Green:$8F/$FF; Blue:$8F/$FF; Alpha:$FF/$FF);
  ROYALBLUE           : TGVColor = (Red:$41/$FF; Green:$69/$FF; Blue:$E1/$FF; Alpha:$FF/$FF);
  SADDLEBROWN         : TGVColor = (Red:$8B/$FF; Green:$45/$FF; Blue:$13/$FF; Alpha:$FF/$FF);
  SALMON              : TGVColor = (Red:$FA/$FF; Green:$80/$FF; Blue:$72/$FF; Alpha:$FF/$FF);
  SANDYBROWN          : TGVColor = (Red:$F4/$FF; Green:$A4/$FF; Blue:$60/$FF; Alpha:$FF/$FF);
  SEAGREEN            : TGVColor = (Red:$2E/$FF; Green:$8B/$FF; Blue:$57/$FF; Alpha:$FF/$FF);
  SEASHELL            : TGVColor = (Red:$FF/$FF; Green:$F5/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  SIENNA              : TGVColor = (Red:$A0/$FF; Green:$52/$FF; Blue:$2D/$FF; Alpha:$FF/$FF);
  SILVER              : TGVColor = (Red:$C0/$FF; Green:$C0/$FF; Blue:$C0/$FF; Alpha:$FF/$FF);
  SKYBLUE             : TGVColor = (Red:$87/$FF; Green:$CE/$FF; Blue:$EB/$FF; Alpha:$FF/$FF);
  SLATEBLUE           : TGVColor = (Red:$6A/$FF; Green:$5A/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  SLATEGRAY           : TGVColor = (Red:$70/$FF; Green:$80/$FF; Blue:$90/$FF; Alpha:$FF/$FF);
  SLATEGREY           : TGVColor = (Red:$70/$FF; Green:$80/$FF; Blue:$90/$FF; Alpha:$FF/$FF);
  SNOW                : TGVColor = (Red:$FF/$FF; Green:$FA/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  SPRINGGREEN         : TGVColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$7F/$FF; Alpha:$FF/$FF);
  STEELBLUE           : TGVColor = (Red:$46/$FF; Green:$82/$FF; Blue:$B4/$FF; Alpha:$FF/$FF);
  TAN                 : TGVColor = (Red:$D2/$FF; Green:$B4/$FF; Blue:$8C/$FF; Alpha:$FF/$FF);
  TEAL                : TGVColor = (Red:$00/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  THISTLE             : TGVColor = (Red:$D8/$FF; Green:$BF/$FF; Blue:$D8/$FF; Alpha:$FF/$FF);
  TOMATO              : TGVColor = (Red:$FF/$FF; Green:$63/$FF; Blue:$47/$FF; Alpha:$FF/$FF);
  TURQUOISE           : TGVColor = (Red:$40/$FF; Green:$E0/$FF; Blue:$D0/$FF; Alpha:$FF/$FF);
  VIOLET              : TGVColor = (Red:$EE/$FF; Green:$82/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  WHEAT               : TGVColor = (Red:$F5/$FF; Green:$DE/$FF; Blue:$B3/$FF; Alpha:$FF/$FF);
  WHITE               : TGVColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  WHITESMOKE          : TGVColor = (Red:$F5/$FF; Green:$F5/$FF; Blue:$F5/$FF; Alpha:$FF/$FF);
  YELLOW              : TGVColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  YELLOWGREEN         : TGVColor = (Red:$9A/$FF; Green:$CD/$FF; Blue:$32/$FF; Alpha:$FF/$FF);
  BLANK               : TGVColor = (Red:$00;     Green:$00;     Blue:$00;     Alpha:$00);
  WHITE2              : TGVColor = (Red:$F5/$FF; Green:$F5/$FF; Blue:$F5/$FF; Alpha:$FF/$FF);
  RED22               : TGVColor = (Red:$7E/$FF; Green:$32/$FF; Blue:$3F/$FF; Alpha:255/$FF);
  COLORKEY            : TGVColor = (Red:$FF/$FF; Green:$00;     Blue:$FF/$FF; Alpha:$FF/$FF);
  OVERLAY1            : TGVColor = (Red:$00/$FF; Green:$20/$FF; Blue:$29/$FF; Alpha:$B4/$FF);
  OVERLAY2            : TGVColor = (Red:$01/$FF; Green:$1B/$FF; Blue:$01/$FF; Alpha:255/$FF);
  DIMWHITE            : TGVColor = (Red:$10/$FF; Green:$10/$FF; Blue:$10/$FF; Alpha:$10/$FF);
  DARKSLATEBROWN      : TGVColor = (Red:30/255; Green:31/255; Blue:30/255; Alpha:1);
{$ENDREGION}

{ --- OBJECT ---------------------------------------------------------------- }
type
  { TGVObjectAttributeSet }
  TGVObjectAttributeSet = set of Byte;

  { TGVObjectList }
  TGVObjectList = class;

  { TGVObject }
  TGVObject = class
  protected
    FOwner: TGVObjectList;
    FPrev: TGVObject;
    FNext: TGVObject;
    FAttributes: TGVObjectAttributeSet;
    function GetAttribute(aIndex: Byte): Boolean;
    procedure SetAttribute(aIndex: Byte; aValue: Boolean);
    function GetAttributes: TGVObjectAttributeSet;
    procedure SetAttributes(aValue: TGVObjectAttributeSet);
  public
    property Owner: TGVObjectList read FOwner write FOwner;
    property Prev: TGVObject read FPrev write FPrev;
    property Next: TGVObject read FNext write FNext;
    property Attribute[aIndex: Byte]: Boolean read GetAttribute write SetAttribute;
    property Attributes: TGVObjectAttributeSet read GetAttributes  write SetAttributes;
    constructor Create; virtual;
    destructor Destroy; override;
    function AttributesAreSet(aAttrs: TGVObjectAttributeSet): Boolean;
  end;

{ --- OBJECTLIST ------------------------------------------------------------ }

  { TGVObjectList }
  TGVObjectList = class
  protected
    FHead: TGVObject;
    FTail: TGVObject;
    FCount: Integer;
  public
    property Count: Integer read FCount;
    constructor Create; virtual;
    destructor Destroy; override;
    procedure Add(aObject: TGVObject);
    procedure Remove(aObject: TGVObject; aDispose: Boolean);
    procedure Clean; virtual;
    procedure Clear(aAttrs: TGVObjectAttributeSet);
  end;

{  BUFFER ------------------------------------------------------------------- }
const
  // Buffer Constants
  GV_BUFFER_COPYCACHESIZE = $100000;

type
  { TGVBuffer }
  TGVBuffer = class(TGVObject)
  protected
    FHandle: THandle;
    FMemory: Pointer;
    FSize: UInt64;
    FPosition: UInt64;
    function GetPosition: UInt64;
    procedure SetPosition(aPosition: UInt64);
  public
    property Position: UInt64 read GetPosition write SetPosition;
    property Memory: Pointer read FMemory;
    property Size: UInt64 read FSize;
    constructor Create; override;
    destructor Destroy; override;
    function Allocate(aSize: UInt64): Boolean;
    procedure Release;
    function Read(const aBuffer: Pointer; aCount: UInt64): UInt64;
    function Write(aBuffer: Pointer; aCount: UInt64): UInt64;
    function LoadFromFile(const aFilename: string): Boolean;
    function SaveToFile(const aFilename: string): Boolean;
    function LoadFromStream(const aStream: TStream): UInt64;
    function SaveToStream(const aStream: TStream): UInt64;
    function Eof: Boolean;
  end;

{ --- UTILS -----------------------------------------------------------------}
type
  { TGVUtil }
  TGVUtil = class(TGVObject)
  public
    constructor Create; override;
    destructor Destroy; override;
    function  GetLastOSError: string;
    function  RemoveQuotes(const aText: string): string;
    procedure GotoURL(const aURL: string);
    procedure ShellRun(const aFilename: string; const aParams: string; const aDir: string; aHide: Boolean);
    function  CreateDirsInPath(const aPath: string): Boolean;
    procedure DeferDelFile(const aFilename: string);
    procedure LoadDefaultIcon(aWnd: HWND);
    function  ResourceExists(aInstance: THandle; const aResName: string): Boolean;
    function  LoadResourceToBuffer(aInstance: THandle; const aResName: string): TGVBuffer;
    procedure LoadStringListFromResource(const aResName: string; aList: TStringList);
    function  LoadStringFromResource(const aResName: string): string;
    procedure ClearKeyboardBuffer;
    procedure ClearMouseClickBuffer;
    procedure CryptBuffer(const aBuffer: PByte; aLength: Cardinal; const aPassword: string; aToCrypt: Boolean);
    function  GetPackedVersion(aVersion: UInt32): string;
    procedure ProcessMessages;
    function  MicrosecondsToSeconds(aTime: Double): Double;
    function  MillisecondsToSeconds(aTime: Double): Double;
    function  BeatsPerSecondToSeconds(aTime: Double): Double;
    function  BeatsPerMinutoToSeconds(aTime: Double): Double;
    procedure WriteStringToStream(const aStream: TStream; const aStr: string);
    function  ReadStringFromStream(const aStream: TStream): string;
    function  ReadStringFromBuffer(const aBuffer: TGVBuffer): string;
    function  FileCount(const aPath: string; const aSearchMask: string): Int64;
    function  FindLastWrittenFile(const aDir: string; const aSearch: string): string;
    class function  IsSingleInstance(aMutexName: string; aKeepMutex: Boolean=True): Boolean;


  end;

{ --- CONSOLE --------------------------------------------------------------- }
type
  { TGVConsole }
  TGVConsole = class(TGVObject)
  public
    constructor Create; override;
    destructor Destroy; override;
    class function  IsPresent: Boolean;
    class function  AtStartup: Boolean;
    procedure Print(const aMsg: string; const aArgs: array of const);
    procedure PrintLn; overload;
    procedure PrintLn(const aMsg: string; const aArgs: array of const); overload;
    procedure WaitForInput;
    procedure Pause;
  end;

{ --- LOGGER ---------------------------------------------------------------- }
  { TGVLogger }
  TGVLogger = class(TGVObject)
  protected
    FFormatSettings : TFormatSettings;
    FFilename: string;
    FText: Text;
    FBuffer: array[Word] of Byte;
    FOpen: Boolean;
  public
    property Filename: string read FFilename;
    constructor Create; override;
    destructor Destroy; override;
    procedure Open(const aFilename: string=''; aOverwrite: Boolean=True);
    procedure Close;
    procedure Log(const aMsg: string; const aArgs: array of const; aWriteToConsole: Boolean=False);
    procedure Exception(const aMsg: string; const aArgs: array of const; aWriteToConsole: Boolean=False);
    class procedure Fatal(const aMsg: string; const aArgs: array of const; aWriteToConsole: Boolean=False);
  end;

{ --- CMDLINE --------------------------------------------------------------- }
type
  { TGVCmdLine }
  TGVCmdLine = class(TGVObject)
  protected
    FCmdLine: string;
    function GetCmdLine: PChar;
    function GetParamStr(aParamStr: PChar; var aParam: string): PChar;
  public
    constructor Create; override;
    destructor Destroy; override;
    function ParamCount: Integer;
    procedure Reset;
    procedure ClearParams;
    procedure AddAParam(const aParam: string);
    procedure AddParams(const aParams: string);
    function ParamStr(aIndex: Integer): string;
    function GetParamValue(const aParamName: string; aSwitchChars: TSysCharSet; aSeperator: Char; var aValue: string): Boolean; overload;
    function GetParamValue(const aParamName: string; var aValue: string): Boolean; overload;
    function ParamExist(const aParamName: string): Boolean;
  end;

{ --- USERPATH -------------------------------------------------------------- }
type
  { TGVUserPath }
  TGVUserPath = class(TGVObject)
  protected
    FOrgName: string;
    FAppId: string;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Reset;
    procedure SetOrgName(const aName: string);
    function  GetOrgName: string;
    procedure SetAppId(const aId: string);
    function  GetAppId: string;
    function  GetAppIdPath: string;
    function  GetPath: string; overload;
    function  GetPath(const aPath: string): string; overload;
    function  CreateDirs: Boolean;
    function  GetConfigFilename: string;
    function  GetLogFilename: string;
  end;

{ --- MATH ------------------------------------------------------------------- }
type
  { TGVMath }
  TGVMath = class(TGVObject)
  protected
    FCosTable: array [0 .. 360] of Single;
    FSinTable: array [0 .. 360] of Single;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Randomize;
    function  RandomRange(aMin, aMax: Integer): Integer; overload;
    function  RandomRange(aMin, aMax: Single): Single; overload;
    function  RandomBool: Boolean;
    function  GetRandomSeed: Integer;
    procedure SetRandomSeed(aValue: Integer);
    function  AngleCos(aAngle: Integer): Single;
    function  AngleSin(aAngle: Integer): Single;
    function  AngleDifference(aSrcAngle: Single; aDestAngle: Single): Single;
    procedure AngleRotatePos(aAngle: Single; var aX: Single; var aY: Single);
    function  ClipValue(var aValue: Single; aMin: Single; aMax: Single; aWrap: Boolean): Single; overload;
    function  ClipValue(var aValue: Integer; aMin: Integer; aMax: Integer; aWrap: Boolean): Integer; overload;
    function  SameSign(aValue1: Integer; aValue2: Integer): Boolean; overload;
    function  SameSign(aValue1: Single; aValue2: Single): Boolean; overload;
    function  SameValue(aA: Double; aB: Double; aEpsilon: Double = 0): Boolean; overload;
    function  SameValue(aA: Single; aB: Single; aEpsilon: Single = 0): Boolean; overload;
    function  Vector(aX: Single; aY: Single): TGVVector;
    function  Rectangle(aX: Single; aY: Single; aWidth: Single; aHeight: Single): TGVRectangle;
    procedure SmoothMove(var aValue: Single; aAmount: Single; aMax: Single; aDrag: Single);
    function  Lerp(aFrom: Double; aTo: Double; aTime: Double): Double;
  end;

{ --- COLLISION ------------------------------------------------------------- }
type

  { TGVLineIntersection }
  TGVLineIntersection = (None, Cross, Parallel);

  { TGVCollision }
  TGVCollision = class(TGVObject)
  public
    constructor Create; override;
    destructor Destroy; override;
    function PointInRectangle(aPoint: TGVVector; aRect: TGVRectangle): Boolean;
    function PointInCircle(aPoint, aCenter: TGVVector; aRadius: Single): Boolean;
    function PointInTriangle(aPoint, aP1, aP2, aP3: TGVVector): Boolean;
    function CirclesOverlap(aCenter1: TGVVector; aRadius1: Single; aCenter2: TGVVector; aRadius2: Single): Boolean;
    function CircleInRectangle(aCenter: TGVVector; aRadius: Single; aRect: TGVRectangle): Boolean;
    function RectanglesOverlap(aRect1: TGVRectangle; aRect2: TGVRectangle): Boolean;
    function RectangleIntersection(aRect1, aRect2: TGVRectangle): TGVRectangle;
    function LineIntersection(aX1, aY1, aX2, aY2, aX3, aY3, aX4, aY4: Integer; var aX: Integer; var aY: Integer): TGVLineIntersection;
    function RadiusOverlap(aRadius1, aX1, aY1, aRadius2, aX2, aY2, aShrinkFactor: Single): Boolean;
  end;

{  ARCHIVE ------------------------------------------------------------------ }
type
  { TGVArchiveBuildProgressEvent }
  TGVArchiveBuildProgressEvent = procedure(const aFilename: string; aProgress: Integer; aNewFile: Boolean) of object;

  { TGVArchiveFile}
  TGVArchiveFile = class;

  { TGVArchive }
  TGVArchive = class(TGVObject)
  protected
    FPassword: string;
    FFilename: string;
    FPasswordFilename: string;
    FIsOpen: Boolean;
    function GetCRC32(aStream: TStream): Cardinal;
  public
    property IsOpen: Boolean read FIsOpen;
    constructor Create; override;
    destructor Destroy; override;
    function Open(const aPassword: string; const aFilename: string): Boolean;
    function Close: Boolean;
    function FileExist(const aFilename: string): Boolean;
    function GetPasswordFilename(const aFilename: string): PAnsiChar;
    function OpenFile(const aFilename: string): TGVArchiveFile; overload;
    function ExtractToBuffer(const aFilename: string): TGVBuffer;
    function Build(const aPassword: string; const aFilename: string; const aDirectory: string; aOnProgress: TGVArchiveBuildProgressEvent): Boolean;
  end;

{ --- ARCHIVEFILE ----------------------------------------------------------- }
  { TGVArchiveFile }
  TGVArchiveFile = class(TGVObject)
  protected
    FHandle: PALLEGRO_FILE;
  public
    constructor Create; override;
    destructor Destroy; override;
    function Open(aArchive: TGVArchive; const aFilename: string): Boolean;
    function Close: Boolean;
    function IsOpen: Boolean;
    function Size: UInt64;
    function Eof: Boolean;
    function Seek(aOffset: Int64; aSeek: TGVSeek): UInt64;
    function Tell: UInt64;
    function Read(aBuffer: Pointer; aSize: UInt64): UInt64;
    function LastError: string;
  end;

{ --- TEXTURE --------------------------------------------------------------- }
type
  { TGVBitmapData }
  PGVTextureData = ^TGVTextureData;
  TGVTextureData = record
    Memory: Pointer;
    Format: Integer;
    Pitch: Integer;
    PixelSize: Integer;
  end;

  { TGVBitmap }
  TGVTexture = class(TGVObject)
  protected
    FHandle: PALLEGRO_BITMAP;
    FWidth: Single;
    FHeight: Single;
    FLocked: Boolean;
    FLockedRegion: TGVRectangle;
    FFilename: string;
  public
    property Width: Single read FWidth;
    property Height: Single read FHeight;
    property Filename: string read FFilename;
    property Handle: PALLEGRO_BITMAP read FHandle;
    constructor Create; override;
    destructor Destroy; override;
    function  Allocate(aWidth: Integer; aHeight: Integer): Boolean;
    function  Load(aArchive: TGVArchive; const aFilename: string; aColorKey: PGVColor): Boolean;
    function Unload: Boolean;
    function Lock(aRegion: PGVRectangle; aData: PGVTextureData=nil): Boolean;
    function Unlock: Boolean;
    function  GetPixel(aX: Integer; aY: Integer): TGVColor;
    procedure SetPixel(aX: Integer; aY: Integer; aColor: TGVColor);
    procedure Draw(aX, aY: Single; aRegion: PGVRectangle; aCenter: PGVVector;  aScale: PGVVector; aAngle: Single; aColor: TGVColor; aHFlip: Boolean=False; aVFlip: Boolean=False); overload;
    procedure Draw(aX, aY, aScale, aAngle: Single; aColor: TGVColor; aHAlign: TGVHAlign; aVAlign: TGVVAlign; aHFlip: Boolean=False; aVFlip: Boolean=False); overload;
    procedure DrawTiled(aDeltaX: Single; aDeltaY: Single);
  end;

{ --- RENDERTARGET ---------------------------------------------------------- }
type
  { TGVRenderTarget }
  TGVRenderTarget = class(TGVObject)
  protected
    FTexture: TGVTexture;
    FPosition: TGVVector;
    FRegion: TGVRectangle;
    FActive: Boolean;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Init(aWidth: Integer; aHeight: Integer);
    procedure SetActive(aActive: Boolean);
    function  GetActive: Boolean;
    procedure SetPosition(aX: Single; aY: Single);
    procedure GetPosition(var aPosition: TGVVector);
    procedure GetSize(var aSize: TGVRectangle);
    procedure SetRegion(aX: Single; aY: Single; aWidth: Single; aHeight: Single);
    procedure GetRegion(var aRegion: TGVRectangle);
    procedure Show;
  end;

{ --- WINDOW ---------------------------------------------------------------- }
const
  GV_BLEND_ZERO = 0;
  GV_BLEND_ONE = 1;
  GV_BLEND_ALPHA = 2;
  GV_BLEND_INVERSE_ALPHA = 3;
  GV_BLEND_SRC_COLOR = 4;
  GV_BLEND_DEST_COLOR = 5;
  GV_BLEND_INVERSE_SRC_COLOR = 6;
  GV_BLEND_INVERSE_DEST_COLOR = 7;
  GV_BLEND_CONST_COLOR = 8;
  GV_BLEND_INVERSE_CONST_COLOR = 9;
  GV_BLEND_ADD = 0;
  GV_BLEND_SRC_MINUS_DEST = 1;
  GV_BLEND_DEST_MINUS_SRC = 2;

type
  { TGVBlendMode }
  TGVBlendMode = (PreMultipliedAlpha, NonPreMultipliedAlpha, AdditiveAlpha, CopySrcToDest, MultiplySrcAndDest);

  { TGVBlendModeColor }
  TGVBlendModeColor = (Normal, AvgSrcDest);

  { TGVWindow }
  TGVWindow = class(TGVObject)
  protected
    FHandle: PALLEGRO_DISPLAY;
    FTransform: ALLEGRO_TRANSFORM;
    FWidth: Integer;
    FHeight: Integer;
    FScale: Single;
    FHWnd: HWND;
    FRenderTarget: TGVRenderTarget;
    procedure GetWindowCenterScaledToDPI(aWidth: Integer; aHeight: Integer; var aX: Integer; var aY: Integer);
    procedure ScaleToDPI;
    procedure SetRenderTarget(aRenderTarget: TGVRenderTarget);
  public
    property Width: Integer read FWidth;
    property Height: Integer read FHeight;
    property HWnd: HWND read FHWnd;
    property Scale: Single read FScale;
    property Handle: PALLEGRO_DISPLAY read FHandle;
    constructor Create; override;
    destructor Destroy; override;
    function Open(aWidth: Integer; aHeight: Integer; aTitle: string): Boolean;
    function Close: Boolean;
    procedure Clear(aColor: TGVColor);
    procedure Show;
    procedure SetTitle(aTitle: string);
    function IsOpen: Boolean;
    procedure ResetTransform;
    procedure SetTransformPosition(aX: Single; aY: Single);
    procedure SetTransformAngle(aAngle: Single);
    procedure GetViewportSize(var aSize: TGVRectangle); overload;
    procedure SetBlender(aOperation: Integer; aSource: Integer; aDestination: Integer);
    procedure GetBlender(aOperation: PInteger; aSource: PInteger; aDestination: PInteger);
    procedure SetBlendColor(aColor: TGVColor);
    function  GetBlendColor: TGVColor;
    procedure SetBlendMode(aMode: TGVBlendMode);
    procedure SetBlendModeColor(aMode: TGVBlendModeColor; aColor: TGVColor);
    procedure RestoreDefaultBlendMode;
    procedure Save(const aFilename: string);
  end;

{ --- PRIMITIVES ------------------------------------------------------------ }
type
  { TPrimitive }
  TGVPrimitive = class(TGVObject)
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Line(aX1, aY1, aX2, aY2: Single; aColor: TGVColor; aThickness: Single);
    procedure Rectangle(aX, aY, aWidth, aHeight, aThickness: Single; aColor: TGVColor);
    procedure FilledRectangle(aX, aY, aWidth, aHeight: Single; aColor: TGVColor);
    procedure Circle(aX, aY, aRadius, aThickness: Single; aColor: TGVColor);
    procedure FilledCircle(aX, aY, aRadius: Single; aColor: TGVColor);
    procedure DrawPolygon(aVertices: System.PSingle; aVertexCount: Integer; aThickness: Single; aColor: TGVColor);
    procedure DrawFilledPolygon(aVertices: System.PSingle; aVertexCount: Integer; aColor: TGVColor);
  end;

{ --- INPUT ----------------------------------------------------------------- }
const
  MAX_AXES = 3;
  MAX_STICKS = 16;
  MAX_BUTTONS = 32;

  MOUSE_BUTTON_LEFT = 1;
  MOUSE_BUTTON_RIGHT = 2;
  MOUSE_BUTTON_MIDDLE = 3;

{$REGION 'Keyboard Constants'}
const
  KEY_A = 1;
  KEY_B = 2;
  KEY_C = 3;
  KEY_D = 4;
  KEY_E = 5;
  KEY_F = 6;
  KEY_G = 7;
  KEY_H = 8;
  KEY_I = 9;
  KEY_J = 10;
  KEY_K = 11;
  KEY_L = 12;
  KEY_M = 13;
  KEY_N = 14;
  KEY_O = 15;
  KEY_P = 16;
  KEY_Q = 17;
  KEY_R = 18;
  KEY_S = 19;
  KEY_T = 20;
  KEY_U = 21;
  KEY_V = 22;
  KEY_W = 23;
  KEY_X = 24;
  KEY_Y = 25;
  KEY_Z = 26;
  KEY_0 = 27;
  KEY_1 = 28;
  KEY_2 = 29;
  KEY_3 = 30;
  KEY_4 = 31;
  KEY_5 = 32;
  KEY_6 = 33;
  KEY_7 = 34;
  KEY_8 = 35;
  KEY_9 = 36;
  KEY_PAD_0 = 37;
  KEY_PAD_1 = 38;
  KEY_PAD_2 = 39;
  KEY_PAD_3 = 40;
  KEY_PAD_4 = 41;
  KEY_PAD_5 = 42;
  KEY_PAD_6 = 43;
  KEY_PAD_7 = 44;
  KEY_PAD_8 = 45;
  KEY_PAD_9 = 46;
  KEY_F1 = 47;
  KEY_F2 = 48;
  KEY_F3 = 49;
  KEY_F4 = 50;
  KEY_F5 = 51;
  KEY_F6 = 52;
  KEY_F7 = 53;
  KEY_F8 = 54;
  KEY_F9 = 55;
  KEY_F10 = 56;
  KEY_F11 = 57;
  KEY_F12 = 58;
  KEY_ESCAPE = 59;
  KEY_TILDE = 60;
  KEY_MINUS = 61;
  KEY_EQUALS = 62;
  KEY_BACKSPACE = 63;
  KEY_TAB = 64;
  KEY_OPENBRACE = 65;
  KEY_CLOSEBRACE = 66;
  KEY_ENTER = 67;
  KEY_SEMICOLON = 68;
  KEY_QUOTE = 69;
  KEY_BACKSLASH = 70;
  KEY_BACKSLASH2 = 71;
  KEY_COMMA = 72;
  KEY_FULLSTOP = 73;
  KEY_SLASH = 74;
  KEY_SPACE = 75;
  KEY_INSERT = 76;
  KEY_DELETE = 77;
  KEY_HOME = 78;
  KEY_END = 79;
  KEY_PGUP = 80;
  KEY_PGDN = 81;
  KEY_LEFT = 82;
  KEY_RIGHT = 83;
  KEY_UP = 84;
  KEY_DOWN = 85;
  KEY_PAD_SLASH = 86;
  KEY_PAD_ASTERISK = 87;
  KEY_PAD_MINUS = 88;
  KEY_PAD_PLUS = 89;
  KEY_PAD_DELETE = 90;
  KEY_PAD_ENTER = 91;
  KEY_PRINTSCREEN = 92;
  KEY_PAUSE = 93;
  KEY_ABNT_C1 = 94;
  KEY_YEN = 95;
  KEY_KANA = 96;
  KEY_CONVERT = 97;
  KEY_NOCONVERT = 98;
  KEY_AT = 99;
  KEY_CIRCUMFLEX = 100;
  KEY_COLON2 = 101;
  KEY_KANJI = 102;
  KEY_PAD_EQUALS = 103;
  KEY_BACKQUOTE = 104;
  KEY_SEMICOLON2 = 105;
  KEY_COMMAND = 106;
  KEY_BACK = 107;
  KEY_VOLUME_UP = 108;
  KEY_VOLUME_DOWN = 109;
  KEY_SEARCH = 110;
  KEY_DPAD_CENTER = 111;
  KEY_BUTTON_X = 112;
  KEY_BUTTON_Y = 113;
  KEY_DPAD_UP = 114;
  KEY_DPAD_DOWN = 115;
  KEY_DPAD_LEFT = 116;
  KEY_DPAD_RIGHT = 117;
  KEY_SELECT = 118;
  KEY_START = 119;
  KEY_BUTTON_L1 = 120;
  KEY_BUTTON_R1 = 121;
  KEY_BUTTON_L2 = 122;
  KEY_BUTTON_R2 = 123;
  KEY_BUTTON_A = 124;
  KEY_BUTTON_B = 125;
  KEY_THUMBL = 126;
  KEY_THUMBR = 127;
  KEY_UNKNOWN = 128;
  KEY_MODIFIERS = 215;
  KEY_LSHIFT = 215;
  KEY_RSHIFT = 216;
  KEY_LCTRL = 217;
  KEY_RCTRL = 218;
  KEY_ALT = 219;
  KEY_ALTGR = 220;
  KEY_LWIN = 221;
  KEY_RWIN = 222;
  KEY_MENU = 223;
  KEY_SCROLLLOCK = 224;
  KEY_NUMLOCK = 225;
  KEY_CAPSLOCK = 226;
  KEY_MAX = 227;
  KEYMOD_SHIFT = $0001;
  KEYMOD_CTRL = $0002;
  KEYMOD_ALT = $0004;
  KEYMOD_LWIN = $0008;
  KEYMOD_RWIN = $0010;
  KEYMOD_MENU = $0020;
  KEYMOD_COMMAND = $0040;
  KEYMOD_SCROLOCK = $0100;
  KEYMOD_NUMLOCK = $0200;
  KEYMOD_CAPSLOCK = $0400;
  KEYMOD_INALTSEQ = $0800;
  KEYMOD_ACCENT1 = $1000;
  KEYMOD_ACCENT2 = $2000;
  KEYMOD_ACCENT3 = $4000;
  KEYMOD_ACCENT4 = $8000;
{$ENDREGION}

  // sticks
  JOY_STICK_LS = 0;
  JOY_STICK_RS = 1;
  JOY_STICK_LT = 2;
  JOY_STICK_RT = 3;

  // axes
  JOY_AXES_X = 0;
  JOY_AXES_Y = 1;
  JOY_AXES_Z = 2;

  // buttons
  JOY_BTN_A = 0;
  JOY_BTN_B = 1;
  JOY_BTN_X = 2;
  JOY_BTN_Y = 3;
  JOY_BTN_RB = 4;
  JOY_BTN_LB = 5;
  JOY_BTN_RT = 6;
  JOY_BTN_LT = 7;
  JOY_BTN_BACK = 8;
  JOY_BTN_START = 9;
  JOY_BTN_RDPAD = 10;
  JOY_BTN_LDPAD = 11;
  JOY_BTN_DDPAD = 12;
  JOY_BTN_UDPAD = 13;

type
  { TGVJoystick }
  TGVJoystick = record
    Name: string;
    Sticks: Integer;
    Buttons: Integer;
    StickName: array[0..MAX_STICKS-1] of string;
    Axes: array[0..MAX_STICKS-1] of Integer;
    AxesName: array[0..MAX_STICKS-1, 0..MAX_AXES-1] of string;
    Pos: array[0..MAX_STICKS-1, 0..MAX_AXES-1] of Single;
    Button: array[0..1, 0..MAX_BUTTONS-1] of Boolean;
    ButtonName: array[0..MAX_BUTTONS- 1] of string;
    procedure Setup(aNum: Integer);
    function GetPos(aStick: Integer; aAxes: Integer): Single;
    function GetButton(aButton: Integer): Boolean;
    procedure Clear;
  end;

  { TGVInput }
  TGVInput = class(TGVObject)
  protected
    FKeyCode: Integer;
    FMouseButtons: array [0..1, 0..256] of Boolean;
    FKeyButtons: array [0..1, 0..256] of Boolean;
    FJoyStick: TGVJoystick;
    FMouse: record
      Postion: TGVVector;
      Delta: TGVVector;
      Pressure: Single;
    end;
  public
    property KeyCode: Integer read FKeyCode;
    constructor Create; override;
    destructor Destroy; override;
    procedure Clear;
    procedure Update;
    function  KeyDown(aKey: Cardinal): Boolean;
    function  KeyPressed(aKey: Cardinal): Boolean;
    function  KeyReleased(aKey: Cardinal): Boolean;

    function  MouseDown(aButton: Cardinal): Boolean;
    function  MousePressed(aButton: Cardinal): Boolean;
    function  MouseReleased(aButton: Cardinal): Boolean;
    procedure MouseSetPos(aX: Integer; aY: Integer);
    procedure GetMouseInfo(aPosition: PGVVector; aDelta: PGVVector; aPressure: System.PSingle);

    function  JoystickDown(aButton: Cardinal): Boolean;
    function  JoystickPressed(aButton: Cardinal): Boolean;
    function  JoystickReleased(aButton: Cardinal): Boolean;
    function  JoystickPosition(aStick: Integer; aAxes: Integer): Single;
  end;

{ --- INPUTMAP -------------------------------------------------------------- }
type
  { TGVInputMapDevice }
  TGVInputMapDevice = (Keyboard, Mouse, Joystick);

  { TGVInputMap }
  TGVInputMap = class(TGVObject)
  protected
    type
      { TInputMapDeviceInput }
      TInputMapDeviceInput = record
        Device: TGVInputMapDevice;
        Data: Integer;
      end;

      { TInputMapAction }
      TInputMapAction = record
        Action: string;
        List: TList<TInputMapDeviceInput>;
      end;
  protected
    FList: TDictionary<string, TInputMapAction>;
    function NewAction(const aAction: string; aDevice: TGVInputMapDevice; aData: Integer): TInputMapAction;
  public
    constructor Create; override;
    destructor Destroy; override;
  public
    procedure Clear;
    function Add(const aAction: string; aDevice: TGVInputMapDevice; aData: Integer): Boolean;
    function Remove(const aAction: string): Boolean; overload;
    function Remove(const aAction: string; aDevice: TGVInputMapDevice; aData: Integer): Boolean; overload;
    function Pressed(const aAction: string): Boolean;
    function Released(const aAction: string): Boolean;
    function Down(const aAction: string): Boolean;
    function Save(const aFilename: string): Boolean;
    function Load(aArchive: TGVArchive; const aFilename: string): Boolean;
  end;

{ --- FONT ------------------------------------------------------------------ }
const
  // Resource Name Constants
  GV_RESNAME_DEFAULT_FONT = 'f83c944ce5144cbe8e05f80becffead2';

type
  { TGVFont }
  TGVFont = class(TGVObject)
  protected
    FHandle: PALLEGRO_FONT;
    FFilename: string;
    FSize: Integer;
  public
    constructor Create; override;
    destructor Destroy; override;
    function LoadBuiltIn: Boolean;
    function LoadDefault(aSize: Cardinal): Boolean;
    function Load(aArchive: TGVArchive; aSize: Cardinal; aFilename: string): Boolean;
    function Unload: Boolean;
    procedure PrintText(aX: Single; aY: Single; aColor: TGVColor; aAlign: TGVHAlign; const aMsg: string; const aArgs: array of const); overload;
    procedure PrintText(aX: Single; var aY: Single; aLineSpace: Single; aColor: TGVColor; aAlign: TGVHAlign; const aMsg: string; const aArgs: array of const); overload;
    procedure PrintText(aX: Single; aY: Single; aColor: TGVColor; aAngle: Single; const aMsg: string; const aArgs: array of const); overload;
    function  GetTextWidth(const aMsg: string; const aArgs: array of const): Single;
    function  GetLineHeight: Single;
  end;

{ --- AUDIO ----------------------------------------------------------------- }

const
  AUDIO_PAN_LEFT     = -1.0;
  AUDIO_PAN_CENTERED = 0.0;
  AUDIO_PAN_RIGHT    = 1.0;
  AUDIO_PAN_NONE     = -1000.0;

  AUDIO_MAX_CHANNELS = 16;

type
  TGVMusic   = type Integer;
  TGVSound   = type Integer;
  TGVSoundId = type Integer;

  { TGVAudio }
  TGVAudio = class(TGVObject)
  protected
    type
      { TMusic }
      TMusic = record
        Handle: PALLEGRO_AUDIO_STREAM;
        Filename: string;
      end;
      { TSound }
      TSound = record
        Handle: PALLEGRO_SAMPLE;
        Filename: string;
      end;
  protected
    FId: Integer;
    FMusicList: TDictionary<TGVMusic, TMusic>;
    FSampleList: TDictionary<TGVSound, TSound>;
    FSampleIdList: TDictionary<TGVSoundId, ALLEGRO_SAMPLE_ID>;
    function GetID: Integer;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Update;
    procedure Pause(aPause: Boolean);
    procedure Clear;
    function  LoadMusic(aArchive: TGVArchive; const aFilename: string): TGVMusic;
    function  UnloadMusic(var aMusic: TGVMusic): Boolean;
    procedure UnloadAllMusic;
    function  PlayMusic(aMusic: TGVMusic; aVolume: Single; aLoop: Boolean): Boolean;
    function  StopMusic(aMusic: TGVMusic): Boolean;
    procedure StopAllMusic;
    function  GetMusicLooping(aMusic: TGVMusic): Boolean;
    procedure SetMusicLooping(aMusic: TGVMusic; aLoop: Boolean);
    function  GetMusicPlaying(aMusic: TGVMusic): Boolean;
    procedure SetMusicPlaying(aMusic: TGVMusic; aPlay: Boolean);
    procedure SetMusicVolume(aMusic: TGVMusic; aVolume: Single);
    function  GetMusicVolume(aMusic: TGVMusic): Single;
    procedure SeekMusic(aMusic: TGVMusic; aTime: Single);
    procedure RewindMusic(aMusic: TGVMusic; aTime: Single);
    function  ReserveSoundChannels(aCount: Integer): Boolean;
    function  LoadSound(aArchive: TGVArchive; const aFilename: string): TGVSound;
    procedure UnloadSound(var aSound: TGVSound);
    procedure UnloadAllSounds;
    function  PlaySound(aSound: TGVSound; aVolume: Single; aLoop: Boolean; aPan: Single=AUDIO_PAN_CENTERED; aSpeed: Single=1.0): TGVSoundId;
    procedure StopSound(var aId: TGVSoundId);
    procedure StopAllSounds;
    function  SoundPlaying(aId: TGVSoundId): Boolean;
  end;

{ --- VIDEO ----------------------------------------------------------------- }
type
  { TGVVideo }
  TGVVideo = class(TGVObject)
  protected
    FVoice: PALLEGRO_VOICE;
    FMixer: PALLEGRO_MIXER;
    FHandle: PALLEGRO_VIDEO;
    FLoop: Boolean;
    FPlaying: Boolean;
    FPaused: Boolean;
    FFilename: string;
    procedure OnFinished(aHandle: PALLEGRO_VIDEO);
  public
    constructor Create; override;
    destructor Destroy; override;
    function  Load(aArchive: TGVArchive; const aFilename: string): Boolean;
    function  Unload: Boolean;
    function  GetPause: Boolean;
    procedure SetPause(aPause: Boolean);
    function  GetLooping:  Boolean;
    procedure Setooping(aLoop: Boolean);
    function  GetPlaying: Boolean;
    procedure SetPlaying(aPlay: Boolean);
    function  GetFilename: string;
    procedure Play(aArchive: TGVArchive; const aFilename: string; aLoop: Boolean; aVolume: Single); overload;
    procedure Play(aLoop: Boolean; aVolume: Single); overload;
    procedure Draw(aX: Single; aY: Single; aScale: Single);
    procedure GetSize(aWidth: PSingle; aHeight: PSingle);
    procedure Seek(aSeconds: Single);
    procedure Rewind;
  end;

{ --- CONFIGFILE ------------------------------------------------------------ }
type
  { TGVConfigFile }
  TGVConfigFile = class(TGVObject)
  protected
    FHandle: TIniFile;
    FFilename: string;
    FSection: TStringList;
    property  Handle: TIniFile read FHandle;
  public
    constructor Create; override;
    destructor Destroy; override;
    function  Open(const aFilename: string=''): Boolean;
    procedure Close;
    function  IsOpen: Boolean;
    procedure Update;
    function  RemoveSection(const aName: string): Boolean;
    procedure SetValue(const aSection: string; const aKey: string; const aValue: string);  overload;
    procedure SetValue(const aSection: string; const aKey: string; aValue: Integer); overload;
    procedure SetValue(const aSection: string; const aKey: string; aValue: Boolean); overload;
    procedure SetValue(const aSection: string; const aKey: string; aValue: Pointer; aValueSize: Cardinal); overload;
    function  GetValue(const aSection: string; const aKey: string; const aDefaultValue: string): string; overload;
    function  GetValue(const aSection: string; const aKey: string; aDefaultValue: Integer): Integer; overload;
    function  GetValue(const aSection: string; const aKey: string; aDefaultValue: Boolean): Boolean; overload;
    procedure GetValue(const aSection: string; const aKey: string; aValue: Pointer; aValueSize: Cardinal); overload;
    function  RemoveKey(const aSection: string; const aKey: string): Boolean;
    function  GetSectionValues(const aSection: string): Integer;
    function  GetSectionValue(aIndex: Integer; aDefaultValue: string): string; overload;
    function  GetSectionValue(aIndex: Integer; aDefaultValue: Integer): Integer; overload;
    function  GetSectionValue(aIndex: Integer; aDefaultValue: Boolean): Boolean; overload;
  end;

{ --- SPEECH ---------------------------------------------------------------- }
type
  { TGVSpeechVoiceAttribute }
  TGVSpeechVoiceAttribute = (Description, Name, Vendor, Age, Gender, Language, Id);

  { TGVSpeech }
  TGVSpeech = class(TGVObject)
  protected
    FSpVoice: TSpVoice;
    FVoiceList: TInterfaceList;
    FVoiceDescList: TStringList;
    FPaused: Boolean;
    FText: string;
    FWord: string;
    FVoice: Integer;
    procedure OnWord(aSender: TObject; aStreamNumber: Integer; aStreamPosition: OleVariant; aCharacterPosition, aLength: Integer);
    //procedure OnStartStream(aSender: TObject; aStreamNumber: Integer; aStreamPosition: OleVariant);
    procedure DoSpeak(aText: string; aFlags: Integer);
    procedure EnumVoices;
    procedure FreeVoices;
    procedure Setup;
    procedure Shutdown;
  public
    constructor Create; override;
    destructor Destroy; override;
    function  GetVoiceCount: Integer;
    function  GetVoiceAttribute(aIndex: Integer; aAttribute: TGVSpeechVoiceAttribute): WideString;
    procedure ChangeVoice(aIndex: Integer);
    function  GetVoice: Integer;
    procedure SetVolume(aVolume: Single);
    function  GetVolume: Single;
    procedure SetRate(aRate: Single);
    function  GetRate: Single;
    procedure Clear;
    procedure Say(const aText: WideString; aPurge: Boolean);
    procedure SayXML(const aText: WideString; aPurge: Boolean);
    function  Active: Boolean;
    procedure Pause;
    procedure Resume;
    procedure Reset;
  end;

{ --- ASYNC ----------------------------------------------------------------- }
type
  { TGVAsyncThread }
  TGVAsyncThread = class(TThread)
  protected
    FTask: TProc;
    FWait: TProc;
    FFinished: Boolean;
  public
    property TaskProc: TProc read FTask write FTask;
    property WaitProc: TProc read FWait write FWait;
    property Finished: Boolean read FFinished;
    constructor Create; virtual;
    destructor Destroy; override;
    procedure Execute; override;
  end;

  { TGVAsync }
  TGVAsync = class(TGVObject)
  protected
    FCriticalSection: TCriticalSection;
    FQueue: TList<TGVAsyncThread>;
    procedure Setup;
    procedure Shutdown;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Process;
    procedure Run(aTask: TProc; aWait: TProc);
    procedure Enter;
    procedure Leave;
  end;

{ --- DATABASE -------------------------------------------------------------- }
const
  GV_DEFAULT_MYSQL_PORT = 3306;

type
  { TGVDatabase }
  TGVDatabase = class(TGVObject)
  protected
    FHandle: TDatabase;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure SetupMySQL(const aServer: string; aPort: Integer; const aDatabase: string; const aUserName: string; const aPassword: string);
    procedure SetupSQLite(const aDatabase: string; aPassword: string);
    procedure Open;
    procedure Close;
    function Connected: Boolean;
    function ExecSQL(const aSQL: string; const aParams: array of const): LongInt;
    function ExecSQLScalar(const aSQL: string; const aParams: array of const): string;
    function Query(const aSQL: string; const aParams: array of const): LongInt;
    function QueryFieldCount: Integer;
    function QueryRecordCount: Integer;
    function QueryBOF: Boolean;
    function QueryEOF: Boolean;
    procedure QueryNext;
    procedure QueryPrev;
    procedure QueryLast;
    procedure QueryFirst;
    function QueryField(const aName: string): string;
    function LastError: string;
  end;

{ --- SCREENSHOT ------------------------------------------------------------ }
type
  { TGVScreenshot }
  TGVScreenshot = class(TGVObject)
  protected
    FFlag: Boolean;
    FDir: string;
    FBaseFilename: string;
    FFilename: string;
    procedure Process;
  public
    property Dir: string read FDir;
    constructor Create; override;
    destructor Destroy; override;
    procedure Init(const aDir: WideString; const aBaseFilename: WideString);
    procedure Take;
  end;

{ --- SCREENSHAKE ----------------------------------------------------------- }
type
  { TGVAScreenshake }
  TGVAScreenshake = class
  protected
    FActive: Boolean;
    FDuration: Single;
    FMagnitude: Single;
    FTimer: Single;
    FPos: TGVVector;
  public
    constructor Create(aDuration: Single; aMagnitude: Single);
    destructor Destroy; override;
    procedure Process(aSpeed: Single; aDeltaTime: Double);
    property Active: Boolean read FActive;
  end;

  { TGVScreenshake }
  TGVScreenshake = class(TGVObject)
  protected
    FTrans: ALLEGRO_TRANSFORM;
    FList: TObjectList<TGVAScreenshake>;
    procedure Process(aSpeed: Single; aDeltaTime: Double);
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Start(aDuration: Single; aMagnitude: Single);
    procedure Clear;
    function  Active: Boolean;
  end;

{ --- STARFIELD ------------------------------------------------------------- }
type
  { TGVStarfield }
  TGVStarfield = class(TGVObject)
  protected
    type
      { TStarfieldItem }
      TStarfieldItem = record
        X, Y, Z, Speed: Single;
      end;
  protected
    FCenter: TGVVector;
    FMin: TGVVector;
    FMax: TGVVector;
    FViewScaleRatio: Single;
    FViewScale: Single;
    FStarCount: Cardinal;
    FStar: array of TStarfieldItem;
    FSpeed: TGVVector;
    FVirtualPos: TGVVector;
    procedure TransformDrawPoint(aX, aY, aZ: Single; aVPX, aVPY, aVPW, aVPH: Integer);
    procedure Done;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Init(aStarCount: Cardinal; aMinX, aMinY, aMinZ, aMaxX, aMaxY, aMaxZ, aViewScale: Single);
    procedure SetVirtualPos(aX, aY: Single);
    procedure GetVirtualPos(var aX: Single; var aY: Single);
    procedure SetXSpeed(aSpeed: Single);
    procedure SetYSpeed(aSpeed: Single);
    procedure SetZSpeed(aSpeed: Single);
    procedure Update(aDeltaTime: Single);
    procedure Render;
  end;

{ --- POLYGON --------------------------------------------------------------- }
type
  { TPolygon }
  TGVPolygon = class(TGVObject)
  protected
    type
      { TPolygonSegment }
      TPolygonSegment = record
        Point: TGVVector;
        Visible: Boolean;
      end;
  protected
    FSegment: array of TPolygonSegment;
    FWorldPoint: array of TGVVector;
    FItemCount: Integer;
    procedure Clear;
  public
    constructor Create; override;
    destructor Destroy; override;
    function Save(const aFilename: string): Boolean;
    function Load(aArchive: TGVArchive; const aFilename: string): Boolean;
    procedure CopyFrom(aPolygon: TGVPolygon);
    procedure AddLocalPoint(aX: Single; aY: Single; aVisible: Boolean);
    function  Transform(aX: Single; aY: Single; aScale: Single; aAngle: Single; aOrigin: PGVVector; aHFlip: Boolean; aVFlip: Boolean): Boolean;
    procedure Render(aX: Single; aY: Single; aScale: Single; aAngle: Single; aThickness: Integer; aColor: TGVColor; aOrigin: PGVVector; aHFlip: Boolean; aVFlip: Boolean);
    procedure SetSegmentVisible(aIndex: Integer; aVisible: Boolean);
    function  GetSegmentVisible(aIndex: Integer): Boolean;
    function  GetPointCount: Integer;
    function  GetWorldPoint(aIndex: Integer): PGVVector;
    function  GetLocalPoint(aIndex: Integer): PGVVector;
  end;

{ --- POLYPOINT ------------------------------------------------------------- }
type
  TGVPolyPoint = class;
  TGVSprite = class;

  { PolyPointTrace }
  PolyPointTrace = record
  private
    type
      TPointi = record
        X,Y: Integer;
      end;
  private
    class var
      mPolyArr: array of TPointi;
      mPntCount: Integer;
      mMju: Extended;
      mMaxStepBack: Integer;
      mAlphaThreshold: Byte; // alpha channel threshhold
    class function IsNeighbour(X1, Y1, X2, Y2: Integer): Boolean; static;
    class function IsPixEmpty(Tex: TGVTexture; X, Y: Integer; W, H: Single): Boolean; static;
    class procedure AddPoint(X, Y: Integer); static;
    class procedure DelPoint(Index: Integer); static;
    class function IsInList(X, Y: Integer): Boolean; static;
    class procedure FindStartingPoint(Tex: TGVTexture; var X, Y: Integer; W, H: Single); static;
    class function CountEmptyAround(Tex: TGVTexture; X, Y: Integer; W, H: Single): Integer; static;
    class function FindNearestButNotNeighbourOfOther(Tex: TGVTexture; Xs, Ys, XOther, YOther: Integer; var XF, YF: Integer; W, H: Single): Boolean; static;
    class function LineLength(X1, Y1, X2, Y2: Integer): Extended; static;
    //class function TriangleSquare(X1, Y1, X2, Y2, X3, Y3: Integer): Extended; static;
    class function TriangleThinness(X1, Y1, X2, Y2, X3, Y3: Integer): Extended; static;
  public
    class procedure Init(aMju: Extended = 6; aMaxStepBack: Integer = 10; aAlphaThreshold: Byte = 70); static;
    class procedure Done; static;
    class function  GetPointCount: Integer; static;
    class procedure PrimaryTrace(aTex: TGVTexture; aWidth, aHeight: Single); static;
    class procedure SimplifyPoly; static;
    class procedure ApplyPolyPoint(aPolyPoint: TGVPolyPoint; aNum: Integer; aOrigin: PGVVector); static;
  end;

  { TGVPolyPoint }
  TGVPolyPoint = class(TGVObject)
  protected
    FPolygon: array of TGVPolygon;
    FCount: Integer;
    procedure Clear;
  public
    constructor Create; override;
    destructor Destroy; override;
    function Save(const aFilename: string): Boolean;
    function Load(aArchive: TGVArchive; const aFilename: string): Boolean;
    function CopyFrom(aPolyPoint: TGVPolyPoint): Boolean;
    procedure AddPoint(aNum: Integer; aX: Single; aY: Single; aOrigin: PGVVector);
    function TraceFromTexture(aTexture: TGVTexture; aMju: Single; aMaxStepBack: Integer; aAlphaThreshold: Integer; aOrigin: PGVVector): Integer;
    procedure TraceFromSprite(aSprite: TGVSprite; aGroup: Integer; aMju: Single; aMaxStepBack: Integer; aAlphaThreshold: Integer; aOrigin: PGVVector);
    function Count: Integer;
    procedure Render(aNum: Integer; aX: Single; aY: Single; aScale: Single; aAngle: Single; aColor: TGVColor; aOrigin: PGVVector; aHFlip: Boolean; aVFlip: Boolean);
    function Collide(aNum1: Integer; aGroup1: Integer; aX1: Single; aY1: Single;
      aScale1: Single; aAngle1: Single; aOrigin1: PGVVector; aHFlip1: Boolean;
      aVFlip1: Boolean; aPolyPoint2: TGVPolyPoint; aNum2: Integer;
      aGroup2: Integer; aX2: Single; aY2: Single; aScale2: Single;
      aAngle2: Single; aOrigin2: PGVVector; aHFlip2: Boolean; aVFlip2: Boolean;
      var aHitPos: TGVVector): Boolean;
    function CollidePoint(aNum: Integer; aGroup: Integer; aX: Single;
      aY: Single; aScale: Single; aAngle: Single; aOrigin: PGVVector;
      aHFlip: Boolean; aVFlip: Boolean; var aPoint: TGVVector): Boolean;
    function Polygon(aNum: Integer): TGVPolygon;
    function Valid(aNum: Integer): Boolean;
  end;

{ --- SPRITE ---------------------------------------------------------------- }
  { TGVSprite }
  TGVSprite = class(TGVObject)
  protected
    type
      { TSpriteImageRegion }
      PSpriteImageRegion = ^TSpriteImageRegion;
      TSpriteImageRegion = record
        Rect: TGVRectangle;
        Page: Integer;
      end;

      { TSpriteGroup }
      PSpriteGroup = ^TSpriteGroup;
      TSpriteGroup = record
        Image: array of TSpriteImageRegion;
        Count: Integer;
        PolyPoint: TGVPolypoint;
      end;
  protected
    FTexture: array of TGVTexture;
    FGroup: array of TSpriteGroup;
    FPageCount: Integer;
    FGroupCount: Integer;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Clear;
    function LoadPage(aArchive: TGVArchive; const aFilename: string; aColorKey: PGVColor): Integer;
    function AddGroup: Integer;
    function GetGroupCount: Integer;
    function AddImageFromRect(aPage: Integer; aGroup: Integer; aRect: TGVRectangle): Integer;
    function AddImageFromGrid(aPage: Integer; aGroup: Integer; aGridX: Integer; aGridY: Integer; aGridWidth: Integer; aGridHeight: Integer): Integer;
    function GetImageCount(aGroup: Integer): Integer;
    function GetImageWidth(aNum: Integer; aGroup: Integer): Single;
    function GetImageHeight(aNum: Integer; aGroup: Integer): Single;
    function GetImageTexture(aNum: Integer; aGroup: Integer): TGVTexture;
    function GetImageRect(aNum: Integer; aGroup: Integer): TGVRectangle;
    procedure DrawImage(aNum: Integer; aGroup: Integer; aX: Single; aY: Single; aOrigin: PGVVector; aScale: PGVVector; aAngle: Single; aColor: TGVColor; aHFlip: Boolean; aVFlip: Boolean; aDrawPolyPoint: Boolean);
    function GroupPolyPoint(aGroup: Integer): TGVPolyPoint;
    procedure GroupPolyPointTrace(aGroup: Integer; aMju: Single=6; aMaxStepBack: Integer=12; aAlphaThreshold: Integer=70; aOrigin: PGVVector=nil);
    function GroupPolyPointCollide(aNum1: Integer; aGroup1: Integer;
      aX1: Single; aY1: Single; aScale1: Single; aAngle1: Single;
      aOrigin1: PGVVector; aHFlip1: Boolean; aVFlip1: Boolean; aSprite2: TGVSprite;
      aNum2: Integer; aGroup2: Integer; aX2: Single; aY2: Single;
      aScale2: Single; aAngle2: Single; aOrigin2: PGVVector; aHFlip2: Boolean;
      aVFlip2: Boolean; aShrinkFactor: Single; var aHitPos: TGVVector): Boolean;
    function GroupPolyPointCollidePoint(aNum: Integer; aGroup: Integer;
      aX: Single; aY: Single; aScale: Single; aAngle: Single; aOrigin: PGVVector;
      aHFlip: Boolean; aVFlip: Boolean; aShrinkFactor: Single;
      var aPoint: TGVVector): Boolean;
  end;

{ --- ENTITY ---------------------------------------------------------------- }
type
  { TGVEntity }
  TGVEntity = class(TGVObject)
  protected
    FSprite      : TGVSprite;
    FGroup       : Integer;
    FFrame       : Integer;
    FFrameFPS    : Single;
    FFrameTimer  : Single;
    FPos         : TGVVector;
    FDir         : TGVVector;
    FScale       : Single;
    FAngle       : Single;
    FAngleOffset : Single;
    FColor       : TGVColor;
    FHFlip       : Boolean;
    FVFlip       : Boolean;
    FLoopFrame   : Boolean;
    FWidth       : Single;
    FHeight      : Single;
    FRadius      : Single;
    FFirstFrame  : Integer;
    FLastFrame   : Integer;
    FShrinkFactor: Single;
    FOrigin      : TGVVector;
    FRenderPolyPoint: Boolean;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Init(aSprite: TGVSprite; aGroup: Integer);
    procedure SetFrameRange(aFirst: Integer; aLast: Integer);
    function  NextFrame: Boolean;
    function  PrevFrame: Boolean;
    function  GetFrame: Integer;
    procedure SetFrame(aFrame: Integer);
    function  GetFrameFPS: Single;
    procedure SetFrameFPS(aFrameFPS: Single);
    function  GetFirstFrame: Integer;
    function  GetLastFrame: Integer;
    procedure SetPosAbs(aX: Single; aY: Single);
    procedure SetPosRel(aX: Single; aY: Single);
    function  GetPos: TGVVector;
    function  GetDir: TGVVector;
    procedure SetScaleAbs(aScale: Single);
    procedure SetScaleRel(aScale: Single);
    function  GetAngle: Single;
    function  GetAngleOffset: Single;
    procedure SetAngleOffset(aAngle: Single);
    procedure RotateAbs(aAngle: Single);
    procedure RotateRel(aAngle: Single);
    function  RotateToAngle(aAngle: Single; aSpeed: Single): Boolean;
    function  RotateToPos(aX: Single; aY: Single; aSpeed: Single): Boolean;
    function  RotateToPosAt(aSrcX: Single; aSrcY: Single; aDestX: Single; aDestY: Single; aSpeed: Single): Boolean;
    procedure Thrust(aSpeed: Single);
    procedure ThrustAngle(aAngle: Single; aSpeed: Single);
    function  ThrustToPos(aThrustSpeed: Single; aRotSpeed: Single; aDestX: Single; aDestY: Single; aSlowdownDist: Single; aStopDist: Single; aStopSpeed: Single; aStopSpeedEpsilon: Single; aDeltaTime: Single): Boolean;
    function  IsVisible(aVirtualX: Single; aVirtualY: Single): Boolean;
    function  IsFullyVisible(aVirtualX: Single; aVirtualY: Single): Boolean;
    function  Overlap(aX: Single; aY: Single; aRadius: Single; aShrinkFactor: Single): Boolean; overload;
    function  Overlap(aEntity: TGVEntity): Boolean; overload;
    procedure Render(aVirtualX: Single; aVirtualY: Single);
    procedure RenderAt(aX: Single; aY: Single);
    function  GetSprite: TGVSprite;
    function  GetGroup: Integer;
    function  GetScale: Single;
    function  GetColor: TGVColor;
    procedure SetColor(aColor: TGVColor);
    procedure GetFlipMode(aHFlip: PBoolean; aVFlip: PBoolean);
    procedure SetFlipMode(aHFlip: PBoolean; aVFlip: PBoolean);
    function  GetLoopFrame: Boolean;
    procedure SetLoopFrame(aLoop: Boolean);
    function  GetWidth: Single;
    function  GetHeight: Single;
    function  GetRadius: Single;
    function  GetShrinkFactor: Single;
    procedure SetShrinkFactor(aShrinkFactor: Single);
    procedure SetRenderPolyPoint(aRenderPolyPoint: Boolean);
    function  GetRenderPolyPoint: Boolean;
    procedure TracePolyPoint(aMju: Single=6; aMaxStepBack: Integer=12; aAlphaThreshold: Integer=70; aOrigin: PGVVector=nil);
    function  CollidePolyPoint(aEntity: TGVEntity; var aHitPos: TGVVector): Boolean;
    function  CollidePolyPointPoint(var aPoint: TGVVector): Boolean;
  end;

{ --- CUSTOMGAME ------------------------------------------------------------ }
type
  { TGVSettings }
  TGVSettings = record
    // archive
    ArchivePassword: string;
    ArchiveFilename: string;

    // window
    WindowWidth: Integer;
    WindowHeight: Integer;
    WindowTitle: string;
    WindowClearColor: TGVColor;

    // font
    FontFilename: string;
    FontSize: Integer;

    // hud
    HudTextItemPadWidth: Integer;
    HudPosX: Integer;
    HudPosY: Integer;
    HudLineSpace: Integer;
  end;

  { PGVSettings }
  PGVSettings = ^TGVSettings;

  { TGVCustomGame }
  TGVCustomGame = class(TGVObject)
  protected
    FOnPrint: TGVPrintEvent;
  public
    property OnPrint: TGVPrintEvent read FOnPrint write FOnPrint;
    constructor Create; override;
    destructor Destroy; override;
    procedure Print(const aMsg: string; const aArgs: array of const);
    procedure PrintLn; overload;
    procedure PrintLn(const aMsg: string; const aArgs: array of const); overload;
    procedure OnProcessCmdLine; virtual;
    procedure OnStartup; virtual;
    procedure OnShutdown; virtual;
    procedure OnRun; virtual;
  end;

  { TGVCustomGameClass }
  TGVCustomGameClass = class of TGVCustomGame;

{ --- GAME ------------------------------------------------------------------ }
type
  { TGVGame }
  TGVGame = class(TGVCustomGame)
  protected
    FTerminated: Boolean;
    FReady: Boolean;
    FTimer: record
      LNow: Double;
      Passed: Double;
      Last: Double;
      Accumulator: Double;
      FrameAccumulator: Double;
      DeltaTime: Double;
      FrameCount: Cardinal;
      FrameRate: Cardinal;
      UpdateSpeed: Single;
      FixedUpdateSpeed: Single;
      FixedUpdateTimer: Single;
    end;
    FHud: record
      TextItemPadWidth: Integer;
      Pos: TGVVector;
    end;
    FMousePos: TGVVector;
    FMouseDelta: TGVVector;
    FMousePressure: Single;
    FSettings: TGVSettings;
    FConfigFile: TGVConfigFile;
    FArchive: TGVArchive;
    FFont: TGVFont;
    FInputMap: TGVInputMap;
    FSprite: TGVSprite;
    procedure UpdateTiming;
  public
    property Terminated: Boolean read FTerminated write FTerminated;
    property Ready: Boolean read FReady;
    property Settings: TGVSettings read FSettings;
    property Font: TGVFont read FFont;
    property Archive: TGVArchive read FArchive;
    property InputMap: TGVInputMap read FInputMap;
    property MousePos: TGVVector read FMousePos;
    property MouseDelta: TGVVector read FMouseDelta;
    property MousePressure: Single read FMousePressure;
    property Sprite: TGVSprite read FSprite;
    constructor Create; override;
    destructor Destroy; override;
    procedure OnPreStartup; virtual;
    procedure OnPostStartup; virtual;
    procedure OnLoadConfig; virtual;
    procedure OnSaveConfig; virtual;
    procedure OnSetSettings(var aSettings: TGVSettings); virtual;
    procedure OnApplySettings; virtual;
    procedure OnUnApplySettings; virtual;
    procedure OnStartup; override;
    procedure OnShutdown; override;
    procedure OnRun; override;
    procedure OnReady(aReady: Boolean); virtual;
    procedure OnUpdateFrame(aDeltaTime: Double); virtual;
    procedure OnFixedUpdateFrame; virtual;
    procedure OnStartFrame; virtual;
    procedure OnEndFrame; virtual;
    procedure OnClearFrame; virtual;
    procedure OnRenderFrame; virtual;
    procedure OnRenderHUD; virtual;
    procedure OnShowFrame; virtual;
    procedure OnLoadVideo(const aFilename: string); virtual;
    procedure OnUnloadVideo(const aFilename: string); virtual;
    procedure OnStartVideo(const aFilename: string); virtual;
    procedure OnFinishedVideo(const aFilename: string); virtual;
    procedure OnSpeechWord(aFWord: string; aText: string); virtual;
    procedure OnScreenshot(const aFilename: string); virtual;
    function  GetTime: Double;
    procedure ResetTiming(aSpeed: Single=0; aFixedSpeed: Single=0);
    procedure SetUpdateSpeed(aSpeed: Single);
    function  GetUpdateSpeed: Single;
    procedure SetFixedUpdateSpeed(aSpeed: Single);
    function  GetFixedUpdateSpeed: Single;
    function  GetDeltaTime: Double;
    function  GetFrameRate: Cardinal;
    function  FrameSpeed(var aTimer: Single; aSpeed: Single): Boolean;
    function  FrameElapsed(var aTimer: Single; aFrames: Single): Boolean;
    procedure SetTerminate(aTerminate: Boolean);
    function  IsTerminated: Boolean;
    procedure HudResetPos;
    procedure HudPos(aX: Integer; aY: Integer);
    procedure HudLineSpace(aLineSpace: Integer);
    procedure HudTextItemPadWidth(aWidth: Integer);
    procedure HudText(aFont: TGVFont; aColor: TGVColor; aAlign: TGVHAlign; const aMsg: string; const aArgs: array of const);
    function  HudTextItem(const aKey: string; const aValue: string; const aSeperator: string='-'): string;
  end;

  { TGVGameClass }
  TGVGameClass = class of TGVGame;

{ GVRunGame }
procedure GVRunGame(aGame: TGVCustomGameClass; aPause: Boolean=False);

{ --- GV -------------------------------------------------------------------- }
type
  { TGV }
  TGV = class
  protected
    FDLLHandle: THandle;
    FDLLExportPath: string;
    FCodePage: Cardinal;
    FEvent: ALLEGRO_EVENT;
    FQueue: PALLEGRO_EVENT_QUEUE;
    FVoice: PALLEGRO_VOICE;
    FMixer: PALLEGRO_MIXER;
    FFileState: array[False..True] of ALLEGRO_STATE;
    FMasterObjectList: TGVObjectList;
    FUtil: TGVUtil;
    FConsole: TGVConsole;
    FLogger: TGVLogger;
    FCmdLine: TGVCmdLine;
    FUserPath: TGVUserPath;
    FWindow: TGVWindow;
    FPrimitive: TGVPrimitive;
    FInput: TGVInput;
    FAudio: TGVAudio;
    FVideo: TGVVideo;
    FMath: TGVMath;
    FGame: TGVGame;
    FCollision: TGVCollision;
    FSpeech: TGVSpeech;
    FAsync: TGVAsync;
    FScreenshot: TGVScreenshot;
    FScreenshake: TGVScreenshake;
    function GetEvent: PALLEGRO_EVENT;
    procedure AbortDLL;
    procedure LoadDLL;
    procedure UnloadDLL;
    procedure StartupAllegro;
    procedure ShutdownAllegro;
  public
    property Queue: PALLEGRO_EVENT_QUEUE read FQueue;
    property Voice: PALLEGRO_VOICE read FVoice;
    property Mixer: PALLEGRO_MIXER read FMixer;
    property Event: PALLEGRO_EVENT read GetEvent;
    property MasterObjectList: TGVObjectList read FMasterObjectList;
    property Util: TGVUtil read FUtil;
    property Console: TGVConsole read FConsole;
    property Logger: TGVLogger read FLogger;
    property CmdLine: TGVCmdLine read FCmdLine;
    property UserPath: TGVUserPath read FUserPath;
    property Window: TGVWindow read FWindow;
    property Primitive: TGVPrimitive read FPrimitive;
    property Input: TGVInput read FInput;
    property Audio: TGVAudio read FAudio;
    property Video: TGVVideo read FVideo;
    property Math: TGVMath read FMath;
    property Collision: TGVCollision read FCollision;
    property Speech: TGVSpeech read FSpeech;
    property Async: TGVAsync read FAsync;
    property Screenshot: TGVScreenshot read FScreenshot;
    property Screenshake: TGVScreenshake read FScreenshake;
    property Game: TGVGame read FGame;
    constructor Create; virtual;
    destructor Destroy; override;
    procedure Run(aGame: TGVCustomGameClass); overload;
    procedure Run(aGame: TGVGameClass); overload;
    procedure SetFileSandBoxed(aEnable: Boolean);
    function  GetFileSandBoxed: Boolean;
    procedure SetFileSandboxWriteDir(aPath: string);
    function  GetFileSandboxWriteDir: string;
  end;

var
  GV: TGV = nil;
{$ENDREGION}

implementation

uses
  System.Types,
  System.IOUtils,
  System.Math,
  System.Zip,
  VCL.Graphics,
  WinApi.Messages,
  WinApi.ShellApi;

{$REGION '  === CLIBS ================================================================='}
procedure GetExports(aDLLHandle: THandle);
begin
  if aDLLHandle = 0 then Exit;
  _al_trace_prefix := GetProcAddress(aDLLHandle, '_al_trace_prefix');
  _al_trace_suffix := GetProcAddress(aDLLHandle, '_al_trace_suffix');
  _WinMain := GetProcAddress(aDLLHandle, '_WinMain');
  al_acknowledge_drawing_halt := GetProcAddress(aDLLHandle, 'al_acknowledge_drawing_halt');
  al_acknowledge_drawing_resume := GetProcAddress(aDLLHandle, 'al_acknowledge_drawing_resume');
  al_acknowledge_resize := GetProcAddress(aDLLHandle, 'al_acknowledge_resize');
  al_add_config_comment := GetProcAddress(aDLLHandle, 'al_add_config_comment');
  al_add_config_section := GetProcAddress(aDLLHandle, 'al_add_config_section');
  al_add_new_bitmap_flag := GetProcAddress(aDLLHandle, 'al_add_new_bitmap_flag');
  al_add_timer_count := GetProcAddress(aDLLHandle, 'al_add_timer_count');
  al_append_menu_item := GetProcAddress(aDLLHandle, 'al_append_menu_item');
  al_append_native_text_log := GetProcAddress(aDLLHandle, 'al_append_native_text_log');
  al_append_path_component := GetProcAddress(aDLLHandle, 'al_append_path_component');
  al_apply_window_constraints := GetProcAddress(aDLLHandle, 'al_apply_window_constraints');
  al_attach_audio_stream_to_mixer := GetProcAddress(aDLLHandle, 'al_attach_audio_stream_to_mixer');
  al_attach_audio_stream_to_voice := GetProcAddress(aDLLHandle, 'al_attach_audio_stream_to_voice');
  al_attach_mixer_to_mixer := GetProcAddress(aDLLHandle, 'al_attach_mixer_to_mixer');
  al_attach_mixer_to_voice := GetProcAddress(aDLLHandle, 'al_attach_mixer_to_voice');
  al_attach_sample_instance_to_mixer := GetProcAddress(aDLLHandle, 'al_attach_sample_instance_to_mixer');
  al_attach_sample_instance_to_voice := GetProcAddress(aDLLHandle, 'al_attach_sample_instance_to_voice');
  al_attach_shader_source := GetProcAddress(aDLLHandle, 'al_attach_shader_source');
  al_attach_shader_source_file := GetProcAddress(aDLLHandle, 'al_attach_shader_source_file');
  al_backup_dirty_bitmap := GetProcAddress(aDLLHandle, 'al_backup_dirty_bitmap');
  al_backup_dirty_bitmaps := GetProcAddress(aDLLHandle, 'al_backup_dirty_bitmaps');
  al_broadcast_cond := GetProcAddress(aDLLHandle, 'al_broadcast_cond');
  al_build_camera_transform := GetProcAddress(aDLLHandle, 'al_build_camera_transform');
  al_build_menu := GetProcAddress(aDLLHandle, 'al_build_menu');
  al_build_shader := GetProcAddress(aDLLHandle, 'al_build_shader');
  al_build_transform := GetProcAddress(aDLLHandle, 'al_build_transform');
  al_calculate_arc := GetProcAddress(aDLLHandle, 'al_calculate_arc');
  al_calculate_ribbon := GetProcAddress(aDLLHandle, 'al_calculate_ribbon');
  al_calculate_spline := GetProcAddress(aDLLHandle, 'al_calculate_spline');
  al_calloc_with_context := GetProcAddress(aDLLHandle, 'al_calloc_with_context');
  al_change_directory := GetProcAddress(aDLLHandle, 'al_change_directory');
  al_check_inverse := GetProcAddress(aDLLHandle, 'al_check_inverse');
  al_clear_depth_buffer := GetProcAddress(aDLLHandle, 'al_clear_depth_buffer');
  al_clear_keyboard_state := GetProcAddress(aDLLHandle, 'al_clear_keyboard_state');
  al_clear_to_color := GetProcAddress(aDLLHandle, 'al_clear_to_color');
  al_clipboard_has_text := GetProcAddress(aDLLHandle, 'al_clipboard_has_text');
  al_clone_bitmap := GetProcAddress(aDLLHandle, 'al_clone_bitmap');
  al_clone_menu := GetProcAddress(aDLLHandle, 'al_clone_menu');
  al_clone_menu_for_popup := GetProcAddress(aDLLHandle, 'al_clone_menu_for_popup');
  al_clone_path := GetProcAddress(aDLLHandle, 'al_clone_path');
  al_close_directory := GetProcAddress(aDLLHandle, 'al_close_directory');
  al_close_native_text_log := GetProcAddress(aDLLHandle, 'al_close_native_text_log');
  al_close_video := GetProcAddress(aDLLHandle, 'al_close_video');
  al_color_cmyk := GetProcAddress(aDLLHandle, 'al_color_cmyk');
  al_color_cmyk_to_rgb := GetProcAddress(aDLLHandle, 'al_color_cmyk_to_rgb');
  al_color_distance_ciede2000 := GetProcAddress(aDLLHandle, 'al_color_distance_ciede2000');
  al_color_hsl := GetProcAddress(aDLLHandle, 'al_color_hsl');
  al_color_hsl_to_rgb := GetProcAddress(aDLLHandle, 'al_color_hsl_to_rgb');
  al_color_hsv := GetProcAddress(aDLLHandle, 'al_color_hsv');
  al_color_hsv_to_rgb := GetProcAddress(aDLLHandle, 'al_color_hsv_to_rgb');
  al_color_html := GetProcAddress(aDLLHandle, 'al_color_html');
  al_color_html_to_rgb := GetProcAddress(aDLLHandle, 'al_color_html_to_rgb');
  al_color_lab := GetProcAddress(aDLLHandle, 'al_color_lab');
  al_color_lab_to_rgb := GetProcAddress(aDLLHandle, 'al_color_lab_to_rgb');
  al_color_lch := GetProcAddress(aDLLHandle, 'al_color_lch');
  al_color_lch_to_rgb := GetProcAddress(aDLLHandle, 'al_color_lch_to_rgb');
  al_color_linear := GetProcAddress(aDLLHandle, 'al_color_linear');
  al_color_linear_to_rgb := GetProcAddress(aDLLHandle, 'al_color_linear_to_rgb');
  al_color_name := GetProcAddress(aDLLHandle, 'al_color_name');
  al_color_name_to_rgb := GetProcAddress(aDLLHandle, 'al_color_name_to_rgb');
  al_color_oklab := GetProcAddress(aDLLHandle, 'al_color_oklab');
  al_color_oklab_to_rgb := GetProcAddress(aDLLHandle, 'al_color_oklab_to_rgb');
  al_color_rgb_to_cmyk := GetProcAddress(aDLLHandle, 'al_color_rgb_to_cmyk');
  al_color_rgb_to_hsl := GetProcAddress(aDLLHandle, 'al_color_rgb_to_hsl');
  al_color_rgb_to_hsv := GetProcAddress(aDLLHandle, 'al_color_rgb_to_hsv');
  al_color_rgb_to_html := GetProcAddress(aDLLHandle, 'al_color_rgb_to_html');
  al_color_rgb_to_lab := GetProcAddress(aDLLHandle, 'al_color_rgb_to_lab');
  al_color_rgb_to_lch := GetProcAddress(aDLLHandle, 'al_color_rgb_to_lch');
  al_color_rgb_to_linear := GetProcAddress(aDLLHandle, 'al_color_rgb_to_linear');
  al_color_rgb_to_name := GetProcAddress(aDLLHandle, 'al_color_rgb_to_name');
  al_color_rgb_to_oklab := GetProcAddress(aDLLHandle, 'al_color_rgb_to_oklab');
  al_color_rgb_to_xyy := GetProcAddress(aDLLHandle, 'al_color_rgb_to_xyy');
  al_color_rgb_to_xyz := GetProcAddress(aDLLHandle, 'al_color_rgb_to_xyz');
  al_color_rgb_to_yuv := GetProcAddress(aDLLHandle, 'al_color_rgb_to_yuv');
  al_color_xyy := GetProcAddress(aDLLHandle, 'al_color_xyy');
  al_color_xyy_to_rgb := GetProcAddress(aDLLHandle, 'al_color_xyy_to_rgb');
  al_color_xyz := GetProcAddress(aDLLHandle, 'al_color_xyz');
  al_color_xyz_to_rgb := GetProcAddress(aDLLHandle, 'al_color_xyz_to_rgb');
  al_color_yuv := GetProcAddress(aDLLHandle, 'al_color_yuv');
  al_color_yuv_to_rgb := GetProcAddress(aDLLHandle, 'al_color_yuv_to_rgb');
  al_compose_transform := GetProcAddress(aDLLHandle, 'al_compose_transform');
  al_convert_bitmap := GetProcAddress(aDLLHandle, 'al_convert_bitmap');
  al_convert_mask_to_alpha := GetProcAddress(aDLLHandle, 'al_convert_mask_to_alpha');
  al_convert_memory_bitmaps := GetProcAddress(aDLLHandle, 'al_convert_memory_bitmaps');
  al_copy_transform := GetProcAddress(aDLLHandle, 'al_copy_transform');
  al_create_audio_recorder := GetProcAddress(aDLLHandle, 'al_create_audio_recorder');
  al_create_audio_stream := GetProcAddress(aDLLHandle, 'al_create_audio_stream');
  al_create_bitmap := GetProcAddress(aDLLHandle, 'al_create_bitmap');
  al_create_builtin_font := GetProcAddress(aDLLHandle, 'al_create_builtin_font');
  al_create_cond := GetProcAddress(aDLLHandle, 'al_create_cond');
  al_create_config := GetProcAddress(aDLLHandle, 'al_create_config');
  al_create_display := GetProcAddress(aDLLHandle, 'al_create_display');
  al_create_event_queue := GetProcAddress(aDLLHandle, 'al_create_event_queue');
  al_create_file_handle := GetProcAddress(aDLLHandle, 'al_create_file_handle');
  al_create_fs_entry := GetProcAddress(aDLLHandle, 'al_create_fs_entry');
  al_create_index_buffer := GetProcAddress(aDLLHandle, 'al_create_index_buffer');
  al_create_menu := GetProcAddress(aDLLHandle, 'al_create_menu');
  al_create_mixer := GetProcAddress(aDLLHandle, 'al_create_mixer');
  al_create_mouse_cursor := GetProcAddress(aDLLHandle, 'al_create_mouse_cursor');
  al_create_mutex := GetProcAddress(aDLLHandle, 'al_create_mutex');
  al_create_mutex_recursive := GetProcAddress(aDLLHandle, 'al_create_mutex_recursive');
  al_create_native_file_dialog := GetProcAddress(aDLLHandle, 'al_create_native_file_dialog');
  al_create_path := GetProcAddress(aDLLHandle, 'al_create_path');
  al_create_path_for_directory := GetProcAddress(aDLLHandle, 'al_create_path_for_directory');
  al_create_popup_menu := GetProcAddress(aDLLHandle, 'al_create_popup_menu');
  al_create_sample := GetProcAddress(aDLLHandle, 'al_create_sample');
  al_create_sample_instance := GetProcAddress(aDLLHandle, 'al_create_sample_instance');
  al_create_shader := GetProcAddress(aDLLHandle, 'al_create_shader');
  al_create_sub_bitmap := GetProcAddress(aDLLHandle, 'al_create_sub_bitmap');
  al_create_thread := GetProcAddress(aDLLHandle, 'al_create_thread');
  al_create_thread_with_stacksize := GetProcAddress(aDLLHandle, 'al_create_thread_with_stacksize');
  al_create_timer := GetProcAddress(aDLLHandle, 'al_create_timer');
  al_create_vertex_buffer := GetProcAddress(aDLLHandle, 'al_create_vertex_buffer');
  al_create_vertex_decl := GetProcAddress(aDLLHandle, 'al_create_vertex_decl');
  al_create_voice := GetProcAddress(aDLLHandle, 'al_create_voice');
  al_cstr := GetProcAddress(aDLLHandle, 'al_cstr');
  al_cstr_dup := GetProcAddress(aDLLHandle, 'al_cstr_dup');
  al_destroy_audio_recorder := GetProcAddress(aDLLHandle, 'al_destroy_audio_recorder');
  al_destroy_audio_stream := GetProcAddress(aDLLHandle, 'al_destroy_audio_stream');
  al_destroy_bitmap := GetProcAddress(aDLLHandle, 'al_destroy_bitmap');
  al_destroy_cond := GetProcAddress(aDLLHandle, 'al_destroy_cond');
  al_destroy_config := GetProcAddress(aDLLHandle, 'al_destroy_config');
  al_destroy_display := GetProcAddress(aDLLHandle, 'al_destroy_display');
  al_destroy_event_queue := GetProcAddress(aDLLHandle, 'al_destroy_event_queue');
  al_destroy_font := GetProcAddress(aDLLHandle, 'al_destroy_font');
  al_destroy_fs_entry := GetProcAddress(aDLLHandle, 'al_destroy_fs_entry');
  al_destroy_index_buffer := GetProcAddress(aDLLHandle, 'al_destroy_index_buffer');
  al_destroy_menu := GetProcAddress(aDLLHandle, 'al_destroy_menu');
  al_destroy_mixer := GetProcAddress(aDLLHandle, 'al_destroy_mixer');
  al_destroy_mouse_cursor := GetProcAddress(aDLLHandle, 'al_destroy_mouse_cursor');
  al_destroy_mutex := GetProcAddress(aDLLHandle, 'al_destroy_mutex');
  al_destroy_native_file_dialog := GetProcAddress(aDLLHandle, 'al_destroy_native_file_dialog');
  al_destroy_path := GetProcAddress(aDLLHandle, 'al_destroy_path');
  al_destroy_sample := GetProcAddress(aDLLHandle, 'al_destroy_sample');
  al_destroy_sample_instance := GetProcAddress(aDLLHandle, 'al_destroy_sample_instance');
  al_destroy_shader := GetProcAddress(aDLLHandle, 'al_destroy_shader');
  al_destroy_thread := GetProcAddress(aDLLHandle, 'al_destroy_thread');
  al_destroy_timer := GetProcAddress(aDLLHandle, 'al_destroy_timer');
  al_destroy_user_event_source := GetProcAddress(aDLLHandle, 'al_destroy_user_event_source');
  al_destroy_vertex_buffer := GetProcAddress(aDLLHandle, 'al_destroy_vertex_buffer');
  al_destroy_vertex_decl := GetProcAddress(aDLLHandle, 'al_destroy_vertex_decl');
  al_destroy_voice := GetProcAddress(aDLLHandle, 'al_destroy_voice');
  al_detach_audio_stream := GetProcAddress(aDLLHandle, 'al_detach_audio_stream');
  al_detach_mixer := GetProcAddress(aDLLHandle, 'al_detach_mixer');
  al_detach_sample_instance := GetProcAddress(aDLLHandle, 'al_detach_sample_instance');
  al_detach_voice := GetProcAddress(aDLLHandle, 'al_detach_voice');
  al_disable_menu_event_source := GetProcAddress(aDLLHandle, 'al_disable_menu_event_source');
  al_do_multiline_text := GetProcAddress(aDLLHandle, 'al_do_multiline_text');
  al_do_multiline_ustr := GetProcAddress(aDLLHandle, 'al_do_multiline_ustr');
  al_drain_audio_stream := GetProcAddress(aDLLHandle, 'al_drain_audio_stream');
  al_draw_arc := GetProcAddress(aDLLHandle, 'al_draw_arc');
  al_draw_bitmap := GetProcAddress(aDLLHandle, 'al_draw_bitmap');
  al_draw_bitmap_region := GetProcAddress(aDLLHandle, 'al_draw_bitmap_region');
  al_draw_circle := GetProcAddress(aDLLHandle, 'al_draw_circle');
  al_draw_ellipse := GetProcAddress(aDLLHandle, 'al_draw_ellipse');
  al_draw_elliptical_arc := GetProcAddress(aDLLHandle, 'al_draw_elliptical_arc');
  al_draw_filled_circle := GetProcAddress(aDLLHandle, 'al_draw_filled_circle');
  al_draw_filled_ellipse := GetProcAddress(aDLLHandle, 'al_draw_filled_ellipse');
  al_draw_filled_pieslice := GetProcAddress(aDLLHandle, 'al_draw_filled_pieslice');
  al_draw_filled_polygon := GetProcAddress(aDLLHandle, 'al_draw_filled_polygon');
  al_draw_filled_polygon_with_holes := GetProcAddress(aDLLHandle, 'al_draw_filled_polygon_with_holes');
  al_draw_filled_rectangle := GetProcAddress(aDLLHandle, 'al_draw_filled_rectangle');
  al_draw_filled_rounded_rectangle := GetProcAddress(aDLLHandle, 'al_draw_filled_rounded_rectangle');
  al_draw_filled_triangle := GetProcAddress(aDLLHandle, 'al_draw_filled_triangle');
  al_draw_glyph := GetProcAddress(aDLLHandle, 'al_draw_glyph');
  al_draw_indexed_buffer := GetProcAddress(aDLLHandle, 'al_draw_indexed_buffer');
  al_draw_indexed_prim := GetProcAddress(aDLLHandle, 'al_draw_indexed_prim');
  al_draw_justified_text := GetProcAddress(aDLLHandle, 'al_draw_justified_text');
  al_draw_justified_textf := GetProcAddress(aDLLHandle, 'al_draw_justified_textf');
  al_draw_justified_ustr := GetProcAddress(aDLLHandle, 'al_draw_justified_ustr');
  al_draw_line := GetProcAddress(aDLLHandle, 'al_draw_line');
  al_draw_multiline_text := GetProcAddress(aDLLHandle, 'al_draw_multiline_text');
  al_draw_multiline_textf := GetProcAddress(aDLLHandle, 'al_draw_multiline_textf');
  al_draw_multiline_ustr := GetProcAddress(aDLLHandle, 'al_draw_multiline_ustr');
  al_draw_pieslice := GetProcAddress(aDLLHandle, 'al_draw_pieslice');
  al_draw_pixel := GetProcAddress(aDLLHandle, 'al_draw_pixel');
  al_draw_polygon := GetProcAddress(aDLLHandle, 'al_draw_polygon');
  al_draw_polyline := GetProcAddress(aDLLHandle, 'al_draw_polyline');
  al_draw_prim := GetProcAddress(aDLLHandle, 'al_draw_prim');
  al_draw_rectangle := GetProcAddress(aDLLHandle, 'al_draw_rectangle');
  al_draw_ribbon := GetProcAddress(aDLLHandle, 'al_draw_ribbon');
  al_draw_rotated_bitmap := GetProcAddress(aDLLHandle, 'al_draw_rotated_bitmap');
  al_draw_rounded_rectangle := GetProcAddress(aDLLHandle, 'al_draw_rounded_rectangle');
  al_draw_scaled_bitmap := GetProcAddress(aDLLHandle, 'al_draw_scaled_bitmap');
  al_draw_scaled_rotated_bitmap := GetProcAddress(aDLLHandle, 'al_draw_scaled_rotated_bitmap');
  al_draw_soft_line := GetProcAddress(aDLLHandle, 'al_draw_soft_line');
  al_draw_soft_triangle := GetProcAddress(aDLLHandle, 'al_draw_soft_triangle');
  al_draw_spline := GetProcAddress(aDLLHandle, 'al_draw_spline');
  al_draw_text := GetProcAddress(aDLLHandle, 'al_draw_text');
  al_draw_textf := GetProcAddress(aDLLHandle, 'al_draw_textf');
  al_draw_tinted_bitmap := GetProcAddress(aDLLHandle, 'al_draw_tinted_bitmap');
  al_draw_tinted_bitmap_region := GetProcAddress(aDLLHandle, 'al_draw_tinted_bitmap_region');
  al_draw_tinted_rotated_bitmap := GetProcAddress(aDLLHandle, 'al_draw_tinted_rotated_bitmap');
  al_draw_tinted_scaled_bitmap := GetProcAddress(aDLLHandle, 'al_draw_tinted_scaled_bitmap');
  al_draw_tinted_scaled_rotated_bitmap := GetProcAddress(aDLLHandle, 'al_draw_tinted_scaled_rotated_bitmap');
  al_draw_tinted_scaled_rotated_bitmap_region := GetProcAddress(aDLLHandle, 'al_draw_tinted_scaled_rotated_bitmap_region');
  al_draw_triangle := GetProcAddress(aDLLHandle, 'al_draw_triangle');
  al_draw_ustr := GetProcAddress(aDLLHandle, 'al_draw_ustr');
  al_draw_vertex_buffer := GetProcAddress(aDLLHandle, 'al_draw_vertex_buffer');
  al_drop_next_event := GetProcAddress(aDLLHandle, 'al_drop_next_event');
  al_drop_path_tail := GetProcAddress(aDLLHandle, 'al_drop_path_tail');
  al_emit_user_event := GetProcAddress(aDLLHandle, 'al_emit_user_event');
  al_enable_menu_event_source := GetProcAddress(aDLLHandle, 'al_enable_menu_event_source');
  al_fclearerr := GetProcAddress(aDLLHandle, 'al_fclearerr');
  al_fclose := GetProcAddress(aDLLHandle, 'al_fclose');
  al_feof := GetProcAddress(aDLLHandle, 'al_feof');
  al_ferrmsg := GetProcAddress(aDLLHandle, 'al_ferrmsg');
  al_ferror := GetProcAddress(aDLLHandle, 'al_ferror');
  al_fflush := GetProcAddress(aDLLHandle, 'al_fflush');
  al_fget_ustr := GetProcAddress(aDLLHandle, 'al_fget_ustr');
  al_fgetc := GetProcAddress(aDLLHandle, 'al_fgetc');
  al_fgets := GetProcAddress(aDLLHandle, 'al_fgets');
  al_filename_exists := GetProcAddress(aDLLHandle, 'al_filename_exists');
  al_fill_silence := GetProcAddress(aDLLHandle, 'al_fill_silence');
  al_find_menu := GetProcAddress(aDLLHandle, 'al_find_menu');
  al_find_menu_item := GetProcAddress(aDLLHandle, 'al_find_menu_item');
  al_fixatan := GetProcAddress(aDLLHandle, 'al_fixatan');
  al_fixatan2 := GetProcAddress(aDLLHandle, 'al_fixatan2');
  al_fixhypot := GetProcAddress(aDLLHandle, 'al_fixhypot');
  al_fixsqrt := GetProcAddress(aDLLHandle, 'al_fixsqrt');
  al_flip_display := GetProcAddress(aDLLHandle, 'al_flip_display');
  al_flush_event_queue := GetProcAddress(aDLLHandle, 'al_flush_event_queue');
  al_fopen := GetProcAddress(aDLLHandle, 'al_fopen');
  al_fopen_fd := GetProcAddress(aDLLHandle, 'al_fopen_fd');
  al_fopen_interface := GetProcAddress(aDLLHandle, 'al_fopen_interface');
  al_fopen_slice := GetProcAddress(aDLLHandle, 'al_fopen_slice');
  al_for_each_fs_entry := GetProcAddress(aDLLHandle, 'al_for_each_fs_entry');
  al_fprintf := GetProcAddress(aDLLHandle, 'al_fprintf');
  al_fputc := GetProcAddress(aDLLHandle, 'al_fputc');
  al_fputs := GetProcAddress(aDLLHandle, 'al_fputs');
  al_fread := GetProcAddress(aDLLHandle, 'al_fread');
  al_fread16be := GetProcAddress(aDLLHandle, 'al_fread16be');
  al_fread16le := GetProcAddress(aDLLHandle, 'al_fread16le');
  al_fread32be := GetProcAddress(aDLLHandle, 'al_fread32be');
  al_fread32le := GetProcAddress(aDLLHandle, 'al_fread32le');
  al_free_with_context := GetProcAddress(aDLLHandle, 'al_free_with_context');
  al_fs_entry_exists := GetProcAddress(aDLLHandle, 'al_fs_entry_exists');
  al_fseek := GetProcAddress(aDLLHandle, 'al_fseek');
  al_fsize := GetProcAddress(aDLLHandle, 'al_fsize');
  al_ftell := GetProcAddress(aDLLHandle, 'al_ftell');
  al_fungetc := GetProcAddress(aDLLHandle, 'al_fungetc');
  al_fwrite := GetProcAddress(aDLLHandle, 'al_fwrite');
  al_fwrite16be := GetProcAddress(aDLLHandle, 'al_fwrite16be');
  al_fwrite16le := GetProcAddress(aDLLHandle, 'al_fwrite16le');
  al_fwrite32be := GetProcAddress(aDLLHandle, 'al_fwrite32be');
  al_fwrite32le := GetProcAddress(aDLLHandle, 'al_fwrite32le');
  al_get_allegro_acodec_version := GetProcAddress(aDLLHandle, 'al_get_allegro_acodec_version');
  al_get_allegro_audio_version := GetProcAddress(aDLLHandle, 'al_get_allegro_audio_version');
  al_get_allegro_color_version := GetProcAddress(aDLLHandle, 'al_get_allegro_color_version');
  al_get_allegro_font_version := GetProcAddress(aDLLHandle, 'al_get_allegro_font_version');
  al_get_allegro_image_version := GetProcAddress(aDLLHandle, 'al_get_allegro_image_version');
  al_get_allegro_memfile_version := GetProcAddress(aDLLHandle, 'al_get_allegro_memfile_version');
  al_get_allegro_native_dialog_version := GetProcAddress(aDLLHandle, 'al_get_allegro_native_dialog_version');
  al_get_allegro_physfs_version := GetProcAddress(aDLLHandle, 'al_get_allegro_physfs_version');
  al_get_allegro_primitives_version := GetProcAddress(aDLLHandle, 'al_get_allegro_primitives_version');
  al_get_allegro_ttf_version := GetProcAddress(aDLLHandle, 'al_get_allegro_ttf_version');
  al_get_allegro_version := GetProcAddress(aDLLHandle, 'al_get_allegro_version');
  al_get_allegro_video_version := GetProcAddress(aDLLHandle, 'al_get_allegro_video_version');
  al_get_app_name := GetProcAddress(aDLLHandle, 'al_get_app_name');
  al_get_audio_depth_size := GetProcAddress(aDLLHandle, 'al_get_audio_depth_size');
  al_get_audio_device_name := GetProcAddress(aDLLHandle, 'al_get_audio_device_name');
  al_get_audio_output_device := GetProcAddress(aDLLHandle, 'al_get_audio_output_device');
  al_get_audio_recorder_event := GetProcAddress(aDLLHandle, 'al_get_audio_recorder_event');
  al_get_audio_recorder_event_source := GetProcAddress(aDLLHandle, 'al_get_audio_recorder_event_source');
  al_get_audio_stream_attached := GetProcAddress(aDLLHandle, 'al_get_audio_stream_attached');
  al_get_audio_stream_channels := GetProcAddress(aDLLHandle, 'al_get_audio_stream_channels');
  al_get_audio_stream_depth := GetProcAddress(aDLLHandle, 'al_get_audio_stream_depth');
  al_get_audio_stream_event_source := GetProcAddress(aDLLHandle, 'al_get_audio_stream_event_source');
  al_get_audio_stream_fragment := GetProcAddress(aDLLHandle, 'al_get_audio_stream_fragment');
  al_get_audio_stream_fragments := GetProcAddress(aDLLHandle, 'al_get_audio_stream_fragments');
  al_get_audio_stream_frequency := GetProcAddress(aDLLHandle, 'al_get_audio_stream_frequency');
  al_get_audio_stream_gain := GetProcAddress(aDLLHandle, 'al_get_audio_stream_gain');
  al_get_audio_stream_length := GetProcAddress(aDLLHandle, 'al_get_audio_stream_length');
  al_get_audio_stream_length_secs := GetProcAddress(aDLLHandle, 'al_get_audio_stream_length_secs');
  al_get_audio_stream_pan := GetProcAddress(aDLLHandle, 'al_get_audio_stream_pan');
  al_get_audio_stream_played_samples := GetProcAddress(aDLLHandle, 'al_get_audio_stream_played_samples');
  al_get_audio_stream_playing := GetProcAddress(aDLLHandle, 'al_get_audio_stream_playing');
  al_get_audio_stream_playmode := GetProcAddress(aDLLHandle, 'al_get_audio_stream_playmode');
  al_get_audio_stream_position_secs := GetProcAddress(aDLLHandle, 'al_get_audio_stream_position_secs');
  al_get_audio_stream_speed := GetProcAddress(aDLLHandle, 'al_get_audio_stream_speed');
  al_get_available_audio_stream_fragments := GetProcAddress(aDLLHandle, 'al_get_available_audio_stream_fragments');
  al_get_backbuffer := GetProcAddress(aDLLHandle, 'al_get_backbuffer');
  al_get_bitmap_blend_color := GetProcAddress(aDLLHandle, 'al_get_bitmap_blend_color');
  al_get_bitmap_blender := GetProcAddress(aDLLHandle, 'al_get_bitmap_blender');
  al_get_bitmap_depth := GetProcAddress(aDLLHandle, 'al_get_bitmap_depth');
  al_get_bitmap_flags := GetProcAddress(aDLLHandle, 'al_get_bitmap_flags');
  al_get_bitmap_format := GetProcAddress(aDLLHandle, 'al_get_bitmap_format');
  al_get_bitmap_height := GetProcAddress(aDLLHandle, 'al_get_bitmap_height');
  al_get_bitmap_samples := GetProcAddress(aDLLHandle, 'al_get_bitmap_samples');
  al_get_bitmap_width := GetProcAddress(aDLLHandle, 'al_get_bitmap_width');
  al_get_bitmap_x := GetProcAddress(aDLLHandle, 'al_get_bitmap_x');
  al_get_bitmap_y := GetProcAddress(aDLLHandle, 'al_get_bitmap_y');
  al_get_blend_color := GetProcAddress(aDLLHandle, 'al_get_blend_color');
  al_get_blender := GetProcAddress(aDLLHandle, 'al_get_blender');
  al_get_channel_count := GetProcAddress(aDLLHandle, 'al_get_channel_count');
  al_get_clipboard_text := GetProcAddress(aDLLHandle, 'al_get_clipboard_text');
  al_get_clipping_rectangle := GetProcAddress(aDLLHandle, 'al_get_clipping_rectangle');
  al_get_config_value := GetProcAddress(aDLLHandle, 'al_get_config_value');
  al_get_cpu_count := GetProcAddress(aDLLHandle, 'al_get_cpu_count');
  al_get_current_directory := GetProcAddress(aDLLHandle, 'al_get_current_directory');
  al_get_current_display := GetProcAddress(aDLLHandle, 'al_get_current_display');
  al_get_current_inverse_transform := GetProcAddress(aDLLHandle, 'al_get_current_inverse_transform');
  al_get_current_projection_transform := GetProcAddress(aDLLHandle, 'al_get_current_projection_transform');
  al_get_current_transform := GetProcAddress(aDLLHandle, 'al_get_current_transform');
  al_get_default_menu_event_source := GetProcAddress(aDLLHandle, 'al_get_default_menu_event_source');
  al_get_default_mixer := GetProcAddress(aDLLHandle, 'al_get_default_mixer');
  al_get_default_shader_source := GetProcAddress(aDLLHandle, 'al_get_default_shader_source');
  al_get_default_voice := GetProcAddress(aDLLHandle, 'al_get_default_voice');
  al_get_display_event_source := GetProcAddress(aDLLHandle, 'al_get_display_event_source');
  al_get_display_flags := GetProcAddress(aDLLHandle, 'al_get_display_flags');
  al_get_display_format := GetProcAddress(aDLLHandle, 'al_get_display_format');
  al_get_display_height := GetProcAddress(aDLLHandle, 'al_get_display_height');
  al_get_display_menu := GetProcAddress(aDLLHandle, 'al_get_display_menu');
  al_get_display_mode := GetProcAddress(aDLLHandle, 'al_get_display_mode');
  al_get_display_option := GetProcAddress(aDLLHandle, 'al_get_display_option');
  al_get_display_orientation := GetProcAddress(aDLLHandle, 'al_get_display_orientation');
  al_get_display_refresh_rate := GetProcAddress(aDLLHandle, 'al_get_display_refresh_rate');
  al_get_display_width := GetProcAddress(aDLLHandle, 'al_get_display_width');
  al_get_errno := GetProcAddress(aDLLHandle, 'al_get_errno');
  al_get_event_source_data := GetProcAddress(aDLLHandle, 'al_get_event_source_data');
  al_get_fallback_font := GetProcAddress(aDLLHandle, 'al_get_fallback_font');
  al_get_file_userdata := GetProcAddress(aDLLHandle, 'al_get_file_userdata');
  al_get_first_config_entry := GetProcAddress(aDLLHandle, 'al_get_first_config_entry');
  al_get_first_config_section := GetProcAddress(aDLLHandle, 'al_get_first_config_section');
  al_get_font_ascent := GetProcAddress(aDLLHandle, 'al_get_font_ascent');
  al_get_font_descent := GetProcAddress(aDLLHandle, 'al_get_font_descent');
  al_get_font_line_height := GetProcAddress(aDLLHandle, 'al_get_font_line_height');
  al_get_font_ranges := GetProcAddress(aDLLHandle, 'al_get_font_ranges');
  al_get_fs_entry_atime := GetProcAddress(aDLLHandle, 'al_get_fs_entry_atime');
  al_get_fs_entry_ctime := GetProcAddress(aDLLHandle, 'al_get_fs_entry_ctime');
  al_get_fs_entry_mode := GetProcAddress(aDLLHandle, 'al_get_fs_entry_mode');
  al_get_fs_entry_mtime := GetProcAddress(aDLLHandle, 'al_get_fs_entry_mtime');
  al_get_fs_entry_name := GetProcAddress(aDLLHandle, 'al_get_fs_entry_name');
  al_get_fs_entry_size := GetProcAddress(aDLLHandle, 'al_get_fs_entry_size');
  al_get_fs_interface := GetProcAddress(aDLLHandle, 'al_get_fs_interface');
  al_get_glyph := GetProcAddress(aDLLHandle, 'al_get_glyph');
  al_get_glyph_advance := GetProcAddress(aDLLHandle, 'al_get_glyph_advance');
  al_get_glyph_dimensions := GetProcAddress(aDLLHandle, 'al_get_glyph_dimensions');
  al_get_glyph_width := GetProcAddress(aDLLHandle, 'al_get_glyph_width');
  al_get_haptic_autocenter := GetProcAddress(aDLLHandle, 'al_get_haptic_autocenter');
  al_get_haptic_capabilities := GetProcAddress(aDLLHandle, 'al_get_haptic_capabilities');
  al_get_haptic_effect_duration := GetProcAddress(aDLLHandle, 'al_get_haptic_effect_duration');
  al_get_haptic_from_display := GetProcAddress(aDLLHandle, 'al_get_haptic_from_display');
  al_get_haptic_from_joystick := GetProcAddress(aDLLHandle, 'al_get_haptic_from_joystick');
  al_get_haptic_from_keyboard := GetProcAddress(aDLLHandle, 'al_get_haptic_from_keyboard');
  al_get_haptic_from_mouse := GetProcAddress(aDLLHandle, 'al_get_haptic_from_mouse');
  al_get_haptic_from_touch_input := GetProcAddress(aDLLHandle, 'al_get_haptic_from_touch_input');
  al_get_haptic_gain := GetProcAddress(aDLLHandle, 'al_get_haptic_gain');
  al_get_index_buffer_size := GetProcAddress(aDLLHandle, 'al_get_index_buffer_size');
  al_get_joystick := GetProcAddress(aDLLHandle, 'al_get_joystick');
  al_get_joystick_active := GetProcAddress(aDLLHandle, 'al_get_joystick_active');
  al_get_joystick_axis_name := GetProcAddress(aDLLHandle, 'al_get_joystick_axis_name');
  al_get_joystick_button_name := GetProcAddress(aDLLHandle, 'al_get_joystick_button_name');
  al_get_joystick_event_source := GetProcAddress(aDLLHandle, 'al_get_joystick_event_source');
  al_get_joystick_name := GetProcAddress(aDLLHandle, 'al_get_joystick_name');
  al_get_joystick_num_axes := GetProcAddress(aDLLHandle, 'al_get_joystick_num_axes');
  al_get_joystick_num_buttons := GetProcAddress(aDLLHandle, 'al_get_joystick_num_buttons');
  al_get_joystick_num_sticks := GetProcAddress(aDLLHandle, 'al_get_joystick_num_sticks');
  al_get_joystick_state := GetProcAddress(aDLLHandle, 'al_get_joystick_state');
  al_get_joystick_stick_flags := GetProcAddress(aDLLHandle, 'al_get_joystick_stick_flags');
  al_get_joystick_stick_name := GetProcAddress(aDLLHandle, 'al_get_joystick_stick_name');
  al_get_keyboard_event_source := GetProcAddress(aDLLHandle, 'al_get_keyboard_event_source');
  al_get_keyboard_state := GetProcAddress(aDLLHandle, 'al_get_keyboard_state');
  al_get_max_haptic_effects := GetProcAddress(aDLLHandle, 'al_get_max_haptic_effects');
  al_get_menu_item_caption := GetProcAddress(aDLLHandle, 'al_get_menu_item_caption');
  al_get_menu_item_flags := GetProcAddress(aDLLHandle, 'al_get_menu_item_flags');
  al_get_menu_item_icon := GetProcAddress(aDLLHandle, 'al_get_menu_item_icon');
  al_get_mixer_attached := GetProcAddress(aDLLHandle, 'al_get_mixer_attached');
  al_get_mixer_channels := GetProcAddress(aDLLHandle, 'al_get_mixer_channels');
  al_get_mixer_depth := GetProcAddress(aDLLHandle, 'al_get_mixer_depth');
  al_get_mixer_frequency := GetProcAddress(aDLLHandle, 'al_get_mixer_frequency');
  al_get_mixer_gain := GetProcAddress(aDLLHandle, 'al_get_mixer_gain');
  al_get_mixer_playing := GetProcAddress(aDLLHandle, 'al_get_mixer_playing');
  al_get_mixer_quality := GetProcAddress(aDLLHandle, 'al_get_mixer_quality');
  al_get_monitor_dpi := GetProcAddress(aDLLHandle, 'al_get_monitor_dpi');
  al_get_monitor_info := GetProcAddress(aDLLHandle, 'al_get_monitor_info');
  al_get_monitor_refresh_rate := GetProcAddress(aDLLHandle, 'al_get_monitor_refresh_rate');
  al_get_mouse_cursor_position := GetProcAddress(aDLLHandle, 'al_get_mouse_cursor_position');
  al_get_mouse_emulation_mode := GetProcAddress(aDLLHandle, 'al_get_mouse_emulation_mode');
  al_get_mouse_event_source := GetProcAddress(aDLLHandle, 'al_get_mouse_event_source');
  al_get_mouse_num_axes := GetProcAddress(aDLLHandle, 'al_get_mouse_num_axes');
  al_get_mouse_num_buttons := GetProcAddress(aDLLHandle, 'al_get_mouse_num_buttons');
  al_get_mouse_state := GetProcAddress(aDLLHandle, 'al_get_mouse_state');
  al_get_mouse_state_axis := GetProcAddress(aDLLHandle, 'al_get_mouse_state_axis');
  al_get_mouse_wheel_precision := GetProcAddress(aDLLHandle, 'al_get_mouse_wheel_precision');
  al_get_native_file_dialog_count := GetProcAddress(aDLLHandle, 'al_get_native_file_dialog_count');
  al_get_native_file_dialog_path := GetProcAddress(aDLLHandle, 'al_get_native_file_dialog_path');
  al_get_native_text_log_event_source := GetProcAddress(aDLLHandle, 'al_get_native_text_log_event_source');
  al_get_new_bitmap_depth := GetProcAddress(aDLLHandle, 'al_get_new_bitmap_depth');
  al_get_new_bitmap_flags := GetProcAddress(aDLLHandle, 'al_get_new_bitmap_flags');
  al_get_new_bitmap_format := GetProcAddress(aDLLHandle, 'al_get_new_bitmap_format');
  al_get_new_bitmap_samples := GetProcAddress(aDLLHandle, 'al_get_new_bitmap_samples');
  al_get_new_bitmap_wrap := GetProcAddress(aDLLHandle, 'al_get_new_bitmap_wrap');
  al_get_new_display_adapter := GetProcAddress(aDLLHandle, 'al_get_new_display_adapter');
  al_get_new_display_flags := GetProcAddress(aDLLHandle, 'al_get_new_display_flags');
  al_get_new_display_option := GetProcAddress(aDLLHandle, 'al_get_new_display_option');
  al_get_new_display_refresh_rate := GetProcAddress(aDLLHandle, 'al_get_new_display_refresh_rate');
  al_get_new_file_interface := GetProcAddress(aDLLHandle, 'al_get_new_file_interface');
  al_get_new_window_position := GetProcAddress(aDLLHandle, 'al_get_new_window_position');
  al_get_new_window_title := GetProcAddress(aDLLHandle, 'al_get_new_window_title');
  al_get_next_config_entry := GetProcAddress(aDLLHandle, 'al_get_next_config_entry');
  al_get_next_config_section := GetProcAddress(aDLLHandle, 'al_get_next_config_section');
  al_get_next_event := GetProcAddress(aDLLHandle, 'al_get_next_event');
  al_get_num_audio_output_devices := GetProcAddress(aDLLHandle, 'al_get_num_audio_output_devices');
  al_get_num_display_modes := GetProcAddress(aDLLHandle, 'al_get_num_display_modes');
  al_get_num_joysticks := GetProcAddress(aDLLHandle, 'al_get_num_joysticks');
  al_get_num_video_adapters := GetProcAddress(aDLLHandle, 'al_get_num_video_adapters');
  al_get_org_name := GetProcAddress(aDLLHandle, 'al_get_org_name');
  al_get_parent_bitmap := GetProcAddress(aDLLHandle, 'al_get_parent_bitmap');
  al_get_path_basename := GetProcAddress(aDLLHandle, 'al_get_path_basename');
  al_get_path_component := GetProcAddress(aDLLHandle, 'al_get_path_component');
  al_get_path_drive := GetProcAddress(aDLLHandle, 'al_get_path_drive');
  al_get_path_extension := GetProcAddress(aDLLHandle, 'al_get_path_extension');
  al_get_path_filename := GetProcAddress(aDLLHandle, 'al_get_path_filename');
  al_get_path_num_components := GetProcAddress(aDLLHandle, 'al_get_path_num_components');
  al_get_path_tail := GetProcAddress(aDLLHandle, 'al_get_path_tail');
  al_get_pixel := GetProcAddress(aDLLHandle, 'al_get_pixel');
  al_get_pixel_block_height := GetProcAddress(aDLLHandle, 'al_get_pixel_block_height');
  al_get_pixel_block_size := GetProcAddress(aDLLHandle, 'al_get_pixel_block_size');
  al_get_pixel_block_width := GetProcAddress(aDLLHandle, 'al_get_pixel_block_width');
  al_get_pixel_format_bits := GetProcAddress(aDLLHandle, 'al_get_pixel_format_bits');
  al_get_pixel_size := GetProcAddress(aDLLHandle, 'al_get_pixel_size');
  al_get_ram_size := GetProcAddress(aDLLHandle, 'al_get_ram_size');
  al_get_sample := GetProcAddress(aDLLHandle, 'al_get_sample');
  al_get_sample_channels := GetProcAddress(aDLLHandle, 'al_get_sample_channels');
  al_get_sample_data := GetProcAddress(aDLLHandle, 'al_get_sample_data');
  al_get_sample_depth := GetProcAddress(aDLLHandle, 'al_get_sample_depth');
  al_get_sample_frequency := GetProcAddress(aDLLHandle, 'al_get_sample_frequency');
  al_get_sample_instance_attached := GetProcAddress(aDLLHandle, 'al_get_sample_instance_attached');
  al_get_sample_instance_channels := GetProcAddress(aDLLHandle, 'al_get_sample_instance_channels');
  al_get_sample_instance_depth := GetProcAddress(aDLLHandle, 'al_get_sample_instance_depth');
  al_get_sample_instance_frequency := GetProcAddress(aDLLHandle, 'al_get_sample_instance_frequency');
  al_get_sample_instance_gain := GetProcAddress(aDLLHandle, 'al_get_sample_instance_gain');
  al_get_sample_instance_length := GetProcAddress(aDLLHandle, 'al_get_sample_instance_length');
  al_get_sample_instance_pan := GetProcAddress(aDLLHandle, 'al_get_sample_instance_pan');
  al_get_sample_instance_playing := GetProcAddress(aDLLHandle, 'al_get_sample_instance_playing');
  al_get_sample_instance_playmode := GetProcAddress(aDLLHandle, 'al_get_sample_instance_playmode');
  al_get_sample_instance_position := GetProcAddress(aDLLHandle, 'al_get_sample_instance_position');
  al_get_sample_instance_speed := GetProcAddress(aDLLHandle, 'al_get_sample_instance_speed');
  al_get_sample_instance_time := GetProcAddress(aDLLHandle, 'al_get_sample_instance_time');
  al_get_sample_length := GetProcAddress(aDLLHandle, 'al_get_sample_length');
  al_get_separate_bitmap_blender := GetProcAddress(aDLLHandle, 'al_get_separate_bitmap_blender');
  al_get_separate_blender := GetProcAddress(aDLLHandle, 'al_get_separate_blender');
  al_get_shader_log := GetProcAddress(aDLLHandle, 'al_get_shader_log');
  al_get_shader_platform := GetProcAddress(aDLLHandle, 'al_get_shader_platform');
  al_get_standard_path := GetProcAddress(aDLLHandle, 'al_get_standard_path');
  al_get_system_config := GetProcAddress(aDLLHandle, 'al_get_system_config');
  al_get_system_driver := GetProcAddress(aDLLHandle, 'al_get_system_driver');
  al_get_system_id := GetProcAddress(aDLLHandle, 'al_get_system_id');
  al_get_target_bitmap := GetProcAddress(aDLLHandle, 'al_get_target_bitmap');
  al_get_text_dimensions := GetProcAddress(aDLLHandle, 'al_get_text_dimensions');
  al_get_text_width := GetProcAddress(aDLLHandle, 'al_get_text_width');
  al_get_thread_should_stop := GetProcAddress(aDLLHandle, 'al_get_thread_should_stop');
  al_get_time := GetProcAddress(aDLLHandle, 'al_get_time');
  al_get_timer_count := GetProcAddress(aDLLHandle, 'al_get_timer_count');
  al_get_timer_event_source := GetProcAddress(aDLLHandle, 'al_get_timer_event_source');
  al_get_timer_speed := GetProcAddress(aDLLHandle, 'al_get_timer_speed');
  al_get_timer_started := GetProcAddress(aDLLHandle, 'al_get_timer_started');
  al_get_touch_input_event_source := GetProcAddress(aDLLHandle, 'al_get_touch_input_event_source');
  al_get_touch_input_mouse_emulation_event_source := GetProcAddress(aDLLHandle, 'al_get_touch_input_mouse_emulation_event_source');
  al_get_touch_input_state := GetProcAddress(aDLLHandle, 'al_get_touch_input_state');
  al_get_ustr_dimensions := GetProcAddress(aDLLHandle, 'al_get_ustr_dimensions');
  al_get_ustr_width := GetProcAddress(aDLLHandle, 'al_get_ustr_width');
  al_get_vertex_buffer_size := GetProcAddress(aDLLHandle, 'al_get_vertex_buffer_size');
  al_get_video_audio_rate := GetProcAddress(aDLLHandle, 'al_get_video_audio_rate');
  al_get_video_event_source := GetProcAddress(aDLLHandle, 'al_get_video_event_source');
  al_get_video_fps := GetProcAddress(aDLLHandle, 'al_get_video_fps');
  al_get_video_frame := GetProcAddress(aDLLHandle, 'al_get_video_frame');
  al_get_video_position := GetProcAddress(aDLLHandle, 'al_get_video_position');
  al_get_video_scaled_height := GetProcAddress(aDLLHandle, 'al_get_video_scaled_height');
  al_get_video_scaled_width := GetProcAddress(aDLLHandle, 'al_get_video_scaled_width');
  al_get_voice_channels := GetProcAddress(aDLLHandle, 'al_get_voice_channels');
  al_get_voice_depth := GetProcAddress(aDLLHandle, 'al_get_voice_depth');
  al_get_voice_frequency := GetProcAddress(aDLLHandle, 'al_get_voice_frequency');
  al_get_voice_playing := GetProcAddress(aDLLHandle, 'al_get_voice_playing');
  al_get_voice_position := GetProcAddress(aDLLHandle, 'al_get_voice_position');
  al_get_win_window_handle := GetProcAddress(aDLLHandle, 'al_get_win_window_handle');
  al_get_window_constraints := GetProcAddress(aDLLHandle, 'al_get_window_constraints');
  al_get_window_position := GetProcAddress(aDLLHandle, 'al_get_window_position');
  al_grab_font_from_bitmap := GetProcAddress(aDLLHandle, 'al_grab_font_from_bitmap');
  al_grab_mouse := GetProcAddress(aDLLHandle, 'al_grab_mouse');
  al_hide_mouse_cursor := GetProcAddress(aDLLHandle, 'al_hide_mouse_cursor');
  al_hold_bitmap_drawing := GetProcAddress(aDLLHandle, 'al_hold_bitmap_drawing');
  al_horizontal_shear_transform := GetProcAddress(aDLLHandle, 'al_horizontal_shear_transform');
  al_identify_bitmap := GetProcAddress(aDLLHandle, 'al_identify_bitmap');
  al_identify_bitmap_f := GetProcAddress(aDLLHandle, 'al_identify_bitmap_f');
  al_identify_sample := GetProcAddress(aDLLHandle, 'al_identify_sample');
  al_identify_sample_f := GetProcAddress(aDLLHandle, 'al_identify_sample_f');
  al_identify_video := GetProcAddress(aDLLHandle, 'al_identify_video');
  al_identify_video_f := GetProcAddress(aDLLHandle, 'al_identify_video_f');
  al_identity_transform := GetProcAddress(aDLLHandle, 'al_identity_transform');
  al_inhibit_screensaver := GetProcAddress(aDLLHandle, 'al_inhibit_screensaver');
  al_init_acodec_addon := GetProcAddress(aDLLHandle, 'al_init_acodec_addon');
  al_init_font_addon := GetProcAddress(aDLLHandle, 'al_init_font_addon');
  al_init_image_addon := GetProcAddress(aDLLHandle, 'al_init_image_addon');
  al_init_native_dialog_addon := GetProcAddress(aDLLHandle, 'al_init_native_dialog_addon');
  al_init_primitives_addon := GetProcAddress(aDLLHandle, 'al_init_primitives_addon');
  al_init_timeout := GetProcAddress(aDLLHandle, 'al_init_timeout');
  al_init_ttf_addon := GetProcAddress(aDLLHandle, 'al_init_ttf_addon');
  al_init_user_event_source := GetProcAddress(aDLLHandle, 'al_init_user_event_source');
  al_init_video_addon := GetProcAddress(aDLLHandle, 'al_init_video_addon');
  al_insert_menu_item := GetProcAddress(aDLLHandle, 'al_insert_menu_item');
  al_insert_path_component := GetProcAddress(aDLLHandle, 'al_insert_path_component');
  al_install_audio := GetProcAddress(aDLLHandle, 'al_install_audio');
  al_install_haptic := GetProcAddress(aDLLHandle, 'al_install_haptic');
  al_install_joystick := GetProcAddress(aDLLHandle, 'al_install_joystick');
  al_install_keyboard := GetProcAddress(aDLLHandle, 'al_install_keyboard');
  al_install_mouse := GetProcAddress(aDLLHandle, 'al_install_mouse');
  al_install_system := GetProcAddress(aDLLHandle, 'al_install_system');
  al_install_touch_input := GetProcAddress(aDLLHandle, 'al_install_touch_input');
  al_invert_transform := GetProcAddress(aDLLHandle, 'al_invert_transform');
  al_is_acodec_addon_initialized := GetProcAddress(aDLLHandle, 'al_is_acodec_addon_initialized');
  al_is_audio_installed := GetProcAddress(aDLLHandle, 'al_is_audio_installed');
  al_is_audio_recorder_recording := GetProcAddress(aDLLHandle, 'al_is_audio_recorder_recording');
  al_is_bitmap_drawing_held := GetProcAddress(aDLLHandle, 'al_is_bitmap_drawing_held');
  al_is_bitmap_locked := GetProcAddress(aDLLHandle, 'al_is_bitmap_locked');
  al_is_color_valid := GetProcAddress(aDLLHandle, 'al_is_color_valid');
  al_is_compatible_bitmap := GetProcAddress(aDLLHandle, 'al_is_compatible_bitmap');
  al_is_display_haptic := GetProcAddress(aDLLHandle, 'al_is_display_haptic');
  al_is_event_queue_empty := GetProcAddress(aDLLHandle, 'al_is_event_queue_empty');
  al_is_event_queue_paused := GetProcAddress(aDLLHandle, 'al_is_event_queue_paused');
  al_is_event_source_registered := GetProcAddress(aDLLHandle, 'al_is_event_source_registered');
  al_is_font_addon_initialized := GetProcAddress(aDLLHandle, 'al_is_font_addon_initialized');
  al_is_haptic_active := GetProcAddress(aDLLHandle, 'al_is_haptic_active');
  al_is_haptic_capable := GetProcAddress(aDLLHandle, 'al_is_haptic_capable');
  al_is_haptic_effect_ok := GetProcAddress(aDLLHandle, 'al_is_haptic_effect_ok');
  al_is_haptic_effect_playing := GetProcAddress(aDLLHandle, 'al_is_haptic_effect_playing');
  al_is_haptic_installed := GetProcAddress(aDLLHandle, 'al_is_haptic_installed');
  al_is_image_addon_initialized := GetProcAddress(aDLLHandle, 'al_is_image_addon_initialized');
  al_is_joystick_haptic := GetProcAddress(aDLLHandle, 'al_is_joystick_haptic');
  al_is_joystick_installed := GetProcAddress(aDLLHandle, 'al_is_joystick_installed');
  al_is_keyboard_haptic := GetProcAddress(aDLLHandle, 'al_is_keyboard_haptic');
  al_is_keyboard_installed := GetProcAddress(aDLLHandle, 'al_is_keyboard_installed');
  al_is_mouse_haptic := GetProcAddress(aDLLHandle, 'al_is_mouse_haptic');
  al_is_mouse_installed := GetProcAddress(aDLLHandle, 'al_is_mouse_installed');
  al_is_native_dialog_addon_initialized := GetProcAddress(aDLLHandle, 'al_is_native_dialog_addon_initialized');
  al_is_primitives_addon_initialized := GetProcAddress(aDLLHandle, 'al_is_primitives_addon_initialized');
  al_is_sub_bitmap := GetProcAddress(aDLLHandle, 'al_is_sub_bitmap');
  al_is_system_installed := GetProcAddress(aDLLHandle, 'al_is_system_installed');
  al_is_touch_input_haptic := GetProcAddress(aDLLHandle, 'al_is_touch_input_haptic');
  al_is_touch_input_installed := GetProcAddress(aDLLHandle, 'al_is_touch_input_installed');
  al_is_ttf_addon_initialized := GetProcAddress(aDLLHandle, 'al_is_ttf_addon_initialized');
  al_is_video_addon_initialized := GetProcAddress(aDLLHandle, 'al_is_video_addon_initialized');
  al_is_video_playing := GetProcAddress(aDLLHandle, 'al_is_video_playing');
  al_join_paths := GetProcAddress(aDLLHandle, 'al_join_paths');
  al_join_thread := GetProcAddress(aDLLHandle, 'al_join_thread');
  al_key_down := GetProcAddress(aDLLHandle, 'al_key_down');
  al_keycode_to_name := GetProcAddress(aDLLHandle, 'al_keycode_to_name');
  al_load_audio_stream := GetProcAddress(aDLLHandle, 'al_load_audio_stream');
  al_load_audio_stream_f := GetProcAddress(aDLLHandle, 'al_load_audio_stream_f');
  al_load_bitmap := GetProcAddress(aDLLHandle, 'al_load_bitmap');
  al_load_bitmap_f := GetProcAddress(aDLLHandle, 'al_load_bitmap_f');
  al_load_bitmap_flags := GetProcAddress(aDLLHandle, 'al_load_bitmap_flags');
  al_load_bitmap_flags_f := GetProcAddress(aDLLHandle, 'al_load_bitmap_flags_f');
  al_load_bitmap_font := GetProcAddress(aDLLHandle, 'al_load_bitmap_font');
  al_load_bitmap_font_flags := GetProcAddress(aDLLHandle, 'al_load_bitmap_font_flags');
  al_load_config_file := GetProcAddress(aDLLHandle, 'al_load_config_file');
  al_load_config_file_f := GetProcAddress(aDLLHandle, 'al_load_config_file_f');
  al_load_font := GetProcAddress(aDLLHandle, 'al_load_font');
  al_load_sample := GetProcAddress(aDLLHandle, 'al_load_sample');
  al_load_sample_f := GetProcAddress(aDLLHandle, 'al_load_sample_f');
  al_load_ttf_font := GetProcAddress(aDLLHandle, 'al_load_ttf_font');
  al_load_ttf_font_f := GetProcAddress(aDLLHandle, 'al_load_ttf_font_f');
  al_load_ttf_font_stretch := GetProcAddress(aDLLHandle, 'al_load_ttf_font_stretch');
  al_load_ttf_font_stretch_f := GetProcAddress(aDLLHandle, 'al_load_ttf_font_stretch_f');
  al_lock_bitmap := GetProcAddress(aDLLHandle, 'al_lock_bitmap');
  al_lock_bitmap_blocked := GetProcAddress(aDLLHandle, 'al_lock_bitmap_blocked');
  al_lock_bitmap_region := GetProcAddress(aDLLHandle, 'al_lock_bitmap_region');
  al_lock_bitmap_region_blocked := GetProcAddress(aDLLHandle, 'al_lock_bitmap_region_blocked');
  al_lock_index_buffer := GetProcAddress(aDLLHandle, 'al_lock_index_buffer');
  al_lock_mutex := GetProcAddress(aDLLHandle, 'al_lock_mutex');
  al_lock_sample_id := GetProcAddress(aDLLHandle, 'al_lock_sample_id');
  al_lock_vertex_buffer := GetProcAddress(aDLLHandle, 'al_lock_vertex_buffer');
  al_make_directory := GetProcAddress(aDLLHandle, 'al_make_directory');
  al_make_path_canonical := GetProcAddress(aDLLHandle, 'al_make_path_canonical');
  al_make_temp_file := GetProcAddress(aDLLHandle, 'al_make_temp_file');
  al_malloc_with_context := GetProcAddress(aDLLHandle, 'al_malloc_with_context');
  al_map_rgb := GetProcAddress(aDLLHandle, 'al_map_rgb');
  al_map_rgb_f := GetProcAddress(aDLLHandle, 'al_map_rgb_f');
  al_map_rgba := GetProcAddress(aDLLHandle, 'al_map_rgba');
  al_map_rgba_f := GetProcAddress(aDLLHandle, 'al_map_rgba_f');
  al_merge_config := GetProcAddress(aDLLHandle, 'al_merge_config');
  al_merge_config_into := GetProcAddress(aDLLHandle, 'al_merge_config_into');
  al_mouse_button_down := GetProcAddress(aDLLHandle, 'al_mouse_button_down');
  al_open_directory := GetProcAddress(aDLLHandle, 'al_open_directory');
  al_open_fs_entry := GetProcAddress(aDLLHandle, 'al_open_fs_entry');
  al_open_memfile := GetProcAddress(aDLLHandle, 'al_open_memfile');
  al_open_native_text_log := GetProcAddress(aDLLHandle, 'al_open_native_text_log');
  al_open_video := GetProcAddress(aDLLHandle, 'al_open_video');
  al_orthographic_transform := GetProcAddress(aDLLHandle, 'al_orthographic_transform');
  al_path_cstr := GetProcAddress(aDLLHandle, 'al_path_cstr');
  al_path_ustr := GetProcAddress(aDLLHandle, 'al_path_ustr');
  al_pause_event_queue := GetProcAddress(aDLLHandle, 'al_pause_event_queue');
  al_peek_next_event := GetProcAddress(aDLLHandle, 'al_peek_next_event');
  al_perspective_transform := GetProcAddress(aDLLHandle, 'al_perspective_transform');
  al_play_haptic_effect := GetProcAddress(aDLLHandle, 'al_play_haptic_effect');
  al_play_sample := GetProcAddress(aDLLHandle, 'al_play_sample');
  al_play_sample_instance := GetProcAddress(aDLLHandle, 'al_play_sample_instance');
  al_popup_menu := GetProcAddress(aDLLHandle, 'al_popup_menu');
  al_premul_rgba := GetProcAddress(aDLLHandle, 'al_premul_rgba');
  al_premul_rgba_f := GetProcAddress(aDLLHandle, 'al_premul_rgba_f');
  al_put_blended_pixel := GetProcAddress(aDLLHandle, 'al_put_blended_pixel');
  al_put_pixel := GetProcAddress(aDLLHandle, 'al_put_pixel');
  al_read_directory := GetProcAddress(aDLLHandle, 'al_read_directory');
  al_realloc_with_context := GetProcAddress(aDLLHandle, 'al_realloc_with_context');
  al_rebase_path := GetProcAddress(aDLLHandle, 'al_rebase_path');
  al_reconfigure_joysticks := GetProcAddress(aDLLHandle, 'al_reconfigure_joysticks');
  al_ref_buffer := GetProcAddress(aDLLHandle, 'al_ref_buffer');
  al_ref_cstr := GetProcAddress(aDLLHandle, 'al_ref_cstr');
  al_ref_ustr := GetProcAddress(aDLLHandle, 'al_ref_ustr');
  al_register_assert_handler := GetProcAddress(aDLLHandle, 'al_register_assert_handler');
  al_register_audio_stream_loader := GetProcAddress(aDLLHandle, 'al_register_audio_stream_loader');
  al_register_audio_stream_loader_f := GetProcAddress(aDLLHandle, 'al_register_audio_stream_loader_f');
  al_register_bitmap_identifier := GetProcAddress(aDLLHandle, 'al_register_bitmap_identifier');
  al_register_bitmap_loader := GetProcAddress(aDLLHandle, 'al_register_bitmap_loader');
  al_register_bitmap_loader_f := GetProcAddress(aDLLHandle, 'al_register_bitmap_loader_f');
  al_register_bitmap_saver := GetProcAddress(aDLLHandle, 'al_register_bitmap_saver');
  al_register_bitmap_saver_f := GetProcAddress(aDLLHandle, 'al_register_bitmap_saver_f');
  al_register_event_source := GetProcAddress(aDLLHandle, 'al_register_event_source');
  al_register_font_loader := GetProcAddress(aDLLHandle, 'al_register_font_loader');
  al_register_sample_identifier := GetProcAddress(aDLLHandle, 'al_register_sample_identifier');
  al_register_sample_loader := GetProcAddress(aDLLHandle, 'al_register_sample_loader');
  al_register_sample_loader_f := GetProcAddress(aDLLHandle, 'al_register_sample_loader_f');
  al_register_sample_saver := GetProcAddress(aDLLHandle, 'al_register_sample_saver');
  al_register_sample_saver_f := GetProcAddress(aDLLHandle, 'al_register_sample_saver_f');
  al_register_trace_handler := GetProcAddress(aDLLHandle, 'al_register_trace_handler');
  al_release_haptic := GetProcAddress(aDLLHandle, 'al_release_haptic');
  al_release_haptic_effect := GetProcAddress(aDLLHandle, 'al_release_haptic_effect');
  al_release_joystick := GetProcAddress(aDLLHandle, 'al_release_joystick');
  al_remove_config_key := GetProcAddress(aDLLHandle, 'al_remove_config_key');
  al_remove_config_section := GetProcAddress(aDLLHandle, 'al_remove_config_section');
  al_remove_display_menu := GetProcAddress(aDLLHandle, 'al_remove_display_menu');
  al_remove_filename := GetProcAddress(aDLLHandle, 'al_remove_filename');
  al_remove_fs_entry := GetProcAddress(aDLLHandle, 'al_remove_fs_entry');
  al_remove_menu_item := GetProcAddress(aDLLHandle, 'al_remove_menu_item');
  al_remove_path_component := GetProcAddress(aDLLHandle, 'al_remove_path_component');
  al_reparent_bitmap := GetProcAddress(aDLLHandle, 'al_reparent_bitmap');
  al_replace_path_component := GetProcAddress(aDLLHandle, 'al_replace_path_component');
  al_reserve_samples := GetProcAddress(aDLLHandle, 'al_reserve_samples');
  al_reset_bitmap_blender := GetProcAddress(aDLLHandle, 'al_reset_bitmap_blender');
  al_reset_clipping_rectangle := GetProcAddress(aDLLHandle, 'al_reset_clipping_rectangle');
  al_reset_new_display_options := GetProcAddress(aDLLHandle, 'al_reset_new_display_options');
  al_resize_display := GetProcAddress(aDLLHandle, 'al_resize_display');
  al_rest := GetProcAddress(aDLLHandle, 'al_rest');
  al_restore_default_mixer := GetProcAddress(aDLLHandle, 'al_restore_default_mixer');
  al_restore_state := GetProcAddress(aDLLHandle, 'al_restore_state');
  al_resume_timer := GetProcAddress(aDLLHandle, 'al_resume_timer');
  al_rewind_audio_stream := GetProcAddress(aDLLHandle, 'al_rewind_audio_stream');
  al_rotate_transform := GetProcAddress(aDLLHandle, 'al_rotate_transform');
  al_rotate_transform_3d := GetProcAddress(aDLLHandle, 'al_rotate_transform_3d');
  al_rumble_haptic := GetProcAddress(aDLLHandle, 'al_rumble_haptic');
  al_run_detached_thread := GetProcAddress(aDLLHandle, 'al_run_detached_thread');
  al_run_main := GetProcAddress(aDLLHandle, 'al_run_main');
  al_save_bitmap := GetProcAddress(aDLLHandle, 'al_save_bitmap');
  al_save_bitmap_f := GetProcAddress(aDLLHandle, 'al_save_bitmap_f');
  al_save_config_file := GetProcAddress(aDLLHandle, 'al_save_config_file');
  al_save_config_file_f := GetProcAddress(aDLLHandle, 'al_save_config_file_f');
  al_save_sample := GetProcAddress(aDLLHandle, 'al_save_sample');
  al_save_sample_f := GetProcAddress(aDLLHandle, 'al_save_sample_f');
  al_scale_transform := GetProcAddress(aDLLHandle, 'al_scale_transform');
  al_scale_transform_3d := GetProcAddress(aDLLHandle, 'al_scale_transform_3d');
  al_seek_audio_stream_secs := GetProcAddress(aDLLHandle, 'al_seek_audio_stream_secs');
  al_seek_video := GetProcAddress(aDLLHandle, 'al_seek_video');
  al_set_app_name := GetProcAddress(aDLLHandle, 'al_set_app_name');
  al_set_audio_stream_channel_matrix := GetProcAddress(aDLLHandle, 'al_set_audio_stream_channel_matrix');
  al_set_audio_stream_fragment := GetProcAddress(aDLLHandle, 'al_set_audio_stream_fragment');
  al_set_audio_stream_gain := GetProcAddress(aDLLHandle, 'al_set_audio_stream_gain');
  al_set_audio_stream_loop_secs := GetProcAddress(aDLLHandle, 'al_set_audio_stream_loop_secs');
  al_set_audio_stream_pan := GetProcAddress(aDLLHandle, 'al_set_audio_stream_pan');
  al_set_audio_stream_playing := GetProcAddress(aDLLHandle, 'al_set_audio_stream_playing');
  al_set_audio_stream_playmode := GetProcAddress(aDLLHandle, 'al_set_audio_stream_playmode');
  al_set_audio_stream_speed := GetProcAddress(aDLLHandle, 'al_set_audio_stream_speed');
  al_set_bitmap_blend_color := GetProcAddress(aDLLHandle, 'al_set_bitmap_blend_color');
  al_set_bitmap_blender := GetProcAddress(aDLLHandle, 'al_set_bitmap_blender');
  al_set_blend_color := GetProcAddress(aDLLHandle, 'al_set_blend_color');
  al_set_blender := GetProcAddress(aDLLHandle, 'al_set_blender');
  al_set_clipboard_text := GetProcAddress(aDLLHandle, 'al_set_clipboard_text');
  al_set_clipping_rectangle := GetProcAddress(aDLLHandle, 'al_set_clipping_rectangle');
  al_set_config_value := GetProcAddress(aDLLHandle, 'al_set_config_value');
  al_set_default_mixer := GetProcAddress(aDLLHandle, 'al_set_default_mixer');
  al_set_default_voice := GetProcAddress(aDLLHandle, 'al_set_default_voice');
  al_set_display_flag := GetProcAddress(aDLLHandle, 'al_set_display_flag');
  al_set_display_icon := GetProcAddress(aDLLHandle, 'al_set_display_icon');
  al_set_display_icons := GetProcAddress(aDLLHandle, 'al_set_display_icons');
  al_set_display_menu := GetProcAddress(aDLLHandle, 'al_set_display_menu');
  al_set_display_option := GetProcAddress(aDLLHandle, 'al_set_display_option');
  al_set_errno := GetProcAddress(aDLLHandle, 'al_set_errno');
  al_set_event_source_data := GetProcAddress(aDLLHandle, 'al_set_event_source_data');
  al_set_exe_name := GetProcAddress(aDLLHandle, 'al_set_exe_name');
  al_set_fallback_font := GetProcAddress(aDLLHandle, 'al_set_fallback_font');
  al_set_fs_interface := GetProcAddress(aDLLHandle, 'al_set_fs_interface');
  al_set_haptic_autocenter := GetProcAddress(aDLLHandle, 'al_set_haptic_autocenter');
  al_set_haptic_gain := GetProcAddress(aDLLHandle, 'al_set_haptic_gain');
  al_set_keyboard_leds := GetProcAddress(aDLLHandle, 'al_set_keyboard_leds');
  al_set_memory_interface := GetProcAddress(aDLLHandle, 'al_set_memory_interface');
  al_set_menu_item_caption := GetProcAddress(aDLLHandle, 'al_set_menu_item_caption');
  al_set_menu_item_flags := GetProcAddress(aDLLHandle, 'al_set_menu_item_flags');
  al_set_menu_item_icon := GetProcAddress(aDLLHandle, 'al_set_menu_item_icon');
  al_set_mixer_frequency := GetProcAddress(aDLLHandle, 'al_set_mixer_frequency');
  al_set_mixer_gain := GetProcAddress(aDLLHandle, 'al_set_mixer_gain');
  al_set_mixer_playing := GetProcAddress(aDLLHandle, 'al_set_mixer_playing');
  al_set_mixer_postprocess_callback := GetProcAddress(aDLLHandle, 'al_set_mixer_postprocess_callback');
  al_set_mixer_quality := GetProcAddress(aDLLHandle, 'al_set_mixer_quality');
  al_set_mouse_axis := GetProcAddress(aDLLHandle, 'al_set_mouse_axis');
  al_set_mouse_cursor := GetProcAddress(aDLLHandle, 'al_set_mouse_cursor');
  al_set_mouse_emulation_mode := GetProcAddress(aDLLHandle, 'al_set_mouse_emulation_mode');
  al_set_mouse_w := GetProcAddress(aDLLHandle, 'al_set_mouse_w');
  al_set_mouse_wheel_precision := GetProcAddress(aDLLHandle, 'al_set_mouse_wheel_precision');
  al_set_mouse_xy := GetProcAddress(aDLLHandle, 'al_set_mouse_xy');
  al_set_mouse_z := GetProcAddress(aDLLHandle, 'al_set_mouse_z');
  al_set_new_bitmap_depth := GetProcAddress(aDLLHandle, 'al_set_new_bitmap_depth');
  al_set_new_bitmap_flags := GetProcAddress(aDLLHandle, 'al_set_new_bitmap_flags');
  al_set_new_bitmap_format := GetProcAddress(aDLLHandle, 'al_set_new_bitmap_format');
  al_set_new_bitmap_samples := GetProcAddress(aDLLHandle, 'al_set_new_bitmap_samples');
  al_set_new_bitmap_wrap := GetProcAddress(aDLLHandle, 'al_set_new_bitmap_wrap');
  al_set_new_display_adapter := GetProcAddress(aDLLHandle, 'al_set_new_display_adapter');
  al_set_new_display_flags := GetProcAddress(aDLLHandle, 'al_set_new_display_flags');
  al_set_new_display_option := GetProcAddress(aDLLHandle, 'al_set_new_display_option');
  al_set_new_display_refresh_rate := GetProcAddress(aDLLHandle, 'al_set_new_display_refresh_rate');
  al_set_new_file_interface := GetProcAddress(aDLLHandle, 'al_set_new_file_interface');
  al_set_new_window_position := GetProcAddress(aDLLHandle, 'al_set_new_window_position');
  al_set_new_window_title := GetProcAddress(aDLLHandle, 'al_set_new_window_title');
  al_set_org_name := GetProcAddress(aDLLHandle, 'al_set_org_name');
  al_set_path_drive := GetProcAddress(aDLLHandle, 'al_set_path_drive');
  al_set_path_extension := GetProcAddress(aDLLHandle, 'al_set_path_extension');
  al_set_path_filename := GetProcAddress(aDLLHandle, 'al_set_path_filename');
  al_set_physfs_file_interface := GetProcAddress(aDLLHandle, 'al_set_physfs_file_interface');
  al_set_render_state := GetProcAddress(aDLLHandle, 'al_set_render_state');
  al_set_sample := GetProcAddress(aDLLHandle, 'al_set_sample');
  al_set_sample_instance_channel_matrix := GetProcAddress(aDLLHandle, 'al_set_sample_instance_channel_matrix');
  al_set_sample_instance_gain := GetProcAddress(aDLLHandle, 'al_set_sample_instance_gain');
  al_set_sample_instance_length := GetProcAddress(aDLLHandle, 'al_set_sample_instance_length');
  al_set_sample_instance_pan := GetProcAddress(aDLLHandle, 'al_set_sample_instance_pan');
  al_set_sample_instance_playing := GetProcAddress(aDLLHandle, 'al_set_sample_instance_playing');
  al_set_sample_instance_playmode := GetProcAddress(aDLLHandle, 'al_set_sample_instance_playmode');
  al_set_sample_instance_position := GetProcAddress(aDLLHandle, 'al_set_sample_instance_position');
  al_set_sample_instance_speed := GetProcAddress(aDLLHandle, 'al_set_sample_instance_speed');
  al_set_separate_bitmap_blender := GetProcAddress(aDLLHandle, 'al_set_separate_bitmap_blender');
  al_set_separate_blender := GetProcAddress(aDLLHandle, 'al_set_separate_blender');
  al_set_shader_bool := GetProcAddress(aDLLHandle, 'al_set_shader_bool');
  al_set_shader_float := GetProcAddress(aDLLHandle, 'al_set_shader_float');
  al_set_shader_float_vector := GetProcAddress(aDLLHandle, 'al_set_shader_float_vector');
  al_set_shader_int := GetProcAddress(aDLLHandle, 'al_set_shader_int');
  al_set_shader_int_vector := GetProcAddress(aDLLHandle, 'al_set_shader_int_vector');
  al_set_shader_matrix := GetProcAddress(aDLLHandle, 'al_set_shader_matrix');
  al_set_shader_sampler := GetProcAddress(aDLLHandle, 'al_set_shader_sampler');
  al_set_standard_file_interface := GetProcAddress(aDLLHandle, 'al_set_standard_file_interface');
  al_set_standard_fs_interface := GetProcAddress(aDLLHandle, 'al_set_standard_fs_interface');
  al_set_system_mouse_cursor := GetProcAddress(aDLLHandle, 'al_set_system_mouse_cursor');
  al_set_target_backbuffer := GetProcAddress(aDLLHandle, 'al_set_target_backbuffer');
  al_set_target_bitmap := GetProcAddress(aDLLHandle, 'al_set_target_bitmap');
  al_set_thread_should_stop := GetProcAddress(aDLLHandle, 'al_set_thread_should_stop');
  al_set_timer_count := GetProcAddress(aDLLHandle, 'al_set_timer_count');
  al_set_timer_speed := GetProcAddress(aDLLHandle, 'al_set_timer_speed');
  al_set_video_playing := GetProcAddress(aDLLHandle, 'al_set_video_playing');
  al_set_voice_playing := GetProcAddress(aDLLHandle, 'al_set_voice_playing');
  al_set_voice_position := GetProcAddress(aDLLHandle, 'al_set_voice_position');
  al_set_window_constraints := GetProcAddress(aDLLHandle, 'al_set_window_constraints');
  al_set_window_position := GetProcAddress(aDLLHandle, 'al_set_window_position');
  al_set_window_title := GetProcAddress(aDLLHandle, 'al_set_window_title');
  al_show_mouse_cursor := GetProcAddress(aDLLHandle, 'al_show_mouse_cursor');
  al_show_native_file_dialog := GetProcAddress(aDLLHandle, 'al_show_native_file_dialog');
  al_show_native_message_box := GetProcAddress(aDLLHandle, 'al_show_native_message_box');
  al_shutdown_font_addon := GetProcAddress(aDLLHandle, 'al_shutdown_font_addon');
  al_shutdown_image_addon := GetProcAddress(aDLLHandle, 'al_shutdown_image_addon');
  al_shutdown_native_dialog_addon := GetProcAddress(aDLLHandle, 'al_shutdown_native_dialog_addon');
  al_shutdown_primitives_addon := GetProcAddress(aDLLHandle, 'al_shutdown_primitives_addon');
  al_shutdown_ttf_addon := GetProcAddress(aDLLHandle, 'al_shutdown_ttf_addon');
  al_shutdown_video_addon := GetProcAddress(aDLLHandle, 'al_shutdown_video_addon');
  al_signal_cond := GetProcAddress(aDLLHandle, 'al_signal_cond');
  al_start_audio_recorder := GetProcAddress(aDLLHandle, 'al_start_audio_recorder');
  al_start_thread := GetProcAddress(aDLLHandle, 'al_start_thread');
  al_start_timer := GetProcAddress(aDLLHandle, 'al_start_timer');
  al_start_video := GetProcAddress(aDLLHandle, 'al_start_video');
  al_start_video_with_voice := GetProcAddress(aDLLHandle, 'al_start_video_with_voice');
  al_stop_audio_recorder := GetProcAddress(aDLLHandle, 'al_stop_audio_recorder');
  al_stop_haptic_effect := GetProcAddress(aDLLHandle, 'al_stop_haptic_effect');
  al_stop_sample := GetProcAddress(aDLLHandle, 'al_stop_sample');
  al_stop_sample_instance := GetProcAddress(aDLLHandle, 'al_stop_sample_instance');
  al_stop_samples := GetProcAddress(aDLLHandle, 'al_stop_samples');
  al_stop_timer := GetProcAddress(aDLLHandle, 'al_stop_timer');
  al_store_state := GetProcAddress(aDLLHandle, 'al_store_state');
  al_toggle_menu_item_flags := GetProcAddress(aDLLHandle, 'al_toggle_menu_item_flags');
  al_transform_coordinates := GetProcAddress(aDLLHandle, 'al_transform_coordinates');
  al_transform_coordinates_3d := GetProcAddress(aDLLHandle, 'al_transform_coordinates_3d');
  al_transform_coordinates_3d_projective := GetProcAddress(aDLLHandle, 'al_transform_coordinates_3d_projective');
  al_transform_coordinates_4d := GetProcAddress(aDLLHandle, 'al_transform_coordinates_4d');
  al_translate_transform := GetProcAddress(aDLLHandle, 'al_translate_transform');
  al_translate_transform_3d := GetProcAddress(aDLLHandle, 'al_translate_transform_3d');
  al_transpose_transform := GetProcAddress(aDLLHandle, 'al_transpose_transform');
  al_triangulate_polygon := GetProcAddress(aDLLHandle, 'al_triangulate_polygon');
  al_ungrab_mouse := GetProcAddress(aDLLHandle, 'al_ungrab_mouse');
  al_uninstall_audio := GetProcAddress(aDLLHandle, 'al_uninstall_audio');
  al_uninstall_haptic := GetProcAddress(aDLLHandle, 'al_uninstall_haptic');
  al_uninstall_joystick := GetProcAddress(aDLLHandle, 'al_uninstall_joystick');
  al_uninstall_keyboard := GetProcAddress(aDLLHandle, 'al_uninstall_keyboard');
  al_uninstall_mouse := GetProcAddress(aDLLHandle, 'al_uninstall_mouse');
  al_uninstall_system := GetProcAddress(aDLLHandle, 'al_uninstall_system');
  al_uninstall_touch_input := GetProcAddress(aDLLHandle, 'al_uninstall_touch_input');
  al_unlock_bitmap := GetProcAddress(aDLLHandle, 'al_unlock_bitmap');
  al_unlock_index_buffer := GetProcAddress(aDLLHandle, 'al_unlock_index_buffer');
  al_unlock_mutex := GetProcAddress(aDLLHandle, 'al_unlock_mutex');
  al_unlock_sample_id := GetProcAddress(aDLLHandle, 'al_unlock_sample_id');
  al_unlock_vertex_buffer := GetProcAddress(aDLLHandle, 'al_unlock_vertex_buffer');
  al_unmap_rgb := GetProcAddress(aDLLHandle, 'al_unmap_rgb');
  al_unmap_rgb_f := GetProcAddress(aDLLHandle, 'al_unmap_rgb_f');
  al_unmap_rgba := GetProcAddress(aDLLHandle, 'al_unmap_rgba');
  al_unmap_rgba_f := GetProcAddress(aDLLHandle, 'al_unmap_rgba_f');
  al_unref_user_event := GetProcAddress(aDLLHandle, 'al_unref_user_event');
  al_unregister_event_source := GetProcAddress(aDLLHandle, 'al_unregister_event_source');
  al_update_display_region := GetProcAddress(aDLLHandle, 'al_update_display_region');
  al_update_fs_entry := GetProcAddress(aDLLHandle, 'al_update_fs_entry');
  al_upload_and_play_haptic_effect := GetProcAddress(aDLLHandle, 'al_upload_and_play_haptic_effect');
  al_upload_haptic_effect := GetProcAddress(aDLLHandle, 'al_upload_haptic_effect');
  al_use_projection_transform := GetProcAddress(aDLLHandle, 'al_use_projection_transform');
  al_use_shader := GetProcAddress(aDLLHandle, 'al_use_shader');
  al_use_transform := GetProcAddress(aDLLHandle, 'al_use_transform');
  al_ustr_append := GetProcAddress(aDLLHandle, 'al_ustr_append');
  al_ustr_append_chr := GetProcAddress(aDLLHandle, 'al_ustr_append_chr');
  al_ustr_append_cstr := GetProcAddress(aDLLHandle, 'al_ustr_append_cstr');
  al_ustr_appendf := GetProcAddress(aDLLHandle, 'al_ustr_appendf');
  al_ustr_assign := GetProcAddress(aDLLHandle, 'al_ustr_assign');
  al_ustr_assign_cstr := GetProcAddress(aDLLHandle, 'al_ustr_assign_cstr');
  al_ustr_assign_substr := GetProcAddress(aDLLHandle, 'al_ustr_assign_substr');
  al_ustr_compare := GetProcAddress(aDLLHandle, 'al_ustr_compare');
  al_ustr_dup := GetProcAddress(aDLLHandle, 'al_ustr_dup');
  al_ustr_dup_substr := GetProcAddress(aDLLHandle, 'al_ustr_dup_substr');
  al_ustr_empty_string := GetProcAddress(aDLLHandle, 'al_ustr_empty_string');
  al_ustr_encode_utf16 := GetProcAddress(aDLLHandle, 'al_ustr_encode_utf16');
  al_ustr_equal := GetProcAddress(aDLLHandle, 'al_ustr_equal');
  al_ustr_find_chr := GetProcAddress(aDLLHandle, 'al_ustr_find_chr');
  al_ustr_find_cset := GetProcAddress(aDLLHandle, 'al_ustr_find_cset');
  al_ustr_find_cset_cstr := GetProcAddress(aDLLHandle, 'al_ustr_find_cset_cstr');
  al_ustr_find_cstr := GetProcAddress(aDLLHandle, 'al_ustr_find_cstr');
  al_ustr_find_replace := GetProcAddress(aDLLHandle, 'al_ustr_find_replace');
  al_ustr_find_replace_cstr := GetProcAddress(aDLLHandle, 'al_ustr_find_replace_cstr');
  al_ustr_find_set := GetProcAddress(aDLLHandle, 'al_ustr_find_set');
  al_ustr_find_set_cstr := GetProcAddress(aDLLHandle, 'al_ustr_find_set_cstr');
  al_ustr_find_str := GetProcAddress(aDLLHandle, 'al_ustr_find_str');
  al_ustr_free := GetProcAddress(aDLLHandle, 'al_ustr_free');
  al_ustr_get := GetProcAddress(aDLLHandle, 'al_ustr_get');
  al_ustr_get_next := GetProcAddress(aDLLHandle, 'al_ustr_get_next');
  al_ustr_has_prefix := GetProcAddress(aDLLHandle, 'al_ustr_has_prefix');
  al_ustr_has_prefix_cstr := GetProcAddress(aDLLHandle, 'al_ustr_has_prefix_cstr');
  al_ustr_has_suffix := GetProcAddress(aDLLHandle, 'al_ustr_has_suffix');
  al_ustr_has_suffix_cstr := GetProcAddress(aDLLHandle, 'al_ustr_has_suffix_cstr');
  al_ustr_insert := GetProcAddress(aDLLHandle, 'al_ustr_insert');
  al_ustr_insert_chr := GetProcAddress(aDLLHandle, 'al_ustr_insert_chr');
  al_ustr_insert_cstr := GetProcAddress(aDLLHandle, 'al_ustr_insert_cstr');
  al_ustr_length := GetProcAddress(aDLLHandle, 'al_ustr_length');
  al_ustr_ltrim_ws := GetProcAddress(aDLLHandle, 'al_ustr_ltrim_ws');
  al_ustr_ncompare := GetProcAddress(aDLLHandle, 'al_ustr_ncompare');
  al_ustr_new := GetProcAddress(aDLLHandle, 'al_ustr_new');
  al_ustr_new_from_buffer := GetProcAddress(aDLLHandle, 'al_ustr_new_from_buffer');
  al_ustr_new_from_utf16 := GetProcAddress(aDLLHandle, 'al_ustr_new_from_utf16');
  al_ustr_newf := GetProcAddress(aDLLHandle, 'al_ustr_newf');
  al_ustr_next := GetProcAddress(aDLLHandle, 'al_ustr_next');
  al_ustr_offset := GetProcAddress(aDLLHandle, 'al_ustr_offset');
  al_ustr_prev := GetProcAddress(aDLLHandle, 'al_ustr_prev');
  al_ustr_prev_get := GetProcAddress(aDLLHandle, 'al_ustr_prev_get');
  al_ustr_remove_chr := GetProcAddress(aDLLHandle, 'al_ustr_remove_chr');
  al_ustr_remove_range := GetProcAddress(aDLLHandle, 'al_ustr_remove_range');
  al_ustr_replace_range := GetProcAddress(aDLLHandle, 'al_ustr_replace_range');
  al_ustr_rfind_chr := GetProcAddress(aDLLHandle, 'al_ustr_rfind_chr');
  al_ustr_rfind_cstr := GetProcAddress(aDLLHandle, 'al_ustr_rfind_cstr');
  al_ustr_rfind_str := GetProcAddress(aDLLHandle, 'al_ustr_rfind_str');
  al_ustr_rtrim_ws := GetProcAddress(aDLLHandle, 'al_ustr_rtrim_ws');
  al_ustr_set_chr := GetProcAddress(aDLLHandle, 'al_ustr_set_chr');
  al_ustr_size := GetProcAddress(aDLLHandle, 'al_ustr_size');
  al_ustr_size_utf16 := GetProcAddress(aDLLHandle, 'al_ustr_size_utf16');
  al_ustr_to_buffer := GetProcAddress(aDLLHandle, 'al_ustr_to_buffer');
  al_ustr_trim_ws := GetProcAddress(aDLLHandle, 'al_ustr_trim_ws');
  al_ustr_truncate := GetProcAddress(aDLLHandle, 'al_ustr_truncate');
  al_ustr_vappendf := GetProcAddress(aDLLHandle, 'al_ustr_vappendf');
  al_utf16_encode := GetProcAddress(aDLLHandle, 'al_utf16_encode');
  al_utf16_width := GetProcAddress(aDLLHandle, 'al_utf16_width');
  al_utf8_encode := GetProcAddress(aDLLHandle, 'al_utf8_encode');
  al_utf8_width := GetProcAddress(aDLLHandle, 'al_utf8_width');
  al_vertical_shear_transform := GetProcAddress(aDLLHandle, 'al_vertical_shear_transform');
  al_vfprintf := GetProcAddress(aDLLHandle, 'al_vfprintf');
  al_wait_cond := GetProcAddress(aDLLHandle, 'al_wait_cond');
  al_wait_cond_until := GetProcAddress(aDLLHandle, 'al_wait_cond_until');
  al_wait_for_event := GetProcAddress(aDLLHandle, 'al_wait_for_event');
  al_wait_for_event_timed := GetProcAddress(aDLLHandle, 'al_wait_for_event_timed');
  al_wait_for_event_until := GetProcAddress(aDLLHandle, 'al_wait_for_event_until');
  al_wait_for_vsync := GetProcAddress(aDLLHandle, 'al_wait_for_vsync');
  crc32 := GetProcAddress(aDLLHandle, 'crc32');
  nk__begin := GetProcAddress(aDLLHandle, 'nk__begin');
  nk__next := GetProcAddress(aDLLHandle, 'nk__next');
  nk_begin := GetProcAddress(aDLLHandle, 'nk_begin');
  nk_begin_titled := GetProcAddress(aDLLHandle, 'nk_begin_titled');
  nk_buffer_clear := GetProcAddress(aDLLHandle, 'nk_buffer_clear');
  nk_buffer_free := GetProcAddress(aDLLHandle, 'nk_buffer_free');
  nk_buffer_info := GetProcAddress(aDLLHandle, 'nk_buffer_info');
  nk_buffer_init := GetProcAddress(aDLLHandle, 'nk_buffer_init');
  nk_buffer_init_fixed := GetProcAddress(aDLLHandle, 'nk_buffer_init_fixed');
  nk_buffer_mark := GetProcAddress(aDLLHandle, 'nk_buffer_mark');
  nk_buffer_memory := GetProcAddress(aDLLHandle, 'nk_buffer_memory');
  nk_buffer_memory_const := GetProcAddress(aDLLHandle, 'nk_buffer_memory_const');
  nk_buffer_push := GetProcAddress(aDLLHandle, 'nk_buffer_push');
  nk_buffer_reset := GetProcAddress(aDLLHandle, 'nk_buffer_reset');
  nk_buffer_total := GetProcAddress(aDLLHandle, 'nk_buffer_total');
  nk_button_color := GetProcAddress(aDLLHandle, 'nk_button_color');
  nk_button_image := GetProcAddress(aDLLHandle, 'nk_button_image');
  nk_button_image_label := GetProcAddress(aDLLHandle, 'nk_button_image_label');
  nk_button_image_label_styled := GetProcAddress(aDLLHandle, 'nk_button_image_label_styled');
  nk_button_image_styled := GetProcAddress(aDLLHandle, 'nk_button_image_styled');
  nk_button_image_text := GetProcAddress(aDLLHandle, 'nk_button_image_text');
  nk_button_image_text_styled := GetProcAddress(aDLLHandle, 'nk_button_image_text_styled');
  nk_button_label := GetProcAddress(aDLLHandle, 'nk_button_label');
  nk_button_label_styled := GetProcAddress(aDLLHandle, 'nk_button_label_styled');
  nk_button_pop_behavior := GetProcAddress(aDLLHandle, 'nk_button_pop_behavior');
  nk_button_push_behavior := GetProcAddress(aDLLHandle, 'nk_button_push_behavior');
  nk_button_set_behavior := GetProcAddress(aDLLHandle, 'nk_button_set_behavior');
  nk_button_symbol := GetProcAddress(aDLLHandle, 'nk_button_symbol');
  nk_button_symbol_label := GetProcAddress(aDLLHandle, 'nk_button_symbol_label');
  nk_button_symbol_label_styled := GetProcAddress(aDLLHandle, 'nk_button_symbol_label_styled');
  nk_button_symbol_styled := GetProcAddress(aDLLHandle, 'nk_button_symbol_styled');
  nk_button_symbol_text := GetProcAddress(aDLLHandle, 'nk_button_symbol_text');
  nk_button_symbol_text_styled := GetProcAddress(aDLLHandle, 'nk_button_symbol_text_styled');
  nk_button_text := GetProcAddress(aDLLHandle, 'nk_button_text');
  nk_button_text_styled := GetProcAddress(aDLLHandle, 'nk_button_text_styled');
  nk_chart_add_slot := GetProcAddress(aDLLHandle, 'nk_chart_add_slot');
  nk_chart_add_slot_colored := GetProcAddress(aDLLHandle, 'nk_chart_add_slot_colored');
  nk_chart_begin := GetProcAddress(aDLLHandle, 'nk_chart_begin');
  nk_chart_begin_colored := GetProcAddress(aDLLHandle, 'nk_chart_begin_colored');
  nk_chart_end := GetProcAddress(aDLLHandle, 'nk_chart_end');
  nk_chart_push := GetProcAddress(aDLLHandle, 'nk_chart_push');
  nk_chart_push_slot := GetProcAddress(aDLLHandle, 'nk_chart_push_slot');
  nk_check_flags_label := GetProcAddress(aDLLHandle, 'nk_check_flags_label');
  nk_check_flags_text := GetProcAddress(aDLLHandle, 'nk_check_flags_text');
  nk_check_label := GetProcAddress(aDLLHandle, 'nk_check_label');
  nk_check_text := GetProcAddress(aDLLHandle, 'nk_check_text');
  nk_checkbox_flags_label := GetProcAddress(aDLLHandle, 'nk_checkbox_flags_label');
  nk_checkbox_flags_text := GetProcAddress(aDLLHandle, 'nk_checkbox_flags_text');
  nk_checkbox_label := GetProcAddress(aDLLHandle, 'nk_checkbox_label');
  nk_checkbox_text := GetProcAddress(aDLLHandle, 'nk_checkbox_text');
  nk_clear := GetProcAddress(aDLLHandle, 'nk_clear');
  nk_color_cf := GetProcAddress(aDLLHandle, 'nk_color_cf');
  nk_color_d := GetProcAddress(aDLLHandle, 'nk_color_d');
  nk_color_dv := GetProcAddress(aDLLHandle, 'nk_color_dv');
  nk_color_f := GetProcAddress(aDLLHandle, 'nk_color_f');
  nk_color_fv := GetProcAddress(aDLLHandle, 'nk_color_fv');
  nk_color_hex_rgb := GetProcAddress(aDLLHandle, 'nk_color_hex_rgb');
  nk_color_hex_rgba := GetProcAddress(aDLLHandle, 'nk_color_hex_rgba');
  nk_color_hsv_b := GetProcAddress(aDLLHandle, 'nk_color_hsv_b');
  nk_color_hsv_bv := GetProcAddress(aDLLHandle, 'nk_color_hsv_bv');
  nk_color_hsv_f := GetProcAddress(aDLLHandle, 'nk_color_hsv_f');
  nk_color_hsv_fv := GetProcAddress(aDLLHandle, 'nk_color_hsv_fv');
  nk_color_hsv_i := GetProcAddress(aDLLHandle, 'nk_color_hsv_i');
  nk_color_hsv_iv := GetProcAddress(aDLLHandle, 'nk_color_hsv_iv');
  nk_color_hsva_b := GetProcAddress(aDLLHandle, 'nk_color_hsva_b');
  nk_color_hsva_bv := GetProcAddress(aDLLHandle, 'nk_color_hsva_bv');
  nk_color_hsva_f := GetProcAddress(aDLLHandle, 'nk_color_hsva_f');
  nk_color_hsva_fv := GetProcAddress(aDLLHandle, 'nk_color_hsva_fv');
  nk_color_hsva_i := GetProcAddress(aDLLHandle, 'nk_color_hsva_i');
  nk_color_hsva_iv := GetProcAddress(aDLLHandle, 'nk_color_hsva_iv');
  nk_color_pick := GetProcAddress(aDLLHandle, 'nk_color_pick');
  nk_color_picker := GetProcAddress(aDLLHandle, 'nk_color_picker');
  nk_color_u32 := GetProcAddress(aDLLHandle, 'nk_color_u32');
  nk_colorf_hsva_f := GetProcAddress(aDLLHandle, 'nk_colorf_hsva_f');
  nk_colorf_hsva_fv := GetProcAddress(aDLLHandle, 'nk_colorf_hsva_fv');
  nk_combo := GetProcAddress(aDLLHandle, 'nk_combo');
  nk_combo_begin_color := GetProcAddress(aDLLHandle, 'nk_combo_begin_color');
  nk_combo_begin_image := GetProcAddress(aDLLHandle, 'nk_combo_begin_image');
  nk_combo_begin_image_label := GetProcAddress(aDLLHandle, 'nk_combo_begin_image_label');
  nk_combo_begin_image_text := GetProcAddress(aDLLHandle, 'nk_combo_begin_image_text');
  nk_combo_begin_label := GetProcAddress(aDLLHandle, 'nk_combo_begin_label');
  nk_combo_begin_symbol := GetProcAddress(aDLLHandle, 'nk_combo_begin_symbol');
  nk_combo_begin_symbol_label := GetProcAddress(aDLLHandle, 'nk_combo_begin_symbol_label');
  nk_combo_begin_symbol_text := GetProcAddress(aDLLHandle, 'nk_combo_begin_symbol_text');
  nk_combo_begin_text := GetProcAddress(aDLLHandle, 'nk_combo_begin_text');
  nk_combo_callback := GetProcAddress(aDLLHandle, 'nk_combo_callback');
  nk_combo_close := GetProcAddress(aDLLHandle, 'nk_combo_close');
  nk_combo_end := GetProcAddress(aDLLHandle, 'nk_combo_end');
  nk_combo_item_image_label := GetProcAddress(aDLLHandle, 'nk_combo_item_image_label');
  nk_combo_item_image_text := GetProcAddress(aDLLHandle, 'nk_combo_item_image_text');
  nk_combo_item_label := GetProcAddress(aDLLHandle, 'nk_combo_item_label');
  nk_combo_item_symbol_label := GetProcAddress(aDLLHandle, 'nk_combo_item_symbol_label');
  nk_combo_item_symbol_text := GetProcAddress(aDLLHandle, 'nk_combo_item_symbol_text');
  nk_combo_item_text := GetProcAddress(aDLLHandle, 'nk_combo_item_text');
  nk_combo_separator := GetProcAddress(aDLLHandle, 'nk_combo_separator');
  nk_combo_string := GetProcAddress(aDLLHandle, 'nk_combo_string');
  nk_combobox := GetProcAddress(aDLLHandle, 'nk_combobox');
  nk_combobox_callback := GetProcAddress(aDLLHandle, 'nk_combobox_callback');
  nk_combobox_separator := GetProcAddress(aDLLHandle, 'nk_combobox_separator');
  nk_combobox_string := GetProcAddress(aDLLHandle, 'nk_combobox_string');
  nk_contextual_begin := GetProcAddress(aDLLHandle, 'nk_contextual_begin');
  nk_contextual_close := GetProcAddress(aDLLHandle, 'nk_contextual_close');
  nk_contextual_end := GetProcAddress(aDLLHandle, 'nk_contextual_end');
  nk_contextual_item_image_label := GetProcAddress(aDLLHandle, 'nk_contextual_item_image_label');
  nk_contextual_item_image_text := GetProcAddress(aDLLHandle, 'nk_contextual_item_image_text');
  nk_contextual_item_label := GetProcAddress(aDLLHandle, 'nk_contextual_item_label');
  nk_contextual_item_symbol_label := GetProcAddress(aDLLHandle, 'nk_contextual_item_symbol_label');
  nk_contextual_item_symbol_text := GetProcAddress(aDLLHandle, 'nk_contextual_item_symbol_text');
  nk_contextual_item_text := GetProcAddress(aDLLHandle, 'nk_contextual_item_text');
  nk_draw_image := GetProcAddress(aDLLHandle, 'nk_draw_image');
  nk_draw_nine_slice := GetProcAddress(aDLLHandle, 'nk_draw_nine_slice');
  nk_draw_text := GetProcAddress(aDLLHandle, 'nk_draw_text');
  nk_edit_buffer := GetProcAddress(aDLLHandle, 'nk_edit_buffer');
  nk_edit_focus := GetProcAddress(aDLLHandle, 'nk_edit_focus');
  nk_edit_string := GetProcAddress(aDLLHandle, 'nk_edit_string');
  nk_edit_string_zero_terminated := GetProcAddress(aDLLHandle, 'nk_edit_string_zero_terminated');
  nk_edit_unfocus := GetProcAddress(aDLLHandle, 'nk_edit_unfocus');
  nk_end := GetProcAddress(aDLLHandle, 'nk_end');
  nk_fill_arc := GetProcAddress(aDLLHandle, 'nk_fill_arc');
  nk_fill_circle := GetProcAddress(aDLLHandle, 'nk_fill_circle');
  nk_fill_polygon := GetProcAddress(aDLLHandle, 'nk_fill_polygon');
  nk_fill_rect := GetProcAddress(aDLLHandle, 'nk_fill_rect');
  nk_fill_rect_multi_color := GetProcAddress(aDLLHandle, 'nk_fill_rect_multi_color');
  nk_fill_triangle := GetProcAddress(aDLLHandle, 'nk_fill_triangle');
  nk_filter_ascii := GetProcAddress(aDLLHandle, 'nk_filter_ascii');
  nk_filter_binary := GetProcAddress(aDLLHandle, 'nk_filter_binary');
  nk_filter_decimal := GetProcAddress(aDLLHandle, 'nk_filter_decimal');
  nk_filter_default := GetProcAddress(aDLLHandle, 'nk_filter_default');
  nk_filter_float := GetProcAddress(aDLLHandle, 'nk_filter_float');
  nk_filter_hex := GetProcAddress(aDLLHandle, 'nk_filter_hex');
  nk_filter_oct := GetProcAddress(aDLLHandle, 'nk_filter_oct');
  nk_free := GetProcAddress(aDLLHandle, 'nk_free');
  nk_get_null_rect := GetProcAddress(aDLLHandle, 'nk_get_null_rect');
  nk_group_begin := GetProcAddress(aDLLHandle, 'nk_group_begin');
  nk_group_begin_titled := GetProcAddress(aDLLHandle, 'nk_group_begin_titled');
  nk_group_end := GetProcAddress(aDLLHandle, 'nk_group_end');
  nk_group_get_scroll := GetProcAddress(aDLLHandle, 'nk_group_get_scroll');
  nk_group_scrolled_begin := GetProcAddress(aDLLHandle, 'nk_group_scrolled_begin');
  nk_group_scrolled_end := GetProcAddress(aDLLHandle, 'nk_group_scrolled_end');
  nk_group_scrolled_offset_begin := GetProcAddress(aDLLHandle, 'nk_group_scrolled_offset_begin');
  nk_group_set_scroll := GetProcAddress(aDLLHandle, 'nk_group_set_scroll');
  nk_handle_id := GetProcAddress(aDLLHandle, 'nk_handle_id');
  nk_handle_ptr := GetProcAddress(aDLLHandle, 'nk_handle_ptr');
  nk_hsv := GetProcAddress(aDLLHandle, 'nk_hsv');
  nk_hsv_bv := GetProcAddress(aDLLHandle, 'nk_hsv_bv');
  nk_hsv_f := GetProcAddress(aDLLHandle, 'nk_hsv_f');
  nk_hsv_fv := GetProcAddress(aDLLHandle, 'nk_hsv_fv');
  nk_hsv_iv := GetProcAddress(aDLLHandle, 'nk_hsv_iv');
  nk_hsva := GetProcAddress(aDLLHandle, 'nk_hsva');
  nk_hsva_bv := GetProcAddress(aDLLHandle, 'nk_hsva_bv');
  nk_hsva_colorf := GetProcAddress(aDLLHandle, 'nk_hsva_colorf');
  nk_hsva_colorfv := GetProcAddress(aDLLHandle, 'nk_hsva_colorfv');
  nk_hsva_f := GetProcAddress(aDLLHandle, 'nk_hsva_f');
  nk_hsva_fv := GetProcAddress(aDLLHandle, 'nk_hsva_fv');
  nk_hsva_iv := GetProcAddress(aDLLHandle, 'nk_hsva_iv');
  nk_image_color := GetProcAddress(aDLLHandle, 'nk_image_color');
  nk_image_handle := GetProcAddress(aDLLHandle, 'nk_image_handle');
  nk_image_id := GetProcAddress(aDLLHandle, 'nk_image_id');
  nk_image_is_subimage := GetProcAddress(aDLLHandle, 'nk_image_is_subimage');
  nk_image_ptr := GetProcAddress(aDLLHandle, 'nk_image_ptr');
  nk_image_rtn := GetProcAddress(aDLLHandle, 'nk_image');
  nk_init := GetProcAddress(aDLLHandle, 'nk_init');
  nk_init_custom := GetProcAddress(aDLLHandle, 'nk_init_custom');
  nk_init_fixed := GetProcAddress(aDLLHandle, 'nk_init_fixed');
  nk_input_any_mouse_click_in_rect := GetProcAddress(aDLLHandle, 'nk_input_any_mouse_click_in_rect');
  nk_input_begin := GetProcAddress(aDLLHandle, 'nk_input_begin');
  nk_input_button := GetProcAddress(aDLLHandle, 'nk_input_button');
  nk_input_char := GetProcAddress(aDLLHandle, 'nk_input_char');
  nk_input_end := GetProcAddress(aDLLHandle, 'nk_input_end');
  nk_input_glyph := GetProcAddress(aDLLHandle, 'nk_input_glyph');
  nk_input_has_mouse_click := GetProcAddress(aDLLHandle, 'nk_input_has_mouse_click');
  nk_input_has_mouse_click_down_in_rect := GetProcAddress(aDLLHandle, 'nk_input_has_mouse_click_down_in_rect');
  nk_input_has_mouse_click_in_rect := GetProcAddress(aDLLHandle, 'nk_input_has_mouse_click_in_rect');
  nk_input_is_key_down := GetProcAddress(aDLLHandle, 'nk_input_is_key_down');
  nk_input_is_key_pressed := GetProcAddress(aDLLHandle, 'nk_input_is_key_pressed');
  nk_input_is_key_released := GetProcAddress(aDLLHandle, 'nk_input_is_key_released');
  nk_input_is_mouse_click_down_in_rect := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_click_down_in_rect');
  nk_input_is_mouse_click_in_rect := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_click_in_rect');
  nk_input_is_mouse_down := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_down');
  nk_input_is_mouse_hovering_rect := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_hovering_rect');
  nk_input_is_mouse_pressed := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_pressed');
  nk_input_is_mouse_prev_hovering_rect := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_prev_hovering_rect');
  nk_input_is_mouse_released := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_released');
  nk_input_key := GetProcAddress(aDLLHandle, 'nk_input_key');
  nk_input_motion := GetProcAddress(aDLLHandle, 'nk_input_motion');
  nk_input_mouse_clicked := GetProcAddress(aDLLHandle, 'nk_input_mouse_clicked');
  nk_input_scroll := GetProcAddress(aDLLHandle, 'nk_input_scroll');
  nk_input_unicode := GetProcAddress(aDLLHandle, 'nk_input_unicode');
  nk_item_is_any_active := GetProcAddress(aDLLHandle, 'nk_item_is_any_active');
  nk_label := GetProcAddress(aDLLHandle, 'nk_label');
  nk_label_colored := GetProcAddress(aDLLHandle, 'nk_label_colored');
  nk_label_colored_wrap := GetProcAddress(aDLLHandle, 'nk_label_colored_wrap');
  nk_label_wrap := GetProcAddress(aDLLHandle, 'nk_label_wrap');
  nk_layout_ratio_from_pixel := GetProcAddress(aDLLHandle, 'nk_layout_ratio_from_pixel');
  nk_layout_reset_min_row_height := GetProcAddress(aDLLHandle, 'nk_layout_reset_min_row_height');
  nk_layout_row := GetProcAddress(aDLLHandle, 'nk_layout_row');
  nk_layout_row_begin := GetProcAddress(aDLLHandle, 'nk_layout_row_begin');
  nk_layout_row_dynamic := GetProcAddress(aDLLHandle, 'nk_layout_row_dynamic');
  nk_layout_row_end := GetProcAddress(aDLLHandle, 'nk_layout_row_end');
  nk_layout_row_push := GetProcAddress(aDLLHandle, 'nk_layout_row_push');
  nk_layout_row_static := GetProcAddress(aDLLHandle, 'nk_layout_row_static');
  nk_layout_row_template_begin := GetProcAddress(aDLLHandle, 'nk_layout_row_template_begin');
  nk_layout_row_template_end := GetProcAddress(aDLLHandle, 'nk_layout_row_template_end');
  nk_layout_row_template_push_dynamic := GetProcAddress(aDLLHandle, 'nk_layout_row_template_push_dynamic');
  nk_layout_row_template_push_static := GetProcAddress(aDLLHandle, 'nk_layout_row_template_push_static');
  nk_layout_row_template_push_variable := GetProcAddress(aDLLHandle, 'nk_layout_row_template_push_variable');
  nk_layout_set_min_row_height := GetProcAddress(aDLLHandle, 'nk_layout_set_min_row_height');
  nk_layout_space_begin := GetProcAddress(aDLLHandle, 'nk_layout_space_begin');
  nk_layout_space_bounds := GetProcAddress(aDLLHandle, 'nk_layout_space_bounds');
  nk_layout_space_end := GetProcAddress(aDLLHandle, 'nk_layout_space_end');
  nk_layout_space_push := GetProcAddress(aDLLHandle, 'nk_layout_space_push');
  nk_layout_space_rect_to_local := GetProcAddress(aDLLHandle, 'nk_layout_space_rect_to_local');
  nk_layout_space_rect_to_screen := GetProcAddress(aDLLHandle, 'nk_layout_space_rect_to_screen');
  nk_layout_space_to_local := GetProcAddress(aDLLHandle, 'nk_layout_space_to_local');
  nk_layout_space_to_screen := GetProcAddress(aDLLHandle, 'nk_layout_space_to_screen');
  nk_layout_widget_bounds := GetProcAddress(aDLLHandle, 'nk_layout_widget_bounds');
  nk_list_view_begin := GetProcAddress(aDLLHandle, 'nk_list_view_begin');
  nk_list_view_end := GetProcAddress(aDLLHandle, 'nk_list_view_end');
  nk_menu_begin_image := GetProcAddress(aDLLHandle, 'nk_menu_begin_image');
  nk_menu_begin_image_label := GetProcAddress(aDLLHandle, 'nk_menu_begin_image_label');
  nk_menu_begin_image_text := GetProcAddress(aDLLHandle, 'nk_menu_begin_image_text');
  nk_menu_begin_label := GetProcAddress(aDLLHandle, 'nk_menu_begin_label');
  nk_menu_begin_symbol := GetProcAddress(aDLLHandle, 'nk_menu_begin_symbol');
  nk_menu_begin_symbol_label := GetProcAddress(aDLLHandle, 'nk_menu_begin_symbol_label');
  nk_menu_begin_symbol_text := GetProcAddress(aDLLHandle, 'nk_menu_begin_symbol_text');
  nk_menu_begin_text := GetProcAddress(aDLLHandle, 'nk_menu_begin_text');
  nk_menu_close := GetProcAddress(aDLLHandle, 'nk_menu_close');
  nk_menu_end := GetProcAddress(aDLLHandle, 'nk_menu_end');
  nk_menu_item_image_label := GetProcAddress(aDLLHandle, 'nk_menu_item_image_label');
  nk_menu_item_image_text := GetProcAddress(aDLLHandle, 'nk_menu_item_image_text');
  nk_menu_item_label := GetProcAddress(aDLLHandle, 'nk_menu_item_label');
  nk_menu_item_symbol_label := GetProcAddress(aDLLHandle, 'nk_menu_item_symbol_label');
  nk_menu_item_symbol_text := GetProcAddress(aDLLHandle, 'nk_menu_item_symbol_text');
  nk_menu_item_text := GetProcAddress(aDLLHandle, 'nk_menu_item_text');
  nk_menubar_begin := GetProcAddress(aDLLHandle, 'nk_menubar_begin');
  nk_menubar_end := GetProcAddress(aDLLHandle, 'nk_menubar_end');
  nk_murmur_hash := GetProcAddress(aDLLHandle, 'nk_murmur_hash');
  nk_nine_slice_handle := GetProcAddress(aDLLHandle, 'nk_nine_slice_handle');
  nk_nine_slice_id := GetProcAddress(aDLLHandle, 'nk_nine_slice_id');
  nk_nine_slice_is_sub9slice := GetProcAddress(aDLLHandle, 'nk_nine_slice_is_sub9slice');
  nk_nine_slice_ptr := GetProcAddress(aDLLHandle, 'nk_nine_slice_ptr');
  nk_option_label := GetProcAddress(aDLLHandle, 'nk_option_label');
  nk_option_text := GetProcAddress(aDLLHandle, 'nk_option_text');
  nk_plot := GetProcAddress(aDLLHandle, 'nk_plot');
  nk_plot_function := GetProcAddress(aDLLHandle, 'nk_plot_function');
  nk_popup_begin := GetProcAddress(aDLLHandle, 'nk_popup_begin');
  nk_popup_close := GetProcAddress(aDLLHandle, 'nk_popup_close');
  nk_popup_end := GetProcAddress(aDLLHandle, 'nk_popup_end');
  nk_popup_get_scroll := GetProcAddress(aDLLHandle, 'nk_popup_get_scroll');
  nk_popup_set_scroll := GetProcAddress(aDLLHandle, 'nk_popup_set_scroll');
  nk_prog := GetProcAddress(aDLLHandle, 'nk_prog');
  nk_progress := GetProcAddress(aDLLHandle, 'nk_progress');
  nk_property_double := GetProcAddress(aDLLHandle, 'nk_property_double');
  nk_property_float := GetProcAddress(aDLLHandle, 'nk_property_float');
  nk_property_int := GetProcAddress(aDLLHandle, 'nk_property_int');
  nk_propertyd := GetProcAddress(aDLLHandle, 'nk_propertyd');
  nk_propertyf := GetProcAddress(aDLLHandle, 'nk_propertyf');
  nk_propertyi := GetProcAddress(aDLLHandle, 'nk_propertyi');
  nk_push_custom := GetProcAddress(aDLLHandle, 'nk_push_custom');
  nk_push_scissor := GetProcAddress(aDLLHandle, 'nk_push_scissor');
  nk_radio_label := GetProcAddress(aDLLHandle, 'nk_radio_label');
  nk_radio_text := GetProcAddress(aDLLHandle, 'nk_radio_text');
  nk_rect_pos := GetProcAddress(aDLLHandle, 'nk_rect_pos');
  nk_rect_rtn := GetProcAddress(aDLLHandle, 'nk_rect');
  nk_rect_size := GetProcAddress(aDLLHandle, 'nk_rect_size');
  nk_recta := GetProcAddress(aDLLHandle, 'nk_recta');
  nk_recti_rtn := GetProcAddress(aDLLHandle, 'nk_recti');
  nk_rectiv := GetProcAddress(aDLLHandle, 'nk_rectiv');
  nk_rectv := GetProcAddress(aDLLHandle, 'nk_rectv');
  nk_rgb_bv := GetProcAddress(aDLLHandle, 'nk_rgb_bv');
  nk_rgb_cf := GetProcAddress(aDLLHandle, 'nk_rgb_cf');
  nk_rgb_f := GetProcAddress(aDLLHandle, 'nk_rgb_f');
  nk_rgb_fv := GetProcAddress(aDLLHandle, 'nk_rgb_fv');
  nk_rgb_hex := GetProcAddress(aDLLHandle, 'nk_rgb_hex');
  nk_rgb_iv := GetProcAddress(aDLLHandle, 'nk_rgb_iv');
  nk_rgb_rtn := GetProcAddress(aDLLHandle, 'nk_rgb');
  nk_rgba_bv := GetProcAddress(aDLLHandle, 'nk_rgba_bv');
  nk_rgba_cf := GetProcAddress(aDLLHandle, 'nk_rgba_cf');
  nk_rgba_f := GetProcAddress(aDLLHandle, 'nk_rgba_f');
  nk_rgba_fv := GetProcAddress(aDLLHandle, 'nk_rgba_fv');
  nk_rgba_hex := GetProcAddress(aDLLHandle, 'nk_rgba_hex');
  nk_rgba_iv := GetProcAddress(aDLLHandle, 'nk_rgba_iv');
  nk_rgba_rtn := GetProcAddress(aDLLHandle, 'nk_rgba');
  nk_rgba_u32 := GetProcAddress(aDLLHandle, 'nk_rgba_u32');
  nk_select_image_label := GetProcAddress(aDLLHandle, 'nk_select_image_label');
  nk_select_image_text := GetProcAddress(aDLLHandle, 'nk_select_image_text');
  nk_select_label := GetProcAddress(aDLLHandle, 'nk_select_label');
  nk_select_symbol_label := GetProcAddress(aDLLHandle, 'nk_select_symbol_label');
  nk_select_symbol_text := GetProcAddress(aDLLHandle, 'nk_select_symbol_text');
  nk_select_text := GetProcAddress(aDLLHandle, 'nk_select_text');
  nk_selectable_image_label := GetProcAddress(aDLLHandle, 'nk_selectable_image_label');
  nk_selectable_image_text := GetProcAddress(aDLLHandle, 'nk_selectable_image_text');
  nk_selectable_label := GetProcAddress(aDLLHandle, 'nk_selectable_label');
  nk_selectable_symbol_label := GetProcAddress(aDLLHandle, 'nk_selectable_symbol_label');
  nk_selectable_symbol_text := GetProcAddress(aDLLHandle, 'nk_selectable_symbol_text');
  nk_selectable_text := GetProcAddress(aDLLHandle, 'nk_selectable_text');
  nk_slide_float := GetProcAddress(aDLLHandle, 'nk_slide_float');
  nk_slide_int := GetProcAddress(aDLLHandle, 'nk_slide_int');
  nk_slider_float := GetProcAddress(aDLLHandle, 'nk_slider_float');
  nk_slider_int := GetProcAddress(aDLLHandle, 'nk_slider_int');
  nk_spacer := GetProcAddress(aDLLHandle, 'nk_spacer');
  nk_spacing := GetProcAddress(aDLLHandle, 'nk_spacing');
  nk_str_append_str_char := GetProcAddress(aDLLHandle, 'nk_str_append_str_char');
  nk_str_append_str_runes := GetProcAddress(aDLLHandle, 'nk_str_append_str_runes');
  nk_str_append_str_utf8 := GetProcAddress(aDLLHandle, 'nk_str_append_str_utf8');
  nk_str_append_text_char := GetProcAddress(aDLLHandle, 'nk_str_append_text_char');
  nk_str_append_text_runes := GetProcAddress(aDLLHandle, 'nk_str_append_text_runes');
  nk_str_append_text_utf8 := GetProcAddress(aDLLHandle, 'nk_str_append_text_utf8');
  nk_str_at_char := GetProcAddress(aDLLHandle, 'nk_str_at_char');
  nk_str_at_char_const := GetProcAddress(aDLLHandle, 'nk_str_at_char_const');
  nk_str_at_const := GetProcAddress(aDLLHandle, 'nk_str_at_const');
  nk_str_at_rune := GetProcAddress(aDLLHandle, 'nk_str_at_rune');
  nk_str_clear := GetProcAddress(aDLLHandle, 'nk_str_clear');
  nk_str_delete_chars := GetProcAddress(aDLLHandle, 'nk_str_delete_chars');
  nk_str_delete_runes := GetProcAddress(aDLLHandle, 'nk_str_delete_runes');
  nk_str_free := GetProcAddress(aDLLHandle, 'nk_str_free');
  nk_str_get := GetProcAddress(aDLLHandle, 'nk_str_get');
  nk_str_get_const := GetProcAddress(aDLLHandle, 'nk_str_get_const');
  nk_str_init := GetProcAddress(aDLLHandle, 'nk_str_init');
  nk_str_init_fixed := GetProcAddress(aDLLHandle, 'nk_str_init_fixed');
  nk_str_insert_at_char := GetProcAddress(aDLLHandle, 'nk_str_insert_at_char');
  nk_str_insert_at_rune := GetProcAddress(aDLLHandle, 'nk_str_insert_at_rune');
  nk_str_insert_str_char := GetProcAddress(aDLLHandle, 'nk_str_insert_str_char');
  nk_str_insert_str_runes := GetProcAddress(aDLLHandle, 'nk_str_insert_str_runes');
  nk_str_insert_str_utf8 := GetProcAddress(aDLLHandle, 'nk_str_insert_str_utf8');
  nk_str_insert_text_char := GetProcAddress(aDLLHandle, 'nk_str_insert_text_char');
  nk_str_insert_text_runes := GetProcAddress(aDLLHandle, 'nk_str_insert_text_runes');
  nk_str_insert_text_utf8 := GetProcAddress(aDLLHandle, 'nk_str_insert_text_utf8');
  nk_str_len := GetProcAddress(aDLLHandle, 'nk_str_len');
  nk_str_len_char := GetProcAddress(aDLLHandle, 'nk_str_len_char');
  nk_str_remove_chars := GetProcAddress(aDLLHandle, 'nk_str_remove_chars');
  nk_str_remove_runes := GetProcAddress(aDLLHandle, 'nk_str_remove_runes');
  nk_str_rune_at := GetProcAddress(aDLLHandle, 'nk_str_rune_at');
  nk_strfilter := GetProcAddress(aDLLHandle, 'nk_strfilter');
  nk_stricmp := GetProcAddress(aDLLHandle, 'nk_stricmp');
  nk_stricmpn := GetProcAddress(aDLLHandle, 'nk_stricmpn');
  nk_strlen := GetProcAddress(aDLLHandle, 'nk_strlen');
  nk_strmatch_fuzzy_string := GetProcAddress(aDLLHandle, 'nk_strmatch_fuzzy_string');
  nk_strmatch_fuzzy_text := GetProcAddress(aDLLHandle, 'nk_strmatch_fuzzy_text');
  nk_stroke_arc := GetProcAddress(aDLLHandle, 'nk_stroke_arc');
  nk_stroke_circle := GetProcAddress(aDLLHandle, 'nk_stroke_circle');
  nk_stroke_curve := GetProcAddress(aDLLHandle, 'nk_stroke_curve');
  nk_stroke_line := GetProcAddress(aDLLHandle, 'nk_stroke_line');
  nk_stroke_polygon := GetProcAddress(aDLLHandle, 'nk_stroke_polygon');
  nk_stroke_polyline := GetProcAddress(aDLLHandle, 'nk_stroke_polyline');
  nk_stroke_rect := GetProcAddress(aDLLHandle, 'nk_stroke_rect');
  nk_stroke_triangle := GetProcAddress(aDLLHandle, 'nk_stroke_triangle');
  nk_strtod := GetProcAddress(aDLLHandle, 'nk_strtod');
  nk_strtof := GetProcAddress(aDLLHandle, 'nk_strtof');
  nk_strtoi := GetProcAddress(aDLLHandle, 'nk_strtoi');
  nk_style_default := GetProcAddress(aDLLHandle, 'nk_style_default');
  nk_style_from_table := GetProcAddress(aDLLHandle, 'nk_style_from_table');
  nk_style_get_color_by_name := GetProcAddress(aDLLHandle, 'nk_style_get_color_by_name');
  nk_style_hide_cursor := GetProcAddress(aDLLHandle, 'nk_style_hide_cursor');
  nk_style_item_color_rtn := GetProcAddress(aDLLHandle, 'nk_style_item_color');
  nk_style_item_hide := GetProcAddress(aDLLHandle, 'nk_style_item_hide');
  nk_style_item_image_rtn := GetProcAddress(aDLLHandle, 'nk_style_item_image');
  nk_style_item_nine_slice_rtn := GetProcAddress(aDLLHandle, 'nk_style_item_nine_slice');
  nk_style_load_all_cursors := GetProcAddress(aDLLHandle, 'nk_style_load_all_cursors');
  nk_style_load_cursor := GetProcAddress(aDLLHandle, 'nk_style_load_cursor');
  nk_style_pop_color := GetProcAddress(aDLLHandle, 'nk_style_pop_color');
  nk_style_pop_flags := GetProcAddress(aDLLHandle, 'nk_style_pop_flags');
  nk_style_pop_float := GetProcAddress(aDLLHandle, 'nk_style_pop_float');
  nk_style_pop_font := GetProcAddress(aDLLHandle, 'nk_style_pop_font');
  nk_style_pop_style_item := GetProcAddress(aDLLHandle, 'nk_style_pop_style_item');
  nk_style_pop_vec2 := GetProcAddress(aDLLHandle, 'nk_style_pop_vec2');
  nk_style_push_color := GetProcAddress(aDLLHandle, 'nk_style_push_color');
  nk_style_push_flags := GetProcAddress(aDLLHandle, 'nk_style_push_flags');
  nk_style_push_float := GetProcAddress(aDLLHandle, 'nk_style_push_float');
  nk_style_push_font := GetProcAddress(aDLLHandle, 'nk_style_push_font');
  nk_style_push_style_item := GetProcAddress(aDLLHandle, 'nk_style_push_style_item');
  nk_style_push_vec2 := GetProcAddress(aDLLHandle, 'nk_style_push_vec2');
  nk_style_set_cursor := GetProcAddress(aDLLHandle, 'nk_style_set_cursor');
  nk_style_set_font := GetProcAddress(aDLLHandle, 'nk_style_set_font');
  nk_style_show_cursor := GetProcAddress(aDLLHandle, 'nk_style_show_cursor');
  nk_sub9slice_handle := GetProcAddress(aDLLHandle, 'nk_sub9slice_handle');
  nk_sub9slice_id := GetProcAddress(aDLLHandle, 'nk_sub9slice_id');
  nk_sub9slice_ptr := GetProcAddress(aDLLHandle, 'nk_sub9slice_ptr');
  nk_subimage_handle := GetProcAddress(aDLLHandle, 'nk_subimage_handle');
  nk_subimage_id := GetProcAddress(aDLLHandle, 'nk_subimage_id');
  nk_subimage_ptr := GetProcAddress(aDLLHandle, 'nk_subimage_ptr');
  nk_text := GetProcAddress(aDLLHandle, 'nk_text');
  nk_text_colored := GetProcAddress(aDLLHandle, 'nk_text_colored');
  nk_text_wrap := GetProcAddress(aDLLHandle, 'nk_text_wrap');
  nk_text_wrap_colored := GetProcAddress(aDLLHandle, 'nk_text_wrap_colored');
  nk_textedit_cut := GetProcAddress(aDLLHandle, 'nk_textedit_cut');
  nk_textedit_delete := GetProcAddress(aDLLHandle, 'nk_textedit_delete');
  nk_textedit_delete_selection := GetProcAddress(aDLLHandle, 'nk_textedit_delete_selection');
  nk_textedit_free := GetProcAddress(aDLLHandle, 'nk_textedit_free');
  nk_textedit_init := GetProcAddress(aDLLHandle, 'nk_textedit_init');
  nk_textedit_init_fixed := GetProcAddress(aDLLHandle, 'nk_textedit_init_fixed');
  nk_textedit_paste := GetProcAddress(aDLLHandle, 'nk_textedit_paste');
  nk_textedit_redo := GetProcAddress(aDLLHandle, 'nk_textedit_redo');
  nk_textedit_select_all := GetProcAddress(aDLLHandle, 'nk_textedit_select_all');
  nk_textedit_text := GetProcAddress(aDLLHandle, 'nk_textedit_text');
  nk_textedit_undo := GetProcAddress(aDLLHandle, 'nk_textedit_undo');
  nk_tooltip := GetProcAddress(aDLLHandle, 'nk_tooltip');
  nk_tooltip_begin := GetProcAddress(aDLLHandle, 'nk_tooltip_begin');
  nk_tooltip_end := GetProcAddress(aDLLHandle, 'nk_tooltip_end');
  nk_tree_element_image_push_hashed := GetProcAddress(aDLLHandle, 'nk_tree_element_image_push_hashed');
  nk_tree_element_pop := GetProcAddress(aDLLHandle, 'nk_tree_element_pop');
  nk_tree_element_push_hashed := GetProcAddress(aDLLHandle, 'nk_tree_element_push_hashed');
  nk_tree_image_push_hashed := GetProcAddress(aDLLHandle, 'nk_tree_image_push_hashed');
  nk_tree_pop := GetProcAddress(aDLLHandle, 'nk_tree_pop');
  nk_tree_push_hashed := GetProcAddress(aDLLHandle, 'nk_tree_push_hashed');
  nk_tree_state_image_push := GetProcAddress(aDLLHandle, 'nk_tree_state_image_push');
  nk_tree_state_pop := GetProcAddress(aDLLHandle, 'nk_tree_state_pop');
  nk_tree_state_push := GetProcAddress(aDLLHandle, 'nk_tree_state_push');
  nk_triangle_from_direction := GetProcAddress(aDLLHandle, 'nk_triangle_from_direction');
  nk_utf_at := GetProcAddress(aDLLHandle, 'nk_utf_at');
  nk_utf_decode := GetProcAddress(aDLLHandle, 'nk_utf_decode');
  nk_utf_encode := GetProcAddress(aDLLHandle, 'nk_utf_encode');
  nk_utf_len := GetProcAddress(aDLLHandle, 'nk_utf_len');
  nk_vec2_rtn := GetProcAddress(aDLLHandle, 'nk_vec2');
  nk_vec2i_rtn := GetProcAddress(aDLLHandle, 'nk_vec2i');
  nk_vec2iv := GetProcAddress(aDLLHandle, 'nk_vec2iv');
  nk_vec2v := GetProcAddress(aDLLHandle, 'nk_vec2v');
  nk_widget := GetProcAddress(aDLLHandle, 'nk_widget');
  nk_widget_bounds := GetProcAddress(aDLLHandle, 'nk_widget_bounds');
  nk_widget_fitting := GetProcAddress(aDLLHandle, 'nk_widget_fitting');
  nk_widget_has_mouse_click_down := GetProcAddress(aDLLHandle, 'nk_widget_has_mouse_click_down');
  nk_widget_height := GetProcAddress(aDLLHandle, 'nk_widget_height');
  nk_widget_is_hovered := GetProcAddress(aDLLHandle, 'nk_widget_is_hovered');
  nk_widget_is_mouse_clicked := GetProcAddress(aDLLHandle, 'nk_widget_is_mouse_clicked');
  nk_widget_position := GetProcAddress(aDLLHandle, 'nk_widget_position');
  nk_widget_size := GetProcAddress(aDLLHandle, 'nk_widget_size');
  nk_widget_width := GetProcAddress(aDLLHandle, 'nk_widget_width');
  nk_window_close := GetProcAddress(aDLLHandle, 'nk_window_close');
  nk_window_collapse := GetProcAddress(aDLLHandle, 'nk_window_collapse');
  nk_window_collapse_if := GetProcAddress(aDLLHandle, 'nk_window_collapse_if');
  nk_window_find := GetProcAddress(aDLLHandle, 'nk_window_find');
  nk_window_get_bounds := GetProcAddress(aDLLHandle, 'nk_window_get_bounds');
  nk_window_get_canvas := GetProcAddress(aDLLHandle, 'nk_window_get_canvas');
  nk_window_get_content_region := GetProcAddress(aDLLHandle, 'nk_window_get_content_region');
  nk_window_get_content_region_max := GetProcAddress(aDLLHandle, 'nk_window_get_content_region_max');
  nk_window_get_content_region_min := GetProcAddress(aDLLHandle, 'nk_window_get_content_region_min');
  nk_window_get_content_region_size := GetProcAddress(aDLLHandle, 'nk_window_get_content_region_size');
  nk_window_get_height := GetProcAddress(aDLLHandle, 'nk_window_get_height');
  nk_window_get_panel := GetProcAddress(aDLLHandle, 'nk_window_get_panel');
  nk_window_get_position := GetProcAddress(aDLLHandle, 'nk_window_get_position');
  nk_window_get_scroll := GetProcAddress(aDLLHandle, 'nk_window_get_scroll');
  nk_window_get_size := GetProcAddress(aDLLHandle, 'nk_window_get_size');
  nk_window_get_width := GetProcAddress(aDLLHandle, 'nk_window_get_width');
  nk_window_has_focus := GetProcAddress(aDLLHandle, 'nk_window_has_focus');
  nk_window_is_active := GetProcAddress(aDLLHandle, 'nk_window_is_active');
  nk_window_is_any_hovered := GetProcAddress(aDLLHandle, 'nk_window_is_any_hovered');
  nk_window_is_closed := GetProcAddress(aDLLHandle, 'nk_window_is_closed');
  nk_window_is_collapsed := GetProcAddress(aDLLHandle, 'nk_window_is_collapsed');
  nk_window_is_hidden := GetProcAddress(aDLLHandle, 'nk_window_is_hidden');
  nk_window_is_hovered := GetProcAddress(aDLLHandle, 'nk_window_is_hovered');
  nk_window_set_bounds := GetProcAddress(aDLLHandle, 'nk_window_set_bounds');
  nk_window_set_focus := GetProcAddress(aDLLHandle, 'nk_window_set_focus');
  nk_window_set_position := GetProcAddress(aDLLHandle, 'nk_window_set_position');
  nk_window_set_scroll := GetProcAddress(aDLLHandle, 'nk_window_set_scroll');
  nk_window_set_size := GetProcAddress(aDLLHandle, 'nk_window_set_size');
  nk_window_show := GetProcAddress(aDLLHandle, 'nk_window_show');
  nk_window_show_if := GetProcAddress(aDLLHandle, 'nk_window_show_if');
  PHYSFS_deinit := GetProcAddress(aDLLHandle, 'PHYSFS_deinit');
  PHYSFS_getWriteDir := GetProcAddress(aDLLHandle, 'PHYSFS_getWriteDir');
  PHYSFS_init := GetProcAddress(aDLLHandle, 'PHYSFS_init');
  PHYSFS_mount := GetProcAddress(aDLLHandle, 'PHYSFS_mount');
  PHYSFS_setWriteDir := GetProcAddress(aDLLHandle, 'PHYSFS_setWriteDir');
  PHYSFS_unmount := GetProcAddress(aDLLHandle, 'PHYSFS_unmount');
  zipClose := GetProcAddress(aDLLHandle, 'zipClose');
  zipCloseFileInZip := GetProcAddress(aDLLHandle, 'zipCloseFileInZip');
  zipOpen := GetProcAddress(aDLLHandle, 'zipOpen');
  zipOpenNewFileInZip3 := GetProcAddress(aDLLHandle, 'zipOpenNewFileInZip3');
  zipWriteInFileInZip := GetProcAddress(aDLLHandle, 'zipWriteInFileInZip');
end;
{$ENDREGION}

{$REGION '  === SPEECHLIB ============================================================='}
procedure TSpVoice.InitServerData;
const
  CServerData: TServerData = (ClassId: '{96749377-3391-11D2-9EE3-00C04F797396}';
    IntfIID: '{269316D8-57BD-11D2-9EEE-00C04F797396}';
    EventIID: '{A372ACD1-3BEF-4BBD-8FFB-CB3E2B416AF8}'; LicenseKey: nil;
    Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpVoice.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    ConnectEvents(punk);
    FIntf := punk as ISpeechVoice;
  end;
end;

procedure TSpVoice.ConnectTo(svrIntf: ISpeechVoice);
begin
  Disconnect;
  FIntf := svrIntf;
  ConnectEvents(FIntf);
end;

procedure TSpVoice.Disconnect;
begin
  if FIntf <> nil then
  begin
    DisconnectEvents(FIntf);
    FIntf := nil;
  end;
end;

function TSpVoice.GetDefaultInterface: ISpeechVoice;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpVoice.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpVoice.Destroy;
begin
  inherited Destroy;
end;

procedure TSpVoice.InvokeEvent(dispid: TDispID; var Params: TVariantArray);
begin
  case DispID of
   -1: Exit; // DISPID_UNKNOWN
    1: if Assigned(FOnStartStream) then FOnStartStream(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    2: if Assigned(FOnEndStream) then FOnEndStream(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    3: if Assigned(FOnVoiceChange) then FOnVoiceChange(Self, Params[0] { Integer } , Params[1] { OleVariant } , IUnknown(TVarData(Params[2]).VPointer)  as ISpeechObjectToken { const ISpeechObjectToken } );
    4: if Assigned(FOnBookmark) then FOnBookmark(Self, Params[0] { Integer } , Params[1] { OleVariant } ,  Params[2] { const WideString } , Params[3] { Integer } );
    5: if Assigned(FOnWord) then FOnWord(Self, Params[0] { Integer } , Params[1] { OleVariant } , Params[2] { Integer } , Params[3] { Integer } );
    7: if Assigned(FOnSentence) then FOnSentence(Self, Params[0] { Integer } , Params[1] { OleVariant } , Params[2] { Integer } , Params[3] { Integer } );
    6: if Assigned(FOnPhoneme) then FOnPhoneme(Self, Params[0] { Integer } , Params[1] { OleVariant } ,  Params[2] { Integer } , Params[3] { Smallint } ,  Params[4] { SpeechVisemeFeature } , Params[5] { Smallint } );
    8: if Assigned(FOnViseme) then FOnViseme(Self, Params[0] { Integer } , Params[1] { OleVariant } , Params[2] { Integer } , Params[3] { SpeechVisemeType } , Params[4] { SpeechVisemeFeature } , Params[5] { SpeechVisemeType } );
    9: if Assigned(FOnAudioLevel) then FOnAudioLevel(Self, Params[0] { Integer } , Params[1] { OleVariant } , Params[2] { Integer } );
    10: if Assigned(FOnEnginePrivate) then FOnEnginePrivate(Self, Params[0] { Integer } , Params[1] { Integer } ,  Params[2] { OleVariant } );
  end; { case DispID }
end;

function TSpVoice.Get_Status: ISpeechVoiceStatus;
begin
  Result := DefaultInterface.Status;
end;

function TSpVoice.Get_Voice: ISpeechObjectToken;
begin
  Result := DefaultInterface.Voice;
end;

procedure TSpVoice._Set_Voice(const Voice: ISpeechObjectToken);
begin
  DefaultInterface.Voice := Voice;
end;

function TSpVoice.Get_AudioOutput: ISpeechObjectToken;
begin
  Result := DefaultInterface.AudioOutput;
end;

procedure TSpVoice._Set_AudioOutput(const AudioOutput: ISpeechObjectToken);
begin
  DefaultInterface.AudioOutput := AudioOutput;
end;

function TSpVoice.Get_AudioOutputStream: ISpeechBaseStream;
begin
  Result := DefaultInterface.AudioOutputStream;
end;

procedure TSpVoice._Set_AudioOutputStream(const AudioOutputStream: ISpeechBaseStream);
begin
  DefaultInterface.AudioOutputStream := AudioOutputStream;
end;

function TSpVoice.Get_Rate: Integer;
begin
  Result := DefaultInterface.Rate;
end;

procedure TSpVoice.Set_Rate(Rate: Integer);
begin
  DefaultInterface.Rate := Rate;
end;

function TSpVoice.Get_Volume: Integer;
begin
  Result := DefaultInterface.Volume;
end;

procedure TSpVoice.Set_Volume(Volume: Integer);
begin
  DefaultInterface.Volume := Volume;
end;

procedure TSpVoice.Set_AllowAudioOutputFormatChangesOnNextSet(Allow: WordBool);
begin
  DefaultInterface.AllowAudioOutputFormatChangesOnNextSet := Allow;
end;

function TSpVoice.Get_AllowAudioOutputFormatChangesOnNextSet: WordBool;
begin
  Result := DefaultInterface.AllowAudioOutputFormatChangesOnNextSet;
end;

function TSpVoice.Get_EventInterests: SpeechVoiceEvents;
begin
  Result := DefaultInterface.EventInterests;
end;

procedure TSpVoice.Set_EventInterests(EventInterestFlags: SpeechVoiceEvents);
begin
  DefaultInterface.EventInterests := EventInterestFlags;
end;

procedure TSpVoice.Set_Priority(Priority: SpeechVoicePriority);
begin
  DefaultInterface.Priority := Priority;
end;

function TSpVoice.Get_Priority: SpeechVoicePriority;
begin
  Result := DefaultInterface.Priority;
end;

procedure TSpVoice.Set_AlertBoundary(Boundary: SpeechVoiceEvents);
begin
  DefaultInterface.AlertBoundary := Boundary;
end;

function TSpVoice.Get_AlertBoundary: SpeechVoiceEvents;
begin
  Result := DefaultInterface.AlertBoundary;
end;

procedure TSpVoice.Set_SynchronousSpeakTimeout(msTimeout: Integer);
begin
  DefaultInterface.SynchronousSpeakTimeout := msTimeout;
end;

function TSpVoice.Get_SynchronousSpeakTimeout: Integer;
begin
  Result := DefaultInterface.SynchronousSpeakTimeout;
end;

function TSpVoice.Speak(const Text: WideString;
  Flags: SpeechVoiceSpeakFlags): Integer;
begin
  Result := DefaultInterface.Speak(Text, Flags);
end;

function TSpVoice.SpeakStream(const Stream: ISpeechBaseStream;
  Flags: SpeechVoiceSpeakFlags): Integer;
begin
  Result := DefaultInterface.SpeakStream(Stream, Flags);
end;

procedure TSpVoice.Pause;
begin
  DefaultInterface.Pause;
end;

procedure TSpVoice.Resume;
begin
  DefaultInterface.Resume;
end;

function TSpVoice.Skip(const type_: WideString; NumItems: Integer): Integer;
begin
  Result := DefaultInterface.Skip(type_, NumItems);
end;

function TSpVoice.GetVoices(const RequiredAttributes: WideString;
  const OptionalAttributes: WideString): ISpeechObjectTokens;
begin
  Result := DefaultInterface.GetVoices(RequiredAttributes, OptionalAttributes);
end;

function TSpVoice.GetAudioOutputs(const RequiredAttributes: WideString;
  const OptionalAttributes: WideString): ISpeechObjectTokens;
begin
  Result := DefaultInterface.GetAudioOutputs(RequiredAttributes,
    OptionalAttributes);
end;

function TSpVoice.WaitUntilDone(msTimeout: Integer): WordBool;
begin
  Result := DefaultInterface.WaitUntilDone(msTimeout);
end;

function TSpVoice.SpeakCompleteEvent: Integer;
begin
  Result := DefaultInterface.SpeakCompleteEvent;
end;

function TSpVoice.IsUISupported(const TypeOfUI: WideString): WordBool;
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  Result := DefaultInterface.IsUISupported(TypeOfUI, EmptyParam);
end;

function TSpVoice.IsUISupported(const TypeOfUI: WideString;
  const ExtraData: OleVariant): WordBool;
begin
  Result := DefaultInterface.IsUISupported(TypeOfUI, ExtraData);
end;

procedure TSpVoice.DisplayUI(hWndParent: Integer; const Title: WideString;
  const TypeOfUI: WideString);
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  DefaultInterface.DisplayUI(hWndParent, Title, TypeOfUI, EmptyParam);
end;

procedure TSpVoice.DisplayUI(hWndParent: Integer; const Title: WideString;
  const TypeOfUI: WideString; const ExtraData: OleVariant);
begin
  DefaultInterface.DisplayUI(hWndParent, Title, TypeOfUI, ExtraData);
end;
{$ENDREGION}

{$REGION '  === PASLIBS ==============================================================='}
procedure GetPasLibsExports(aDLLHandle: THandle);
begin
  if aDLLHandle = 0 then Exit;
  gv_database_create := GetProcAddress(aDLLHandle, 'gv_database_create');
  gv_database_destroy := GetProcAddress(aDLLHandle, 'gv_database_destroy');
  gv_database_setupmysql := GetProcAddress(aDLLHandle, 'gv_database_setupmysql');
  gv_database_setupsqlite := GetProcAddress(aDLLHandle, 'gv_database_setupsqlite');
  gv_database_open := GetProcAddress(aDLLHandle, 'gv_database_open');
  gv_database_close := GetProcAddress(aDLLHandle, 'gv_database_close');
  gv_database_connected := GetProcAddress(aDLLHandle, 'gv_database_connected');
  gv_database_execsql := GetProcAddress(aDLLHandle, 'gv_database_execsql');
  gv_database_execsql_scalar := GetProcAddress(aDLLHandle, 'gv_database_execsql_scalar');
  gv_database_query := GetProcAddress(aDLLHandle, 'gv_database_query');
  gv_database_query_field_count := GetProcAddress(aDLLHandle, 'gv_database_query_field_count');
  gv_databaes_query_record_count := GetProcAddress(aDLLHandle, 'gv_databaes_query_record_count');
  gv_database_query_bof := GetProcAddress(aDLLHandle, 'gv_database_query_bof');
  gv_database_query_eof := GetProcAddress(aDLLHandle, 'gv_database_query_eof');
  gv_database_query_next := GetProcAddress(aDLLHandle, 'gv_database_query_next');
  gv_database_query_prev := GetProcAddress(aDLLHandle, 'gv_database_query_prev');
  gv_database_query_last := GetProcAddress(aDLLHandle, 'gv_database_query_last');
  gv_database_query_first := GetProcAddress(aDLLHandle, 'gv_database_query_first');
  gv_database_query_field := GetProcAddress(aDLLHandle, 'gv_database_query_field');
  gv_database_last_error := GetProcAddress(aDLLHandle, 'gv_database_last_error');
end;
{$ENDREGION}

{$REGION '  === GAMEVISION ============================================================'}
{ --- VECTOR ---------------------------------------------------------------- }
{ TGVVector }
constructor TGVVector.Create(aX, aY: Single);
begin
  X := aX;
  Y := aY;
  Z := 0;
  W := 0;
end;

constructor TGVVector.Create(aX, aY, aZ: Single);
begin
  X := aX;
  Y := aY;
  Z := aZ;
  W := 0;
end;

constructor TGVVector.Create(aX, aY, aZ, aW: Single);
begin
  X := aX;
  Y := aY;
  Z := aZ;
  W := aW;
end;

procedure TGVVector.Assign(aX, aY: Single);
begin
  X := aX;
  Y := aY;
  Z := 0;
  W := 0;
end;

procedure TGVVector.Assign(aX, aY, aZ: Single);
begin
  X := aX;
  Y := aY;
  Z := aZ;
  W := 0;
end;

procedure TGVVector.Assign(aX, aY, aZ, aW: Single);
begin
  X := aX;
  Y := aY;
  Z := aZ;
  W := aW;
end;

procedure TGVVector.Assign(aVector: TGVVector);
begin
  Self := aVector;
end;

procedure TGVVector.Clear;
begin
  X := 0;
  Y := 0;
  Z := 0;
  W := 0;
end;

procedure TGVVector.Add(aVector: TGVVector);
begin
  X := X + aVector.X;
  Y := Y + aVector.Y;
end;

procedure TGVVector.Subtract(aVector: TGVVector);
begin
  X := X - aVector.X;
  Y := Y - aVector.Y;
end;

procedure TGVVector.Multiply(aVector: TGVVector);
begin
  X := X * aVector.X;
  Y := Y * aVector.Y;
end;

procedure TGVVector.Divide(aVector: TGVVector);
begin
  X := X / aVector.X;
  Y := Y / aVector.Y;
end;

function  TGVVector.Magnitude: Single;
begin
  Result := Sqrt((X * X) + (Y * Y));
end;

function  TGVVector.MagnitudeTruncate(aMaxMagitude: Single): TGVVector;
var
  LMaxMagSqrd: Single;
  LVecMagSqrd: Single;
  LTruc: Single;
begin
  Result.Assign(X, Y);
  LMaxMagSqrd := aMaxMagitude * aMaxMagitude;
  LVecMagSqrd := Result.Magnitude;
  if LVecMagSqrd > LMaxMagSqrd then
  begin
    LTruc := (aMaxMagitude / Sqrt(LVecMagSqrd));
    Result.X := Result.X * LTruc;
    Result.Y := Result.Y * LTruc;
  end;
end;

function  TGVVector.Distance(aVector: TGVVector): Single;
var
  LDirVec: TGVVector;
begin
  LDirVec.X := X - aVector.X;
  LDirVec.Y := Y - aVector.Y;
  Result := LDirVec.Magnitude;
end;

procedure TGVVector.Normalize;
var
  LLen, LOOL: Single;
begin
  LLen := self.Magnitude;
  if LLen <> 0 then
  begin
    LOOL := 1.0 / LLen;
    X := X * LOOL;
    Y := Y * LOOL;
  end;
end;

function  TGVVector.Angle(aVector: TGVVector): Single;
var
  LXOY: Single;
  LR: TGVVector;
begin
  LR.Assign(self);
  LR.Subtract(aVector);
  LR.Normalize;

  if LR.Y = 0 then
  begin
    LR.Y := 0.001;
  end;

  LXOY := LR.X / LR.Y;

  Result := ArcTan(LXOY) * GV_RAD2DEG;
  if LR.Y < 0 then
    Result := Result + 180.0;
end;

procedure TGVVector.Thrust(aAngle: Single; aSpeed: Single);
var
  LA: Single;

begin
  LA := aAngle + 90.0;

  GV.Math.ClipValue(LA, 0, 360, True);

  X := X + GV.Math.AngleCos(Round(LA)) * -(aSpeed);
  Y := Y + GV.Math.AngleSin(Round(LA)) * -(aSpeed);
end;

function  TGVVector.MagnitudeSquared: Single;
begin
  Result := (X * X) + (Y * Y);
end;

function  TGVVector.DotProduct(aVector: TGVVector): Single;
begin
  Result := (X * aVector.X) + (Y * aVector.Y);
end;

procedure TGVVector.Scale(aValue: Single);
begin
  X := X * aValue;
  Y := Y * aValue;
end;

procedure TGVVector.DivideBy(aValue: Single);
begin
  X := X / aValue;
  Y := Y / aValue;
end;

function  TGVVector.Project(aVector: TGVVector): TGVVector;
var
  LDP: Single;
begin
  LDP := DotProduct(aVector);
  Result.X := (LDP / (aVector.X * aVector.X + aVector.Y * aVector.Y)) * aVector.X;
  Result.Y := (LDP / (aVector.X * aVector.X + aVector.Y * aVector.Y)) * aVector.Y;
end;

procedure TGVVector.Negate;
begin
  X := -X;
  Y := -Y;
end;

{ --- RECTANGLE ------------------------------------------------------------- }
{ TGVRectangle }
constructor TGVRectangle.Create(aX, aY, aWidth, aHeight: Single);
begin
  X := aX;
  Y := aY;
  Width := aWidth;
  Height := aHeight;
end;

procedure TGVRectangle.Assign(aX, aY, aWidth, aHeight: Single);
begin
  X := aX;
  Y := aY;
  Width := aWidth;
  Height := aHeight;
end;

procedure TGVRectangle.Assign(aRectangle: TGVRectangle);
begin
  X := aRectangle.X;
  Y := aRectangle.Y;
  Width := aRectangle.Width;
  Height := aRectangle.Height;
end;

procedure TGVRectangle.Clear;
begin
  X := 0;
  Y := 0;
  Width := 0;
  Height := 0;
end;

function TGVRectangle.Intersect(aRect: TGVRectangle): Boolean;
var
  LR1R, LR1B: Single;
  LR2R, LR2B: Single;
begin
  LR1R := X - (Width - 1);
  LR1B := Y - (Height - 1);
  LR2R := aRect.X - (aRect.Width - 1);
  LR2B := aRect.Y - (aRect.Height - 1);

  Result := (X < LR2R) and (LR1R > aRect.X) and (Y < LR2B) and (LR1B > aRect.Y);
end;

{ --- COLOR ----------------------------------------------------------------- }
{ TGVColor }
function TGVColor.Make(aRed: Byte; aGreen: Byte; aBlue: Byte; aAlpha: Byte): TGVColor;
var
  LColor: ALLEGRO_COLOR;
begin
  LColor := al_map_rgba(aRed, aGreen, aBlue, aAlpha);
  Red := LColor.r;
  Green := LColor.g;
  Blue := LColor.b;
  Alpha := LColor.a;
  Result := Self;
end;

function TGVColor.Make(aRed: Single; aGreen: Single; aBlue: Single; aAlpha: Single): TGVColor;
var
  LColor: ALLEGRO_COLOR;
begin
  LColor := al_map_rgba_f(aRed, aGreen, aBlue, aAlpha);
  Red := LColor.r;
  Green := LColor.g;
  Blue := LColor.b;
  Alpha := LColor.a;
  Result := Self;
end;

function TGVColor.Make(const aName: string): TGVColor;
var
  LMarshaller: TMarshaller;
  LColor: ALLEGRO_COLOR absolute Result;
begin
  LColor := al_color_name(LMarshaller.AsAnsi(aName).ToPointer);
  Red := LColor.r;
  Green := LColor.g;
  Blue := LColor.b;
  Alpha := LColor.a;
  Result := Self;
end;

function TGVColor.Fade(aTo: TGVColor; aPos: Single): TGVColor;
var
  LColor: TGVColor;
begin
  // clip to ranage 0.0 - 1.0
  if aPos < 0 then
    aPos := 0
  else if aPos > 1.0 then
    aPos := 1.0;

  // fade colors
  LColor.Alpha := Alpha + ((aTo.Alpha - Alpha) * aPos);
  LColor.Blue := Blue + ((aTo.Blue - Blue) * aPos);
  LColor.Green := Green + ((aTo.Green - Green) * aPos);
  LColor.Red := Red + ((aTo.Red - Red) * aPos);
  Result := Make(LColor.Red, LColor.Green, LColor.Blue, LColor.Alpha);
end;

function TGVColor.Equal(aColor: TGVColor): Boolean;
begin
  if (Red = aColor.Red) and (Green = aColor.Green) and
    (Blue = aColor.Blue) and (Alpha = aColor.Alpha) then
    Result := True
  else
    Result := False;
end;

{ --- OBJECT ---------------------------------------------------------------- }
{ TGVObject }
function TGVObject.GetAttribute(aIndex: Byte): Boolean;
begin
  Result := Boolean(aIndex in FAttributes);
end;

procedure TGVObject.SetAttribute(aIndex: Byte; aValue: Boolean);
begin
  if aValue then
    Include(FAttributes, aIndex)
  else
    Exclude(FAttributes, aIndex);
end;

function TGVObject.GetAttributes: TGVObjectAttributeSet;
begin
  Result := FAttributes;
end;

procedure TGVObject.SetAttributes(aValue: TGVObjectAttributeSet);
begin
  FAttributes := aValue;
end;

constructor TGVObject.Create;
begin
  inherited;
  FOwner := nil;
  FPrev := nil;
  FNext := nil;
  FAttributes := [];
  if GV <> nil then
    GV.MasterObjectList.Add(Self);
end;

destructor TGVObject.Destroy;
begin
  if FOwner <> nil then
  begin
    if GV <> nil then
      GV.MasterObjectList.Remove(Self, False);
  end;
  inherited;
end;

function TGVObject.AttributesAreSet(aAttrs: TGVObjectAttributeSet): Boolean;
var
  LAttr: Byte;
begin
  Result := False;
  for LAttr in aAttrs do
  begin
    if LAttr in FAttributes then
    begin
      Result := True;
      Break;
    end;
  end;
end;

{ --- OBJECTLIST ------------------------------------------------------------ }
{ TGVObjectList }
constructor TGVObjectList.Create;
begin
  inherited;
  FHead := nil;
  FTail := nil;
  FCount := 0;
end;

destructor TGVObjectList.Destroy;
begin
  Clean;
  inherited;
end;

procedure TGVObjectList.Add(aObject: TGVObject);
begin
  if aObject = nil then Exit;

  // check if already on this list
  if aObject.Owner = Self then Exit;

  // remove if on another list
  if aObject.Owner <> nil then
  begin
    aObject.Owner.Remove(aObject, False);
  end;

  aObject.Prev := FTail;
  aObject.Next := nil;
  aObject.Owner := Self;

  if FHead = nil then
    begin
      FHead := aObject;
      FTail := aObject;
    end
  else
    begin
      FTail.Next := aObject;
      FTail := aObject;
    end;

  Inc(FCount);
end;

procedure TGVObjectList.Remove(aObject: TGVObject; aDispose: Boolean);
var
  LFlag: Boolean;
begin
  if aObject = nil then Exit;

  LFlag := False;

  if aObject.Next <> nil then
  begin
    aObject.Next.Prev := aObject.Prev;
    LFlag := True;
  end;

  if aObject.Prev <> nil then
  begin
    aObject.Prev.Next := aObject.Next;
    LFlag := True;
  end;

  if FTail = aObject then
  begin
    FTail := FTail.Prev;
    LFlag := True;
  end;

  if FHead = aObject then
  begin
    FHead := FHead.Next;
    LFlag := True;
  end;

  if LFlag = True then
  begin
    aObject.Owner := nil;
    Dec(FCount);
    if aDispose then
    begin
      aObject.Free;
    end;
  end;
end;

procedure TGVObjectList.Clean;
var
  LPrev: TGVObject;
  LNext: TGVObject;
begin
  // get pointer to head
  LPrev := FHead;

  // exit if list is empty
  if LPrev = nil then
    Exit;

  repeat
    // save pointer to next object
    LNext := LPrev.Next;

    Remove(LPrev, True);

    // get pointer to next object
    LPrev := LNext;

  until LPrev = nil;
end;

procedure TGVObjectList.Clear(aAttrs: TGVObjectAttributeSet);
var
  LPrev: TGVObject;
  LNext: TGVObject;
  LNoAttrs: Boolean;
begin
  // get pointer to head
  LPrev := FHead;

  // exit if list is empty
  if LPrev = nil then Exit;

  // check if we should check for attrs
  LNoAttrs := Boolean(aAttrs = []);

  repeat
    // save pointer to next object
    LNext := LPrev.Next;

    if LNoAttrs then
      begin
        Remove(LPrev, True);
      end
    else
      begin
        if LPrev.AttributesAreSet(aAttrs) then
        begin
          Remove(LPrev, True);
        end;
      end;

    // get pointer to next object
    LPrev := LNext;

  until LPrev = nil;
end;

{ --- BUFFER ---------------------------------------------------------------- }
{ TGVBuffer }
function TGVBuffer.GetPosition: UInt64;
begin
  Result := FPosition;
end;

procedure TGVBuffer.SetPosition(aPosition: UInt64);
begin
  if aPosition > FSize-1 then
    FPosition := FSize-1
  else
    FPosition := aPosition;
end;

constructor TGVBuffer.Create;
begin
  inherited;
  FHandle := 0;
  FMemory := nil;
  FSize := 0;
  FPosition := 0;
end;

destructor TGVBuffer.Destroy;
begin
  Release;
  inherited;
end;

function TGVBuffer.Allocate(aSize: UInt64): Boolean;
var
  LName: string;
  LHandle: THandle;
  LMemory: Pointer;
begin
  Result := False;

  LName := TPath.GetGUIDFileName;
  LHandle := CreateFileMapping(INVALID_HANDLE_VALUE, nil, PAGE_READWRITE, 0, aSize, PChar(LName));
  if LHandle = 0 then
  begin
    Release;
    Exit;
  end;

  LMemory := MapViewOfFile(LHandle, FILE_MAP_ALL_ACCESS, 0, 0, 0);
  if LMemory = nil then
  begin
    Release;
    Exit;
  end;

  FHandle := LHandle;
  FMemory := LMemory;
  FSize   := aSize;
  FPosition := 0;

  Result := True;
end;

procedure TGVBuffer.Release;
begin
  if FMemory <> nil then
  begin
    // TODO: check for errors
    UnmapViewOfFile(FMemory);
    FMemory := nil;
  end;

  if FHandle <> 0 then
  begin
    // TODO: check for errors
    CloseHandle(FHandle);
    FHandle := 0;
  end;

  if (FMemory = nil) and (FHandle = 0) then
  begin
    FSize := 0;
    FPosition := 0;
  end;
end;

function TGVBuffer.Read(const aBuffer: Pointer; aCount: UInt64): UInt64;
begin
  if (FPosition >= 0) and (aCount >= 0) then
  begin
    if (FSize - FPosition) > 0 then
    begin
      if FSize > aCount + FPosition then Result := aCount
      else Result := FSize - FPosition;
      Move((PByte(FMemory) + FPosition)^, aBuffer^, Result);
      Inc(FPosition, Result);
      Exit;
    end;
  end;
  Result := 0;
end;

function TGVBuffer.Write(aBuffer: Pointer; aCount: UInt64): UInt64;
var
  LPos: UInt64;
begin
  if (FPosition >= 0) and (aCount >= 0) then
  begin
    LPos := FPosition + aCount;
    if LPos > 0 then
    begin
      if LPos > FSize then
      begin
        Result := 0;
        Exit;
      end;
      System.Move(aBuffer^, (PByte(FMemory) + FPosition)^, aCount);
      FPosition := LPos;
      Result := aCount;
      Exit;
    end;
  end;
  Result := 0;
end;

function TGVBuffer.LoadFromFile(const aFilename: string): Boolean;
var
  FStream: TFileStream;
  LNum: UInt64;
begin
  Result := False;
  if not TFile.Exists(aFilename) then Exit;
  FStream := TFile.OpenRead(aFilename);
  if FStream = nil then Exit;
  if FStream.Size = 0 then
  begin
    FreeAndNil(FStream);
    Exit;
  end;
  LNum := LoadFromStream(FStream);
  FreeAndNil(FStream);
  Result := Boolean(LNum <> 0);
end;

function TGVBuffer.SaveToFile(const aFilename: string): Boolean;
var
  FStream: TFileStream;
  LNum: UInt64;
begin
  Result := False;
  FStream := TFile.Create(aFilename);
  if FStream = nil then Exit;
  LNum := SaveToStream(FStream);
  FreeAndNil(FStream);
  Result := Boolean(LNum <> 0);
end;

function TGVBuffer.LoadFromStream(const aStream: TStream): UInt64;
var
  LNum: Integer;
  LBuffer: TBytes;
begin
  Result := 0;
  if aStream = nil then Exit;
  if aStream.Size = 0 then Exit;
  Release;
  Allocate(aStream.Size);
  aStream.Position := 0;
  SetLength(LBuffer, GV_BUFFER_COPYCACHESIZE);
  while True do
  begin
    LNum := aStream.Read(LBuffer, GV_BUFFER_COPYCACHESIZE);
    if LNum = 0 then Break;
    Write(LBuffer, LNum);
    Inc(Result, LNum);
  end;
end;

function TGVBuffer.SaveToStream(const aStream: TStream): UInt64;
var
  LNum: Integer;
  LBuffer: TBytes;
begin
  Result := 0;
  if FHandle = 0 then Exit;
  if FMemory = nil then Exit;
  FPosition := 0;
  SetLength(LBuffer, GV_BUFFER_COPYCACHESIZE);
  while True do
  begin
    LNum := Read(LBuffer, GV_BUFFER_COPYCACHESIZE);
    if LNum = 0 then Break;
    aStream.Write(LBuffer, LNum);
    Inc(Result, LNum);
  end;
end;

function TGVBuffer.Eof: Boolean;
begin
  Result := Boolean(FPosition >= FSize);
end;

{ --- UTIL ------------------------------------------------------------------ }
{ TUtil }
constructor TGVUtil.Create;
begin
  inherited;
end;

destructor TGVUtil.Destroy;
begin
  inherited;
end;

function  TGVUtil.GetLastOSError: string;
begin
  Result := SysErrorMessage(WinAPI.Windows.GetLastError);
end;

function TGVUtil.RemoveQuotes(const aText: string): string;
var
  LText: string;
begin
  LText := AnsiDequotedStr(aText, '"');
  Result := AnsiDequotedStr(LText, '''');
end;

procedure TGVUtil.GotoURL(const aURL: string);
begin
  if aURL.IsEmpty then Exit;
  ShellExecute(0, 'OPEN', PChar(aURL), '', '', SW_SHOWNORMAL);
end;

procedure TGVUtil.ShellRun(const aFilename: string; const aParams: string; const aDir: string; aHide: Boolean);
var
  LShowCmd: Integer;
  LFilename: string;
begin
  LFilename := RemoveQuotes(aFilename);
  if LFilename.IsEmpty then Exit;
  if aHide then
    LShowCmd := SW_HIDE
  else
    LShowCmd := SW_SHOWNORMAL;
  ShellExecute(0, 'OPEN', PChar(aFilename), PChar(aParams), PChar(aDir), LShowCmd);
end;

function TGVUtil.CreateDirsInPath(const aPath: string): Boolean;
var
  LPath: string;
begin
  Result := False;

  if aPath = '' then Exit;

  LPath := TPath.GetDirectoryName(aPath);
  if LPath = '' then Exit;

  TDirectory.CreateDirectory(LPath);

  Result := TDirectory.Exists(LPath);
end;

procedure TGVUtil.DeferDelFile(const aFilename: string);
var
  LCode: TStringList;
  LFilename: string;

  procedure C(const aMsg: string; const aArgs: array of const);
  var
    LLine: string;
  begin
    LLine := Format(aMsg, aArgs);
    LCode.Add(LLine);
  end;

begin
  if aFilename.IsEmpty then Exit;
  LFilename := ChangeFileExt(aFilename, '');
  LFilename := LFilename + '_DeferDelFile.bat';

  LCode := TStringList.Create;
  try
    C('@echo off', []);
    C(':Repeat', []);
    C('del "%s"', [aFilename]);
    C('if exist "%s" goto Repeat', [aFilename]);
    C('del "%s"', [LFilename]);
    LCode.SaveToFile(LFilename);
  finally
    FreeAndNil(LCode);
  end;

  if FileExists(LFilename) then
  begin
    ShellExecute(0, 'open', PChar(LFilename), nil, nil, SW_HIDE);
  end;
end;


procedure TGVUtil.LoadDefaultIcon(aWnd: HWND);
var
  LHnd: THandle;
  LIco: TIcon;
begin
  LHnd := GetModuleHandle(nil);
  if LHnd <> 0 then
  begin
    if FindResource(LHnd, 'MAINICON', RT_GROUP_ICON) <> 0 then
    begin
      LIco := TIcon.Create;
      LIco.LoadFromResourceName(LHnd, 'MAINICON');
      SendMessage(aWnd, WM_SETICON, ICON_BIG, LIco.Handle);
      FreeAndNil(LIco);
      //Application.ProcessMessages;
    end;
  end;
end;

function TGVUtil.ResourceExists(aInstance: THandle; const aResName: string): Boolean;
begin
  Result := Boolean((FindResource(aInstance, PChar(aResName), RT_RCDATA) <> 0));
end;

function  TGVUtil.LoadResourceToBuffer(aInstance: THandle; const aResName: string): TGVBuffer;
var
  LStream: TResourceStream;
begin
  Result := nil;
  if not Self.ResourceExists(aInstance, aResName) then Exit;
  LStream := TResourceStream.Create(aInstance, aResName, RT_RCDATA);
  try
    Result := TGVBuffer.Create;
    Result.LoadFromStream(LStream);
  finally
    FreeAndNil(LStream);
  end;
end;

procedure TGVUtil.LoadStringListFromResource(const aResName: string; aList: TStringList);
var
  LStream: TResourceStream;
begin
  if not ResourceExists(HInstance, aResName) then Exit;
  LStream := TResourceStream.Create(HInstance, aResName, RT_RCDATA);
  try
    aList.LoadFromStream(LStream);
  finally
    FreeAndNil(LStream);
  end;
end;

function TGVUtil.LoadStringFromResource(const aResName: string): string;
var
  LStream: TResourceStream;
  LStrList: TStringLIst;
begin
  Result := '';
  if not ResourceExists(HInstance, aResName) then Exit;
  LStream := TResourceStream.Create(HInstance, aResName, RT_RCDATA);
  try
    LStrList := TStringList.Create;
    try
      LStrList.LoadFromStream(LStream);
      Result := LStrList.Text;
    finally
      FreeAndNil(LStrList);
    end;
  finally
    FreeAndNil(LStream);
  end;
end;

procedure TGVUtil.ClearKeyboardBuffer;
var
  LMsg: TMsg;
begin
  while PeekMessage(LMsg, 0, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE or PM_NOYIELD) do;
end;

procedure TGVUtil.ClearMouseClickBuffer;
var
  LMsg: TMsg;
begin
  while PeekMessage(LMsg, 0, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE or PM_NOYIELD) do;
end;

const
  ADVAPI32 = 'advapi32.dll';
type
  HCRYPTPROV  = NativeUInt;
  PHCRYPTPROV = ^HCRYPTPROV;
  HCRYPTHASH  = NativeUInt;
  PHCRYPTHASH = ^HCRYPTHASH;
  HCRYPTKEY   = NativeUInt;
  PHCRYPTKEY  = ^HCRYPTKEY;
  ALG_ID      = NativeUInt;
  LPAWSTR     = PWideChar;

function CryptAcquireContext(phProv: PHCRYPTPROV; pszContainer: LPAWSTR; pszProvider: LPAWSTR; dwProvType: DWORD; dwFlags: DWORD): BOOL; stdcall; external ADVAPI32 name 'CryptAcquireContextW';
function CryptCreateHash(hProv: HCRYPTPROV; Algid: ALG_ID; hKey: HCRYPTKEY; dwFlags: DWORD; phHash: PHCRYPTHASH): BOOL; stdcall; external ADVAPI32 name 'CryptCreateHash';
function CryptHashData(hHash: HCRYPTHASH; const pbData: PBYTE; dwDataLen: DWORD; dwFlags: DWORD): BOOL; stdcall; external ADVAPI32 name 'CryptHashData';
function CryptDeriveKey(hProv: HCRYPTPROV; Algid: ALG_ID; hBaseData: HCRYPTHASH; dwFlags: DWORD; phKey: PHCRYPTKEY): BOOL; stdcall; external ADVAPI32 name 'CryptDeriveKey';
function CryptDestroyHash(hHash: HCRYPTHASH): BOOL; stdcall; external ADVAPI32 name 'CryptDestroyHash';
function CryptReleaseContext(hProv: HCRYPTPROV; dwFlags: DWORD): BOOL; stdcall; external ADVAPI32 name 'CryptReleaseContext';
function CryptEncrypt(hKey: HCRYPTKEY; hHash: HCRYPTHASH; Final_: BOOL; dwFlags: DWORD; pbData: PBYTE; pdwDataLen: PDWORD; dwBufLen: DWORD): BOOL; stdcall; external ADVAPI32 name 'CryptEncrypt';
function CryptDecrypt(hKey: HCRYPTKEY; hHash: HCRYPTHASH; Final_: BOOL; dwFlags: DWORD; pbData: PBYTE; pdwDataLen: PDWORD): BOOL; stdcall; external ADVAPI32 name 'CryptDecrypt';

procedure TGVUtil.CryptBuffer(const aBuffer: PByte; aLength: Cardinal; const aPassword: string; aToCrypt: Boolean);
const
  PROV_RSA_FULL          = 1;
  CRYPT_VERIFYCONTEXT    = $F0000000;
  ALG_CLASS_HASH         = (4 shl 13);
  ALG_TYPE_ANY           = 0;
  ALG_SID_SHA            = 4;
  CALG_SHA               = (ALG_CLASS_HASH or ALG_TYPE_ANY or ALG_SID_SHA);
  ALG_CLASS_DATA_ENCRYPT = (3 shl 13);
  ALG_TYPE_STREAM        = (4 shl 9);
  ALG_SID_RC4            = 1;
  CALG_RC4               = (ALG_CLASS_DATA_ENCRYPT or ALG_TYPE_STREAM or ALG_SID_RC4);
var
  LProv: HCRYPTPROV;
  LHash: HCRYPTHASH;
  LKey: HCRYPTKEY;
begin
  //get context for crypt default provider
  CryptAcquireContext(@LProv, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);

  //create hash-object (SHA algorithm)
  CryptCreateHash(LProv, CALG_SHA, 0, 0, @LHash);

  //get hash from password
  CryptHashData(LHash, @aPassword[1], Length(aPassword), 0);

  //create key from hash by RC4 algorithm
  CryptDeriveKey(LProv, CALG_RC4, LHash, 0, @LKey);

  //destroy hash-object
  CryptDestroyHash(LHash);

  if aToCrypt then
    //crypt buffer
    CryptEncrypt(LKey, 0, True, 0, aBuffer, @aLength, aLength)
  else
    //decrypt buffer
    CryptDecrypt(LKey, 0, True, 0, aBuffer, @aLength);

  //release the context for crypt default provider
  CryptReleaseContext(LProv, 0);
end;

(*
uint32_t version = al_get_allegro_version();
int major = version >> 24;
int minor = (version >> 16) & 255;
int revision = (version >> 8) & 255;
int release = version & 255;
*)
function TGVUtil.GetPackedVersion(aVersion: UInt32): string;
var
  LMajor: Integer;
  LMinor: Integer;
  LRevision: Integer;
  LRelease: Integer;
begin
  LMajor := aVersion shr 24;
  LMinor := (aVersion shr 16) and 255;
  LRevision := (aVersion shr 8) and 255;
  LRelease := aVersion and 255;
  Result := LMajor.ToString + '.' + LMinor.ToString + '.' + LRevision.ToString + '.' + LRelease.ToString;
end;

procedure TGVUtil.ProcessMessages;
var
  LMsg: TMsg;
begin
  while Integer(PeekMessage(LMsg, 0, 0, 0, PM_REMOVE)) <> 0 do
  begin
    TranslateMessage(LMsg);
    DispatchMessage(LMsg);
  end;
end;

function  TGVUtil.MicrosecondsToSeconds(aTime: Double): Double;
begin
  Result := aTime / 1000000.0;
end;

function  TGVUtil.MillisecondsToSeconds(aTime: Double): Double;
begin
  Result := aTime / 1000.0;
end;

function  TGVUtil.BeatsPerSecondToSeconds(aTime: Double): Double;
begin
  Result := 1.0 / aTime;
end;

function  TGVUtil.BeatsPerMinutoToSeconds(aTime: Double): Double;
begin
  Result := 60.0 / aTime;
end;

procedure TGVUtil.WriteStringToStream(const aStream: TStream; const aStr: string);
var
  LLength: LongInt;
begin
  LLength := Length(aStr);
  aStream.Write(LLength, SizeOf(LLength));
  if LLength > 0 then aStream.Write(aStr[1], LLength * SizeOf(Char));
end;

function  TGVUtil.ReadStringFromStream(const aStream: TStream): string;
var
  LLength: LongInt;
begin
  aStream.Read(LLength, SizeOf(LLength));
  SetLength(Result, LLength);
  if LLength > 0 then aStream.Read(Result[1], LLength * SizeOf(Char));
end;

function  TGVUtil.ReadStringFromBuffer(const aBuffer: TGVBuffer): string;
var
  LLength: LongInt;
begin
  aBuffer.Read(@LLength, SizeOf(LLength));
  SetLength(Result, LLength);
  if LLength > 0 then aBuffer.Read(@Result[1], LLength * SizeOf(Char));
end;

function TGVUtil.FileCount(const aPath: string; const aSearchMask: string): Int64;
var
  LSearchRec: TSearchRec;
  LPath: string;
begin
  Result := 0;
  LPath := aPath;
  LPath := System.IOUtils.TPath.Combine(aPath, aSearchMask);
  if FindFirst(LPath, faAnyFile, LSearchRec) = 0 then
    repeat
      if LSearchRec.Attr <> faDirectory then
        Inc(Result);
    until FindNext(LSearchRec) <> 0;
end;

function TGVUtil.FindLastWrittenFile(const aDir: string; const aSearch: string): string;
Var
 LSearchRec :TSearchRec;
 LLastWrite: TDateTime;
 LLastWriteAllFiles: TDateTime;
 LDir: string;
begin
 LDir := IncludeTrailingBackslash(aDir);
 LLastWriteAllFiles := 0;
 Result := '';
 if System.SysUtils.FindFirst(LDir+aSearch,faAnyFile-faDirectory,LSearchRec)=0 then
  repeat
   LLastWrite  := LSearchRec.TimeStamp;
   if LLastWrite > LLastWriteAllFiles Then
    begin
     LLastWriteAllFiles := LLastWrite;
     Result := TPath.Combine(LDir, LSearchRec.Name);
    end;
  until System.SysUtils.FindNext(LSearchRec)<>0;
 System.SysUtils.FindClose(LSearchRec);
end;

//Creates a mutex to see if the program is already running.
class function  TGVUtil.IsSingleInstance(aMutexName: string; aKeepMutex: Boolean=True): Boolean;
const
  MUTEX_GLOBAL = 'Global\'; // Prefix to explicitly create the object in the
                            // global or session namespace. I.e. both client
                            // app (local user) and service (system account)
var
  LMutexHandel : THandle;
  LSecurityDesc: TSecurityDescriptor;
  LSecurityAttr: TSecurityAttributes;
  LErrCode : integer;
begin
  //  By default (lpMutexAttributes =nil) created mutexes are accessible only by
  //  the user running the process. We need our mutexes to be accessible to all
  //  users, so that the mutex detection can work across user sessions.
  //  I.e. both the current user account and the System (Service) account.
  //  To do this we use a security descriptor with a null DACL.
  InitializeSecurityDescriptor(@LSecurityDesc, SECURITY_DESCRIPTOR_REVISION);
  SetSecurityDescriptorDacl(@LSecurityDesc, True, nil, False);
  LSecurityAttr.nLength:=SizeOf(LSecurityAttr);
  LSecurityAttr.lpSecurityDescriptor := @LSecurityDesc;
  LSecurityAttr.bInheritHandle:=False;

  //  The mutex is created in the global name space which makes it possible to
  //  access across user sessions.
  LMutexHandel := CreateMutex(@LSecurityAttr, True, PChar(MUTEX_GLOBAL + aMutexName));
  LErrCode := GetLastError;

  //  If the function fails, the return value is 0
  //  If the mutex is a named mutex and the object existed before this function
  //  call, the return value is a handle to the existing object, GetLastError
  //  returns ERROR_ALREADY_EXISTS.
  if {(MutexHandel = 0) or }(LErrCode = ERROR_ALREADY_EXISTS) then
  begin
    Result := false;
    CloseHandle(LMutexHandel);
  end
  else
  begin
    //  Mutex object has not yet been created, meaning that no previous
    //  instance has been created.
    Result := true;

    if not aKeepMutex then
       CloseHandle(LMutexHandel);
  end;

  // The Mutexhandle is not closed because we want it to exist during the
  // lifetime of the application. The system closes the handle automatically
  //when the process terminates.
end;

{ --- CONSOLE --------------------------------------------------------------- }
constructor TGVConsole.Create;
begin
  inherited;
end;

destructor TGVConsole.Destroy;
begin
  inherited;
end;

class function  TGVConsole.IsPresent: Boolean;
var
  LStdout: THandle;
begin
  LStdout := GetStdHandle(Std_Output_Handle);
  Win32Check(LStdout <> Invalid_Handle_Value);
  Result := LStdout <> 0;
end;

class function  TGVConsole.AtStartup: Boolean;
var
  LConsoleHWnd: THandle;
  LProcessId: DWORD;
begin
  LConsoleHWnd := GetConsoleWindow;
  if LConsoleHWnd <> 0 then
    begin
      GetWindowThreadProcessId(LConsoleHWnd, LProcessId);
      Result := GetCurrentProcessId <> LProcessId;
    end
  else
    Result := False;
end;

procedure TGVConsole.Print(const aMsg: string; const aArgs: array of const);
begin
  if not IsPresent then Exit;
  Write(Format(aMsg, aArgs));
end;

procedure TGVConsole.PrintLn;
begin
  if not IsPresent then Exit;
  WriteLn;
end;

procedure TGVConsole.PrintLn(const aMsg: string; const aArgs: array of const);
begin
  if not IsPresent then Exit;
  WriteLn(Format(aMsg, aArgs));
end;

procedure TGVConsole.WaitForInput;
var
  LInputRec: TInputRecord;
  LNumRead: Cardinal;
  LOldMode: DWORD;
  LStdIn: THandle;
begin
  LStdIn := GetStdHandle(STD_INPUT_HANDLE);
  GetConsoleMode(LStdIn, LOldMode);
  SetConsoleMode(LStdIn, 0);
  repeat
    ReadConsoleInput(LStdIn, LInputRec, 1, LNumRead);
  until (LInputRec.EventType and KEY_EVENT <> 0) and LInputRec.Event.KeyEvent.bKeyDown;
  SetConsoleMode(LStdIn, LOldMode);
end;

procedure TGVConsole.Pause;
begin
  if IsPresent and (not AtStartup) then
  begin
    WriteLn;
    Write('Press any key... ');
    WaitForInput;
    WriteLn;
  end;
end;

{ --- LOGGER ---------------------------------------------------------------- }
{ TGVLogger }
constructor TGVLogger.Create;
begin
  inherited;
  FFilename := '';
  FillChar(FBuffer, SizeOf(FBuffer), 0);
  FOpen := False;
  Open;
end;

destructor TGVLogger.Destroy;
begin
  Close;
  inherited;
end;

procedure TGVLogger.Open(const aFilename: string; aOverwrite: Boolean);
var
  LFilename: string;
begin
  Close;

  FFormatSettings.DateSeparator := '/';
  FFormatSettings.TimeSeparator := ':';
  FFormatSettings.ShortDateFormat := 'DD-MM-YYY HH:NN:SS';
  FFormatSettings.ShortTimeFormat := 'HH:NN:SS';

  LFilename := aFilename;

  if LFilename.IsEmpty then LFilename := ParamStr(0);
  LFilename := TPath.ChangeExtension(LFilename, GV_FILEEXT_LOG);

  AssignFile(FText, LFilename);
  if aOverwrite then
    ReWrite(FText)
  else
    begin
      if TFile.Exists(LFilename) then
        Reset(FText)
      else
        ReWrite(FText);
    end;
  SetTextBuf(FText, FBuffer);
  FOpen := True;
  FFilename := LFilename;
end;

procedure TGVLogger.Close;
begin
  if not FOpen then Exit;
  CloseFile(FText);
  FOpen := False;
end;

procedure TGVLogger.Log(const aMsg: string; const aArgs: array of const; aWriteToConsole: Boolean=False);
var
  LLine: string;
begin
  if not FOpen then Exit;

  // get line
  LLine := Format(aMsg, aArgs);

  // write to console
  if aWriteToConsole then
  begin
    if GV <> nil then
      GV.Console.PrintLn(LLine, []);
  end;

  // write to logfile
  {$I-}
  LLine := Format('%s %s', [DateTimeToStr(Now, FFormatSettings), LLine]);
  Writeln(FText, LLine);
  Flush(FText);
  {$I+}
end;

procedure TGVLogger.Exception(const aMsg: string; const aArgs: array of const; aWriteToConsole: Boolean=False);
var
  LMsg: string;
begin
  LMsg := Format(aMsg, aArgs);
  Log(LMsg, [], aWriteToConsole);
  raise System.SysUtils.Exception.Create(LMsg);
end;

class procedure TGVLogger.Fatal(const aMsg: string; const aArgs: array of const; aWriteToConsole: Boolean=False);
var
  LLog: TStringList;
  LLine: string;
  FFormatSettings : TFormatSettings;
  LFilename: string;
begin
  FFormatSettings.DateSeparator := '/';
  FFormatSettings.TimeSeparator := ':';
  FFormatSettings.ShortDateFormat := 'DD-MM-YYY HH:NN:SS';
  FFormatSettings.ShortTimeFormat := 'HH:NN:SS';

  LLine := Format(aMsg, aArgs);
  LLine := Format('%s %s', [DateTimeToStr(Now, FFormatSettings), LLine]);

  LLog := TStringList.Create;
  try
    LFilename := TPath.ChangeExtension(ParamStr(0), GV_FILEEXT_LOG);
    if TFile.Exists(LFilename) then
      LLog.LoadFromFile(LFilename);
    LLog.Add(LLine);
    LLog.SaveToFile(LFilename);
  finally
    FreeAndNil(LLog);
  end;
  if TFile.Exists(LFilename) then
    ShellExecute(0, 'OPEN', PChar(LFilename), '', '', SW_SHOWNORMAL);
end;

{ --- CMDLINE --------------------------------------------------------------- }
{ CmdLine }
constructor TGVCmdLine.Create;
begin
  inherited;
  Reset;
end;

destructor TGVCmdLine.Destroy;
begin
  inherited;
end;

function TGVCmdLine.GetCmdLine: PChar;
begin
  Result := PChar(FCmdLine);
end;

function TGVCmdLine.GetParamStr(aParamStr: PChar; var aParam: string): PChar;
var
  LIndex, LLen: Integer;
  LStart, LStr: PChar;
begin
  // U-OK
  while True do
  begin
    while (aParamStr[0] <> #0) and (aParamStr[0] <= ' ') do
      Inc(aParamStr);
    if (aParamStr[0] = '"') and (aParamStr[1] = '"') then Inc(aParamStr, 2) else Break;
  end;
  LLen := 0;
  LStart := aParamStr;
  while aParamStr[0] > ' ' do
  begin
    if aParamStr[0] = '"' then
    begin
      Inc(aParamStr);
      while (aParamStr[0] <> #0) and (aParamStr[0] <> '"') do
      begin
        Inc(LLen);
        Inc(aParamStr);
      end;
      if aParamStr[0] <> #0 then
        Inc(aParamStr);
    end
    else
    begin
      Inc(LLen);
      Inc(aParamStr);
    end;
  end;

  SetLength(aParam, LLen);

  aParamStr := LStart;
  LStr := Pointer(aParam);
  LIndex := 0;
  while aParamStr[0] > ' ' do
  begin
    if aParamStr[0] = '"' then
    begin
      Inc(aParamStr);
      while (aParamStr[0] <> #0) and (aParamStr[0] <> '"') do
      begin
        LStr[LIndex] := aParamStr^;
        Inc(aParamStr);
        Inc(LIndex);
      end;
      if aParamStr[0] <> #0 then Inc(aParamStr);
    end
    else
    begin
      LStr[LIndex] := aParamStr^;
      Inc(aParamStr);
      Inc(LIndex);
    end;
  end;

  Result := aParamStr;
end;

function TGVCmdLine.ParamCount: Integer;
var
  LPtr: PChar;
  LStr: string;
begin
  // U-OK
  Result := 0;
  LPtr := Self.GetParamStr(GetCmdLine, LStr);
  while True do
  begin
    LPtr := Self.GetParamStr(LPtr, LStr);
    if LStr = '' then Break;
    Inc(Result);
  end;
end;

procedure TGVCmdLine.Reset;
begin
  // init commandline
  FCmdLine := System.CmdLine + ' ';
end;

procedure TGVCmdLine.ClearParams;
begin
  FCmdLine := '';
end;

procedure TGVCmdLine.AddAParam(const aParam: string);
var
  LParam: string;
begin
  LParam := aParam.Trim;
  if LParam.IsEmpty then Exit;
  FCmdLine := FCmdLine + LParam + ' ';
end;

procedure TGVCmdLine.AddParams(const aParams: string);
var
  LParams: TStringDynArray;
  LIndex: Integer;
begin
  LParams := aParams.Split([' '], TStringSplitOptions.ExcludeEmpty);
  for LIndex := 0 to Length(LParams)-1 do
  begin
    AddAParam(LParams[LIndex]);
  end;
end;

function TGVCmdLine.ParamStr(aIndex: Integer): string;
var
  LPtr: PChar;
  LBuffer: array[0..260] of Char;
begin
  Result := '';
  if aIndex = 0 then
    SetString(Result, LBuffer, GetModuleFileName(0, LBuffer, Length(LBuffer)))
  else
  begin
    LPtr := GetCmdLine;
    while True do
    begin
      LPtr := Self.GetParamStr(LPtr, Result);
      if (aIndex = 0) or (Result = '') then Break;
      Dec(aIndex);
    end;
  end;
end;

function TGVCmdLine.GetParamValue(const aParamName: string; aSwitchChars: TSysCharSet; aSeperator: Char; var aValue: string): Boolean;
var
  LIndex, LSep: Longint;
  LStr: string;
begin

  Result := False;
  aValue := '';

  // check for first non switch param when aParamName = '' and no
  // other params are found
  if (aParamName = '') then
  begin
    for LIndex := 1 to Self.ParamCount do
    begin
      LStr := Self.ParamStr(LIndex);
      if Length(LStr) > 0 then
        // if S[1] in aSwitchChars then
        if not CharInSet(LStr[1], aSwitchChars) then
        begin
          aValue := LStr;
          Result := True;
          Exit;
        end;
    end;
    Exit;
  end;

  // check for switch params
  for LIndex := 1 to Self.ParamCount do
  begin
    LStr := Self.ParamStr(LIndex);
    if Length(LStr) > 0 then
      // if S[1] in aSwitchChars then
      if CharInSet(LStr[1], aSwitchChars) then

      begin
        LSep := Pos(aSeperator, LStr);

        case LSep of
          0:
            begin
              if CompareText(Copy(LStr, 2, Length(LStr) - 1), aParamName) = 0 then
              begin
                Result := True;
                Break;
              end;
            end;
          1 .. MaxInt:
            begin
              if CompareText(Copy(LStr, 2, LSep - 2), aParamName) = 0 then
              // if CompareText(Copy(S, 1, Sep -1), aParamName) = 0 then
              begin
                aValue := Copy(LStr, LSep + 1, Length(LStr));
                Result := True;
                Break;
              end;
            end;
        end; // case
      end
  end;
end;

function TGVCmdLine.GetParamValue(const aParamName: string; var aValue: string): Boolean;
begin
  Result := Self.GetParamValue(aParamName, ['/', '-'], '=', aValue);
end;

function TGVCmdLine.ParamExist(const aParamName: string): Boolean;
var
  LValue: string;
begin
  Result := Self.GetParamValue(aParamName, ['/', '-'], '=', LValue);
  if not Result then
  begin
    Result := SameText(aParamName, Self.ParamStr(1));
  end;
end;

{ --- USERPATH -------------------------------------------------------------- }
constructor TGVUserPath.Create;
begin
  inherited;
  Reset;
end;

destructor TGVUserPath.Destroy;
begin
  inherited;
end;

procedure TGVUserPath.Reset;
begin
  FOrgName := '';
  FAppId := '';
end;

procedure TGVUserPath.SetOrgName(const aName: string);
begin
  FOrgName := aName;
end;

function  TGVUserPath.GetOrgName: string;
begin
  Result := FOrgName;
end;

procedure TGVUserPath.SetAppId(const aId: string);
begin
  FAppId := aId;
end;

function  TGVUserPath.GetAppId: string;
begin
  Result := FAppId;
end;

function  TGVUserPath.GetAppIdPath: string;
begin
  Result := TPath.Combine(TPath.GetHomePath, FOrgName);
  Result := TPath.Combine(Result, FAppId);
end;

function  TGVUserPath.GetPath: string;
begin
  Result := TPath.Combine(TPath.GetHomePath, FOrgName);
  Result := TPath.Combine(Result, FAppId);
  Result := TPath.Combine(Result, TPath.GetFileNameWithoutExtension(ParamStr(0)));
end;

function  TGVUserPath.GetPath(const aPath: string): string;
begin
  Result := TPath.Combine(GetPath, aPath);
end;

function  TGVUserPath.CreateDirs: Boolean;
begin
  Result := GV.Util.CreateDirsInPath(GetPath('temp.dat'));
end;

function  TGVUserPath.GetConfigFilename: string;
begin
  Result := TPath.GetFileName(ParamStr(0));
  Result := TPath.ChangeExtension(Result, GV_FILEEXT_INI);
  Result := GetPath(Result);
end;

function  TGVUserPath.GetLogFilename: string;
begin
  Result := TPath.GetFileName(ParamStr(0));
  Result := TPath.ChangeExtension(Result, GV_FILEEXT_LOG);
  Result := GetPath(Result);
end;

{ --- MATH ------------------------------------------------------------------ }
{ TGVMath }
constructor TGVMath.Create;
var
  LI: Integer;
begin
  inherited;

  Randomize;

  for LI := 0 to 360 do
  begin
    FCosTable[LI] := cos((LI * PI / 180.0));
    FSinTable[LI] := sin((LI * PI / 180.0));
  end;
end;

destructor TGVMath.Destroy;
begin
  inherited;
end;

procedure TGVMath.Randomize;
begin
  System.Randomize;
end;

function  TGVMath.RandomRange(aMin, aMax: Integer): Integer;
begin
  Result := System.Math.RandomRange(aMin, aMax + 1);
end;

function  TGVMath.RandomRange(aMin, aMax: Single): Single;
var
  LNum: Single;
begin
  LNum := System.Math.RandomRange(0, MaxInt) / MaxInt;
  Result := aMin + (LNum * (aMax - aMin));
end;

function  TGVMath.RandomBool: Boolean;
begin
  Result := Boolean(System.Math.RandomRange(0, 2) = 1);
end;

function  TGVMath.GetRandomSeed: Integer;
begin
  Result := System.RandSeed;
end;

procedure TGVMath.SetRandomSeed(aValue: Integer);
begin
  System.RandSeed := aValue;
end;

function  TGVMath.AngleCos(aAngle: Integer): Single;
begin
  Result := 0;
  if (aAngle < 0) or (aAngle > 360) then Exit;
  Result := FCosTable[aAngle];
end;

function  TGVMath.AngleSin(aAngle: Integer): Single;
begin
  Result := 0;
  if (aAngle < 0) or (aAngle > 360) then Exit;
  Result := FSinTable[aAngle];
end;

function  TGVMath.AngleDifference(aSrcAngle: Single; aDestAngle: Single): Single;
var
  LC: Single;
begin
  LC := aDestAngle - aSrcAngle -
    (Floor((aDestAngle - aSrcAngle) / 360.0) * 360.0);

  if LC >= (360.0 / 2) then
  begin
    LC := LC - 360.0;
  end;
  Result := LC;
end;

procedure TGVMath.AngleRotatePos(aAngle: Single; var aX: Single; var aY: Single);
var
  LNX, LNY: Single;
  LIA: Integer;
begin
  ClipValue(aAngle, 0, 359, True);

  LIA := Round(aAngle);

  LNX := aX * FCosTable[LIA] - aY * FSinTable[LIA];
  LNY := aY * FCosTable[LIA] + aX * FSinTable[LIA];

  aX := LNX;
  aY := LNY;
end;

function  TGVMath.ClipValue(var aValue: Single; aMin: Single; aMax: Single; aWrap: Boolean): Single;
begin
  if aWrap then
    begin
      if (aValue > aMax) then
      begin
        aValue := aMin + Abs(aValue - aMax);
        if aValue > aMax then
          aValue := aMax;
      end
      else if (aValue < aMin) then
      begin
        aValue := aMax - Abs(aValue - aMin);
        if aValue < aMin then
          aValue := aMin;
      end
    end
  else
    begin
      if aValue < aMin then
        aValue := aMin
      else if aValue > aMax then
        aValue := aMax;
    end;

  Result := aValue;

end;

function  TGVMath.ClipValue(var aValue: Integer; aMin: Integer; aMax: Integer; aWrap: Boolean): Integer;
begin
  if aWrap then
    begin
      if (aValue > aMax) then
      begin
        aValue := aMin + Abs(aValue - aMax);
        if aValue > aMax then
          aValue := aMax;
      end
      else if (aValue < aMin) then
      begin
        aValue := aMax - Abs(aValue - aMin);
        if aValue < aMin then
          aValue := aMin;
      end
    end
  else
    begin
      if aValue < aMin then
        aValue := aMin
      else if aValue > aMax then
        aValue := aMax;
    end;

  Result := aValue;
end;

function  TGVMath.SameSign(aValue1: Integer; aValue2: Integer): Boolean;
begin
  if Sign(aValue1) = Sign(aValue2) then
    Result := True
  else
    Result := False;
end;

function  TGVMath.SameSign(aValue1: Single; aValue2: Single): Boolean;
begin
  if Sign(aValue1) = Sign(aValue2) then
    Result := True
  else
    Result := False;
end;

function  TGVMath.SameValue(aA: Double; aB: Double; aEpsilon: Double): Boolean;
begin
  Result := System.Math.SameValue(aA, aB, aEpsilon);
end;

function  TGVMath.SameValue(aA: Single; aB: Single; aEpsilon: Single): Boolean;
begin
  Result := System.Math.SameValue(aA, aB, aEpsilon);
end;

function  TGVMath.Vector(aX: Single; aY: Single): TGVVector;
begin
  Result.X := aX;
  Result.Y := aY;
  Result.Z := 0;
  Result.Z := 0;
  Result.W := 0;
end;

function  TGVMath.Rectangle(aX: Single; aY: Single; aWidth: Single; aHeight: Single): TGVRectangle;
begin
  Result.X := aX;
  Result.Y := aY;
  Result.Width := aWidth;
  Result.Height := aHeight;
end;

procedure TGVMath.SmoothMove(var aValue: Single; aAmount: Single; aMax: Single; aDrag: Single);
var
  LAmt: Single;
begin
  LAmt := aAmount;

  if LAmt > 0 then
  begin
    aValue := aValue + LAmt;
    if aValue > aMax then
      aValue := aMax;
  end else if LAmt < 0 then
  begin
    aValue := aValue + LAmt;
    if aValue < -aMax then
      aValue := -aMax;
  end else
  begin
    if aValue > 0 then
    begin
      aValue := aValue - aDrag;
      if aValue < 0 then
        aValue := 0;
    end else if aValue < 0 then
    begin
      aValue := aValue + aDrag;
      if aValue > 0 then
        aValue := 0;
    end;
  end;
end;

function  TGVMath.Lerp(aFrom: Double; aTo: Double; aTime: Double): Double;
begin
  if aTime <= 0.5 then
    Result := aFrom + (aTo - aFrom) * aTime
  else
    Result := aTo - (aTo - aFrom) * (1.0 - aTime);
end;

{ --- COLLISION ------------------------------------------------------------- }
{ TGVCollision }
constructor TGVCollision.Create;
begin
  inherited;
end;

destructor TGVCollision.Destroy;
begin
  inherited;
end;

function TGVCollision.PointInRectangle(aPoint: TGVVector; aRect: TGVRectangle): Boolean;
begin
  if ((aPoint.x >= aRect.x) and (aPoint.x <= (aRect.x + aRect.width)) and
    (aPoint.y >= aRect.y) and (aPoint.y <= (aRect.y + aRect.height))) then
    Result := True
  else
    Result := False;
end;

function TGVCollision.PointInCircle(aPoint, aCenter: TGVVector; aRadius: Single): Boolean;
begin
  Result := CirclesOverlap(aPoint, 0, aCenter, aRadius);
end;

function TGVCollision.PointInTriangle(aPoint, aP1, aP2, aP3: TGVVector): Boolean;
var
  LAlpha, LBeta, LGamma: Single;
begin
  LAlpha := ((aP2.y - aP3.y) * (aPoint.x - aP3.x) + (aP3.x - aP2.x) *
    (aPoint.y - aP3.y)) / ((aP2.y - aP3.y) * (aP1.x - aP3.x) + (aP3.x - aP2.x) *
    (aP1.y - aP3.y));

  LBeta := ((aP3.y - aP1.y) * (aPoint.x - aP3.x) + (aP1.x - aP3.x) *
    (aPoint.y - aP3.y)) / ((aP2.y - aP3.y) * (aP1.x - aP3.x) + (aP3.x - aP2.x) *
    (aP1.y - aP3.y));

  LGamma := 1.0 - LAlpha - LBeta;

  if ((LAlpha > 0) and (LBeta > 0) and (LGamma > 0)) then
    Result := True
  else
    Result := False;
end;

function TGVCollision.CirclesOverlap(aCenter1: TGVVector; aRadius1: Single; aCenter2: TGVVector; aRadius2: Single): Boolean;
var
  LDX, LDY, LDistance: Single;
begin
  LDX := aCenter2.x - aCenter1.x; // X distance between centers
  LDY := aCenter2.y - aCenter1.y; // Y distance between centers

  LDistance := sqrt(LDX * LDX + LDY * LDY); // Distance between centers

  if (LDistance <= (aRadius1 + aRadius2)) then
    Result := True
  else
    Result := False;
end;

function TGVCollision.CircleInRectangle(aCenter: TGVVector; aRadius: Single; aRect: TGVRectangle): Boolean;
var
  LDX, LDY: Single;
  LCornerDistanceSq: Single;
  LRecCenterX: Integer;
  LRecCenterY: Integer;
begin
  LRecCenterX := Round(aRect.x + aRect.width / 2);
  LRecCenterY := Round(aRect.y + aRect.height / 2);

  LDX := abs(aCenter.x - LRecCenterX);
  LDY := abs(aCenter.y - LRecCenterY);

  if (LDX > (aRect.width / 2.0 + aRadius)) then
  begin
    Result := False;
    Exit;
  end;

  if (LDY > (aRect.height / 2.0 + aRadius)) then
  begin
    Result := False;
    Exit;
  end;

  if (LDX <= (aRect.width / 2.0)) then
  begin
    Result := True;
    Exit;
  end;
  if (LDY <= (aRect.height / 2.0)) then
  begin
    Result := True;
    Exit;
  end;

  LCornerDistanceSq := (LDX - aRect.width / 2.0) * (LDX - aRect.width / 2.0) +
    (LDY - aRect.height / 2.0) * (LDY - aRect.height / 2.0);

  Result := Boolean(LCornerDistanceSq <= (aRadius * aRadius));
end;

function TGVCollision.RectanglesOverlap(aRect1: TGVRectangle; aRect2: TGVRectangle): Boolean;
var
  LDX, LDY: Single;
begin
  LDX := abs((aRect1.x + aRect1.width / 2) - (aRect2.x + aRect2.width / 2));
  LDY := abs((aRect1.y + aRect1.height / 2) - (aRect2.y + aRect2.height / 2));

  if ((LDX <= (aRect1.width / 2 + aRect2.width / 2)) and
    ((LDY <= (aRect1.height / 2 + aRect2.height / 2)))) then
    Result := True
  else
    Result := False;
end;

function TGVCollision.RectangleIntersection(aRect1, aRect2: TGVRectangle): TGVRectangle;
var
  LDXX, LDYY: Single;
begin
  Result.Assign(0, 0, 0, 0);

  if RectanglesOverlap(aRect1, aRect2) then
  begin
    LDXX := abs(aRect1.x - aRect2.x);
    LDYY := abs(aRect1.y - aRect2.y);

    if (aRect1.x <= aRect2.x) then
    begin
      if (aRect1.y <= aRect2.y) then
      begin
        Result.x := aRect2.x;
        Result.y := aRect2.y;
        Result.width := aRect1.width - LDXX;
        Result.height := aRect1.height - LDYY;
      end
      else
      begin
        Result.x := aRect2.x;
        Result.y := aRect1.y;
        Result.width := aRect1.width - LDXX;
        Result.height := aRect2.height - LDYY;
      end
    end
    else
    begin
      if (aRect1.y <= aRect2.y) then
      begin
        Result.x := aRect1.x;
        Result.y := aRect2.y;
        Result.width := aRect2.width - LDXX;
        Result.height := aRect1.height - LDYY;
      end
      else
      begin
        Result.x := aRect1.x;
        Result.y := aRect1.y;
        Result.width := aRect2.width - LDXX;
        Result.height := aRect2.height - LDYY;
      end
    end;

    if (aRect1.width > aRect2.width) then
    begin
      if (Result.width >= aRect2.width) then
        Result.width := aRect2.width;
    end
    else
    begin
      if (Result.width >= aRect1.width) then
        Result.width := aRect1.width;
    end;

    if (aRect1.height > aRect2.height) then
    begin
      if (Result.height >= aRect2.height) then
        Result.height := aRect2.height;
    end
    else
    begin
      if (Result.height >= aRect1.height) then
        Result.height := aRect1.height;
    end
  end;
end;

function TGVCollision.LineIntersection(aX1, aY1, aX2, aY2, aX3, aY3, aX4, aY4: Integer; var aX: Integer; var aY: Integer): TGVLineIntersection;
var
  LAX, LBX, LCX, LAY, LBY, LCY, LD, LE, LF, LNum: Integer;
  LOffset: Integer;
  LX1Lo, LX1Hi, LY1Lo, LY1Hi: Integer;
begin
  Result := TGVLineIntersection.None;

  LAX := aX2 - aX1;
  LBX := aX3 - aX4;

  if (LAX < 0) then // X bound box test
  begin
    LX1Lo := aX2;
    LX1Hi := aX1;
  end
  else
  begin
    LX1Hi := aX2;
    LX1Lo := aX1;
  end;

  if (LBX > 0) then
  begin
    if (LX1Hi < aX4) or (aX3 < LX1Lo) then
      Exit;
  end
  else
  begin
    if (LX1Hi < aX3) or (aX4 < LX1Lo) then
      Exit;
  end;

  LAY := aY2 - aY1;
  LBY := aY3 - aY4;

  if (LAY < 0) then // Y bound box test
  begin
    LY1Lo := aY2;
    LY1Hi := aY1;
  end
  else
  begin
    LY1Hi := aY2;
    LY1Lo := aY1;
  end;

  if (LBY > 0) then
  begin
    if (LY1Hi < aY4) or (aY3 < LY1Lo) then
      Exit;
  end
  else
  begin
    if (LY1Hi < aY3) or (aY4 < LY1Lo) then
      Exit;
  end;

  LCX := aX1 - aX3;
  LCY := aY1 - aY3;
  LD := LBY * LCX - LBX * LCY; // alpha numerator
  LF := LAY * LBX - LAX * LBY; // both denominator

  if (LF > 0) then // alpha tests
  begin
    if (LD < 0) or (LD > LF) then
      Exit;
  end
  else
  begin
    if (LD > 0) or (LD < LF) then
      Exit
  end;

  LE := LAX * LCY - LAY * LCX; // beta numerator
  if (LF > 0) then // beta tests
  begin
    if (LE < 0) or (LE > LF) then
      Exit;
  end
  else
  begin
    if (LE > 0) or (LE < LF) then
      Exit;
  end;

  // compute intersection coordinates

  if (LF = 0) then
  begin
    Result := TGVLineIntersection.Parallel;
    Exit;
  end;

  LNum := LD * LAX; // numerator
  // if SameSigni(num, f) then
  if Sign(LNum) = Sign(LF) then

    LOffset := LF div 2
  else
    LOffset := -LF div 2;
  aX := aX1 + (LNum + LOffset) div LF; // intersection x

  LNum := LD * LAY;
  // if SameSigni(num, f) then
  if Sign(LNum) = Sign(LF) then
    LOffset := LF div 2
  else
    LOffset := -LF div 2;

  aY := aY1 + (LNum + LOffset) div LF; // intersection y

  Result := TGVLineIntersection.Cross;
end;

function TGVCollision.RadiusOverlap(aRadius1, aX1, aY1, aRadius2, aX2, aY2, aShrinkFactor: Single): Boolean;

var
  LDist: Single;
  LR1, LR2: Single;
  LV1, LV2: TGVVector;
begin
  LR1 := aRadius1 * aShrinkFactor;
  LR2 := aRadius2 * aShrinkFactor;

  LV1.x := aX1;
  LV1.y := aY1;
  LV2.x := aX2;
  LV2.y := aY2;

  LDist := LV1.distance(LV2);

  if (LDist < LR1) or (LDist < LR2) then
    Result := True
  else
    Result := False;
end;

{ --- ARCHIVE --------------------------------------------------------------- }
{ TGVArchive }
function TGVArchive.GetCRC32(aStream: TStream): Cardinal;
var
  LBytesRead: Integer;
  LBuffer: array of Byte;
begin
  SetLength(LBuffer, 65521);

  Result := Crc32(0, nil, 0);
  repeat
    LBytesRead := AStream.Read(LBuffer[0], Length(LBuffer));
    Result := Crc32(Result, @LBuffer[0], LBytesRead);
  until LBytesRead = 0;

  LBuffer := nil;
end;

constructor TGVArchive.Create;
begin
  inherited;
  FFilename := '';
  FPassword := '';
  FIsOpen := False;
end;

destructor TGVArchive.Destroy;
begin
  Close;
  inherited;
end;

function TGVArchive.Open(const aPassword: string; const aFilename: string): Boolean;
var
  LMarshaller: TMarshaller;
begin
  Result := False;
  if FIsOpen then Exit;
  if not TFile.Exists(aFilename) then Exit;
  Result := Boolean(PHYSFS_mount(LMarshaller.AsUtf8(aFilename).ToPointer, nil, 1) <> 0);
  if Result then
  begin
    FPassword := aPassword;
    FFilename := aFilename;
    FPasswordFilename := '';
    FIsOpen := True;
  end;
end;

function TGVArchive.Close: Boolean;
var
  LMarshaller: TMarshaller;
begin
  Result := False;
  if not FIsOpen then Exit;
  Result := Boolean(PHYSFS_unmount(LMarshaller.AsUtf8(FFilename).ToPointer) <> 0);
  if Result then
  begin
    FIsOpen := False;
    FFilename := '';
    FPassword := '';
    FPasswordFilename := '';
  end;
end;

function TGVArchive.FileExist(const aFilename: string): Boolean;
var
  LMarshaller: TMarshaller;
begin
  Result := al_filename_exists(LMarshaller.AsUtf8(aFilename).ToPointer);
end;

function TGVArchive.GetPasswordFilename(const aFilename: string): PAnsiChar;
begin
  if FPassword.IsEmpty then
    FPasswordFilename := aFilename
  else
    FPasswordFilename := aFilename + '$' + FPassword;
  Result := PAnsiChar(AnsiString(FPasswordFilename));
end;

function TGVArchive.OpenFile(const aFilename: string): TGVArchiveFile;
var
  LResult: TGVArchiveFile;
begin
  Result := nil;
  if not FIsOpen then Exit;
  LResult := TGVArchiveFIle.Create;
  if not LResult.Open(Self, aFilename) then
  begin
    FreeAndNil(LResult);
    Exit;
  end;
  Result := LResult;
end;

function TGVArchive.ExtractToBuffer(const aFilename: string): TGVBuffer;
var
  LFile: TGVArchiveFile;
  LResult: TGVBuffer;
begin
  Result := nil;
  if not FIsOpen then Exit;
  LFile := OpenFile(aFilename);
  if LFile = nil then Exit;
  if LFile.Size = 0 then
  begin
    FreeAndNil(LFile);
    Exit;
  end;
  LResult := TGVBuffer.Create;
  if not LResult.Allocate(LFile.Size) then
  begin
    FreeAndNil(LResult);
    FreeAndNil(LFile);
    Exit;
  end;
  LFile.Read(LResult.Memory, LResult.Size);
  FreeAndNil(LFile);
  Result := LResult;
end;

function TGVArchive.Build(const aPassword: string; const aFilename: string; const aDirectory: string; aOnProgress: TGVArchiveBuildProgressEvent): Boolean;
var
  LMarshaller: array[0..1] of TMarshaller;
  LFileList: TStringDynArray;
  LFilename: string;
  LZipFile: zipFile;
  LZipFileInfo: zip_fileinfo;
  LFile: TStream;
  LCrc: Cardinal;
  LBytesRead: Integer;
  LBuffer: array of Byte;
  LFileSize: Int64;
  LProgress: Single;
  LNewFile: Boolean;
begin
  Result := False;

  // check if directory exists
  if not TDirectory.Exists(aDirectory) then Exit;

  // init variabls
  SetLength(LBuffer, 1024*4);
  FillChar(LZipFileInfo, SizeOf(LZipFileInfo), 0);

  // scan folder and build file list
  LFileList := TDirectory.GetFiles(aDirectory, '*', TSearchOption.soAllDirectories);

  // create a zip file
  LZipFile := zipOpen(LMarshaller[0].AsUtf8(aFilename).ToPointer, APPEND_STATUS_CREATE);

  // process zip file
  if LZipFile <> nil then
  begin
    // loop through all files in list
    for LFilename in LFileList do
    begin
      // open file
      LFile := TFile.OpenRead(LFilename);

      // get file size
      LFileSize := LFile.Size;

      // get file crc
      LCrc := GetCRC32(LFile);

      // open new file in zip
      if ZipOpenNewFileInZip3(LZipFile, LMarshaller[0].AsUtf8(LFilename).ToPointer,
        @LZipFileInfo, nil, 0, nil, 0, '',  Z_DEFLATED, 9, 0, 15, 9,
        Z_DEFAULT_STRATEGY, LMarshaller[1].AsUtf8(aPassword).ToPointer, LCrc) = Z_OK then
      begin
        // make sure we start at star of stream
        LFile.Position := 0;

        // this is a new file
        LNewFile := True;

        // read through file
        repeat
          // read in a buffer length of file
          LBytesRead := LFile.Read(LBuffer[0], Length(LBuffer));

          // write buffer out to zip file
          zipWriteInFileInZip(LZipFile, @LBuffer[0], LBytesRead);

          // calc file progress percentage
          LProgress := 100.0 * (LFile.Position / LFileSize);

          // show progress
          if Assigned(aOnProgress) then
            aOnProgress(LFilename, Round(LProgress), LNewFile);

          // reset new file flag
          LNewFile := False;
        until LBytesRead = 0;

        // close file in zip
        zipCloseFileInZip(LZipFile);

        // free file stream
        FreeAndNil(LFile);
      end;
    end;

    // close zip file
    zipClose(LZipFile, '');
  end;

  // return true if new zip file exits
  Result := TFile.Exists(aFilename);
end;

{ --- ARCHIVEFILE ----------------------------------------------------------- }
{ TGVArchiveFile }
constructor TGVArchiveFile.Create;
begin
  inherited;
  FHandle := nil;
end;

destructor TGVArchiveFile.Destroy;
begin
  Close;
  inherited;
end;

function TGVArchiveFile.Open(aArchive: TGVArchive; const aFilename: string): Boolean;
var
  LHandle: PALLEGRO_FILE;
begin
  Result := False;
  if IsOpen then Exit;
  if aArchive = nil then Exit;
  if not aArchive.IsOpen then Exit;
  if not aArchive.FileExist(aFilename) then Exit;
  if aArchive = nil then GV.SetFileSandBoxed(False);
  LHandle := al_fopen(aArchive.GetPasswordFilename(aFilename), 'rb');
  if aArchive = nil then GV.SetFileSandBoxed(True);
  if LHandle = nil then Exit;
  FHandle := LHandle;
  Result := IsOpen;
end;

function TGVArchiveFile.Close: Boolean;
begin
  Result := False;
  if not IsOpen then Exit;
  Result := al_fclose(FHandle);
  if Result then
  begin
    FHandle := nil;
  end;
end;

function TGVArchiveFile.IsOpen: Boolean;
begin
  Result := Boolean(FHandle <> nil);
end;

function TGVArchiveFile.Size: UInt64;
begin
  Result := 0;
  if not IsOpen then Exit;
  Result := al_fsize(FHandle);
end;

function TGVArchiveFile.Eof: Boolean;
begin
  Result := False;
  if not IsOpen then Exit;
  Result := al_feof(FHandle);
end;

function TGVArchiveFile.Seek(aOffset: Int64; aSeek: TGVSeek): UInt64;
var
  LSeek: Boolean;
begin
  Result := 0;
  if not IsOpen then Exit;
  LSeek := al_fseek(FHandle, aOffset, Ord(aSeek));
  if LSeek then
    Result := Self.Tell;
end;

function TGVArchiveFile.Tell: UInt64;
var
  LResult: Int64;
begin
  Result := 0;
  if not IsOpen then Exit;
  LResult := al_ftell(FHandle);
  if LResult = -1 then Exit;
  Result := LResult;
end;

function TGVArchiveFile.Read(aBuffer: Pointer; aSize: UInt64): UInt64;
begin
  Result := 0;
  if not IsOpen then Exit;
  Result := al_fread(FHandle, aBuffer, aSize);
end;

function TGVArchiveFile.LastError: string;
begin
  Result := '';
  if not IsOpen then Exit;
  Result := string(al_ferrmsg(FHandle));
end;

{ --- TEXTURE --------------------------------------------------------------- }
{ TGVTexture }
constructor TGVTexture.Create;
begin
  inherited;
end;

destructor TGVTexture.Destroy;
begin
  Unload;
  inherited;
end;

function  TGVTexture.Allocate(aWidth: Integer; aHeight: Integer): Boolean;
var
  LHandle: PALLEGRO_BITMAP;
begin
  Result := False;
  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR or ALLEGRO_MIPMAP or ALLEGRO_VIDEO_BITMAP);
  LHandle := al_create_bitmap(aWidth, aHeight);
  if LHandle = nil then Exit;
  Unload;
  FHandle := LHandle;
  FWidth := al_get_bitmap_width(FHandle);
  FHeight := al_get_bitmap_height(FHandle);
  FFilename := '';
  Result := True;
end;

function  TGVTexture.Load(aArchive: TGVArchive; const aFilename: string; aColorKey: PGVColor): Boolean;
var
  LMarshaller: TMarshaller;
  LHandle: PALLEGRO_BITMAP;
  LFilename: string;
  LColorKey: PALLEGRO_COLOR absolute aColorKey;
begin
  Result := False;
  if aFilename.IsEmpty then Exit;

  if aArchive <> nil then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileExist(aFilename) then Exit;
      LFilename := string(aArchive.GetPasswordFilename(aFilename));
    end
  else
    begin
      if not TFile.Exists(aFilename) then Exit;
      LFilename := aFilename;
    end;

   if aArchive = nil then GV.SetFileSandBoxed(False);
   LHandle := al_load_bitmap(LMarshaller.AsUtf8(LFilename).ToPointer);
   if aArchive = nil then GV.SetFileSandBoxed(True);
   if LHandle = nil then Exit;

  Unload;
  FHandle := LHandle;
  FWidth := al_get_bitmap_width(FHandle);
  FHeight := al_get_bitmap_height(FHandle);
  FFilename := aFilename;

  if aColorKey <> nil then
    al_convert_mask_to_alpha(FHandle, LColorKey^);

  Result := True;
end;

function TGVTexture.Unload: Boolean;
begin
  Result := False;
  if FHandle = nil then Exit;
  al_destroy_bitmap(FHandle);
  FHandle := nil;
  FWidth := 0;
  FHeight := 0;
  FLocked := False;
  FFilename := '';
end;

function TGVTexture.Lock(aRegion: PGVRectangle; aData: PGVTextureData): Boolean;
var
  LLock: PALLEGRO_LOCKED_REGION;
begin
  Result := False;

  if FLocked then Exit;
  if FHandle = nil then Exit;

  LLock := nil;
  if not FLocked then
  begin
    if aRegion <> nil then
      begin
        LLock := al_lock_bitmap_region(FHandle, Round(aRegion.X), Round(aRegion.Y), Round(aRegion.Width), Round(aRegion.Height), ALLEGRO_PIXEL_FORMAT_ANY, ALLEGRO_LOCK_READWRITE);
        if LLock = nil then Exit;
        FLockedRegion.X := aRegion.X;
        FLockedRegion.Y := aRegion.Y;
        FLockedRegion.Width := aRegion.Width;
        FLockedRegion.Height := aRegion.Height;
      end
    else
      begin
        LLock := al_lock_bitmap(FHandle, ALLEGRO_PIXEL_FORMAT_ANY, ALLEGRO_LOCK_READWRITE);
        if LLock = nil then Exit;
        FLockedRegion.X := 0;
        FLockedRegion.Y := 0;
        FLockedRegion.Width := FWidth;
        FLockedRegion.Height := FHeight;
      end;
    FLocked := True;
  end;

  if LLock <> nil then
  begin
    if aData <> nil then
    begin
      aData.Memory := LLock.data;
      aData.Format := LLock.format;
      aData.Pitch := LLock.pitch;
      aData.PixelSize := LLock.pixel_size;
    end;
  end;

  Result := True;
end;

function TGVTexture.Unlock: Boolean;
begin
  Result := False;
  if not FLocked then Exit;
  if FHandle = nil then Exit;

  al_unlock_bitmap(FHandle);
  FLocked := False;
  FLockedRegion.X := 0;
  FLockedRegion.Y := 0;
  FLockedRegion.Width := 0;
  FLockedRegion.Height := 0;

  Result := True;
end;

function  TGVTexture.GetPixel(aX: Integer; aY: Integer): TGVColor;
var
  LX,LY: Integer;
  LResult: ALLEGRO_COLOR absolute Result;
begin
  Result := BLANK;
  if FHandle = nil then Exit;
  LX := Round(aX + FLockedRegion.X);
  LY := Round(aY + FlockedRegion.Y);
  LResult := al_get_pixel(FHandle, LX, LY);
end;

procedure TGVTexture.SetPixel(aX: Integer; aY: Integer; aColor: TGVColor);
var
  LX,LY: Integer;
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FHandle = nil then Exit;
  LX := Round(aX + FLockedRegion.X);
  LY := Round(aY + FlockedRegion.Y);
  al_put_pixel(LX, LY, LColor);
end;

procedure TGVTexture.Draw(aX, aY: Single; aRegion: PGVRectangle; aCenter: PGVVector;  aScale: PGVVector; aAngle: Single; aColor: TGVColor; aHFlip: Boolean; aVFlip: Boolean);
var
  LA: Single;
  LRG: TGVRectangle;
  LCP: TGVVector;
  LSC: TGVVector;
  LC: ALLEGRO_COLOR absolute aColor;
  LFlags: Integer;
begin
  if FHandle = nil then Exit;

  // angle
  LA := aAngle * GV_DEG2RAD;
  LA := EnsureRange(LA, 0, 359);

  // region
  if Assigned(aRegion) then
    begin
      LRG.X := aRegion.X;
      LRG.Y := aRegion.Y;
      LRG.Width := aRegion.Width;
      LRG.Height := aRegion.Height;
    end
  else
    begin
      LRG.X := 0;
      LRG.Y := 0;
      LRG.Width := FWidth;
      LRG.Height := FHeight;
    end;

  if LRG.X < 0 then
    LRG.X := 0;
  if LRG.X > FWidth - 1 then
    LRG.X := FWidth - 1;

  if LRG.Y < 0 then
    LRG.Y := 0;
  if LRG.Y > FHeight - 1 then
    LRG.Y := FHeight - 1;

  if LRG.Width < 0 then
    LRG.Width := 0;
  if LRG.Width > FWidth then
    LRG.Width := LRG.Width;

  if LRG.Height < 0 then
    LRG.Height := 0;
  if LRG.Height > FHeight then
    LRG.Height := LRG.Height;

  // center
  if Assigned(aCenter) then
    begin
      LCP.X := (LRG.Width * aCenter.X);
      LCP.Y := (LRG.Height * aCenter.Y);
    end
  else
    begin
      LCP.X := 0;
      LCP.Y := 0;
    end;

  // scale
  if Assigned(aScale) then
    begin
      LSC.X := aScale.X;
      LSC.Y := aScale.Y;
    end
  else
    begin
      LSC.X := 1;
      LSC.Y := 1;
    end;

  // flags
  LFlags := 0;
  if aHFlip then LFlags := LFlags or ALLEGRO_FLIP_HORIZONTAL;
  if aVFlip then LFlags := LFlags or ALLEGRO_FLIP_VERTICAL;

  // render
  al_draw_tinted_scaled_rotated_bitmap_region(FHandle, LRG.X, LRG.Y, LRG.Width, LRG.Height, LC, LCP.X, LCP.Y, aX, aY, LSC.X, LSC.Y, LA, LFlags);
end;

procedure TGVTexture.Draw(aX, aY, aScale, aAngle: Single; aColor: TGVColor; aHAlign: TGVHAlign; aVAlign: TGVVAlign; aHFlip: Boolean; aVFlip: Boolean);
var
  LCenter: TGVVector;
  LScale: TGVVector;
begin
  if FHandle = nil then Exit;

  LCenter.X := 0;
  LCenter.Y := 0;

  LScale.X := aScale;
  LScale.Y := aScale;

  case aHAlign of
    TGVHAlign.Left  : LCenter.X := 0;
    TGVHAlign.Center: LCenter.X := 0.5;
    TGVHAlign.Right : LCenter.X := 1;
  end;

  case aVAlign of
    TGVValign.Top   : LCenter.Y := 0;
    TGVValign.Center: LCenter.Y := 0.5;
    TGVValign.Bottom: LCenter.Y := 1;
  end;

  Draw(aX, aY, nil, @LCenter, @LScale, aAngle, aColor, aHFlip, aVFlip);
end;

procedure TGVTexture.DrawTiled(aDeltaX: Single; aDeltaY: Single);
var
  LW,LH    : Integer;
  LOX,LOY  : Integer;
  LPX,LPY  : Single;
  LFX,LFY  : Single;
  LTX,LTY  : Integer;
  //LVPW,LVPH: Single;
  LVP      : TGVRectangle;
  LVR,LVB  : Integer;
  LIX,LIY  : Integer;
begin
  if FHandle = nil then Exit;

  GV.Window.GetViewportSize(LVP);

  LW := Round(FWidth);
  LH := Round(FHeight);

  LOX := -LW+1;
  LOY := -LH+1;

  LPX := aDeltaX;
  LPY := aDeltaY;

  LFX := LPX-floor(LPX);
  LFY := LPY-floor(LPY);

  LTX := floor(LPX)-LOX;
  LTY := floor(LPY)-LOY;

  if (LTX>=0) then LTX := LTX mod LW + LOX else LTX := LW - -LTX mod LW + LOX;
  if (LTY>=0) then LTY := LTY mod LH + LOY else LTY := LH - -LTY mod LH + LOY;

  LVR := Round(LVP.Width);
  LVB := Round(LVP.Height);
  LIY := LTY;

  while LIY<LVB do
  begin
    LIX := LTX;
    while LIX<LVR do
    begin
      al_draw_bitmap(FHandle, LIX+LFX, LIY+LFY, 0);
      LIX := LIX+LW;
    end;
   LIY := LIY+LH;
  end;
end;

{ --- RENDERTARGET ---------------------------------------------------------- }
{ TGVRenderTarget }
constructor TGVRenderTarget.Create;
begin
  inherited;
  FTexture := TGVTexture.Create;
end;

destructor TGVRenderTarget.Destroy;
begin
  FreeAndNil(FTexture);
  inherited;
end;

procedure TGVRenderTarget.Init(aWidth: Integer; aHeight: Integer);
begin
  FTexture.Allocate(aWidth, aHeight);
  FPosition.Assign(0, 0);
  FRegion.Assign(0, 0, FTexture.Width, FTexture.Height);
end;

function  TGVRenderTarget.GetActive: Boolean;
begin
  Result := FActive;
end;

procedure TGVRenderTarget.SetActive(aActive: Boolean);
begin
  if FTexture.Handle = nil then Exit;
  if aActive then
    begin
      al_set_target_bitmap(FTexture.Handle);
      GV.Window.SetRenderTarget(Self);
      FActive := True;
    end
  else
    begin
      al_set_target_backbuffer(GV.Window.Handle);
      GV.Window.SetRenderTarget(nil);
      FActive := False;
    end;
end;

procedure TGVRenderTarget.SetPosition(aX: Single; aY: Single);
begin
  FPosition.Assign(aX, aY);
end;

procedure TGVRenderTarget.GetPosition(var aPosition: TGVVector);
begin
  FPosition.Assign(0, 0);
  if FTexture.Handle = nil then Exit;
  aPosition := FPosition;
end;

procedure TGVRenderTarget.GetSize(var aSize: TGVRectangle);
begin
  aSize.Assign(0, 0, 0, 0);
  if FTexture.Handle = nil then Exit;
  aSize.Assign(FPosition.X, FPosition.Y, FTexture.Width, FTexture.Height);
end;

procedure TGVRenderTarget.SetRegion(aX: Single; aY: Single; aWidth: Single; aHeight: Single);
begin
  if FTexture.Handle = nil then Exit;
  FRegion.Assign(aX, aY, aWidth, aHeight);
end;

procedure TGVRenderTarget.GetRegion(var aRegion: TGVRectangle);
begin
  aRegion.Assign(0, 0, 0, 0);
  if FTexture.Handle = nil then Exit;
  aRegion := FRegion;
end;

procedure TGVRenderTarget.Show;
begin
  if FActive then
    al_set_target_backbuffer(GV.Window.Handle);
  FTexture.Draw(FPosition.X, FPosition.Y, @FRegion, nil, nil, 0, WHITE);
  if FActive then
    al_set_target_bitmap(FTexture.Handle);
end;

{ --- WINDOW ---------------------------------------------------------------- }

(*
SetProcessDPIAware(); //true
HDC screen = GetDC(NULL);
double hPixelsPerInch = GetDeviceCaps(screen,LOGPIXELSX);
double vPixelsPerInch = GetDeviceCaps(screen,LOGPIXELSY);
ReleaseDC(NULL, screen);
return (hPixelsPerInch + vPixelsPerInch) * 0.5;
*)

procedure TGVWindow.GetWindowCenterScaledToDPI(aWidth: Integer; aHeight: Integer; var aX: Integer; var aY: Integer);
var
  LDpi: Integer;
  LSX,LSY: Integer;
begin
  LDpi := al_get_monitor_dpi(0);

  LSX := MulDiv(aWidth, LDPI, GV_DISPLAY_DEFAULT_DPI);
  LSY := MulDiv(aHeight, LDpi, GV_DISPLAY_DEFAULT_DPI);

  aX := (GetSystemMetrics(SM_CXFULLSCREEN) - LSX) div 2;
  aY := (GetSystemMetrics(SM_CYFULLSCREEN) - LSY) div 2;
end;

procedure TGVWindow.ScaleToDPI;
var
  LDpi: Integer;
  LSX,LSY: Integer;
  LWX,LWY: Integer;
  LDW,LDH: Integer;
begin
  if FHandle = nil then Exit;

  LDW := al_get_display_width(FHandle);
  LDH := al_get_display_height(FHandle);

  al_identity_transform(@FTransform);
  al_use_transform(@FTransform);
  al_set_clipping_rectangle(0, 0, LDW, LDH);

  LDpi:= GetDpiForWindow(al_get_win_window_handle(FHandle));
  LSX := MulDiv(Round(Self.Width), LDPI, GV_DISPLAY_DEFAULT_DPI);
  LSY := MulDiv(Round(Self.Height), LDpi, GV_DISPLAY_DEFAULT_DPI);

  LWX := (GetSystemMetrics(SM_CXFULLSCREEN) - LSX) div 2;
  LWY := (GetSystemMetrics(SM_CYFULLSCREEN) - LSY) div 2;
  al_set_window_position(FHandle, LWX, LWY);
  al_resize_display(FHandle, LSX, LSY);

  FScale := min(LSX / Self.Width, LSY / Self.Height);
  al_set_clipping_rectangle(0, 0, LSX, LSY);
  al_build_transform(@FTransform, 0, 0, FScale, FScale, 0);
  al_use_transform(@FTransform);

  al_set_window_constraints(FHandle, LSX, LSY, LSX, LSY);
  al_apply_window_constraints(FHandle, True);
end;

procedure TGVWindow.SetRenderTarget(aRenderTarget: TGVRenderTarget);
begin
  FRenderTarget := aRenderTarget;
end;

constructor TGVWindow.Create;
begin
  inherited;
  FHandle := nil;
  al_identity_transform(@FTransform);
end;

destructor TGVWindow.Destroy;
begin
  Close;
  inherited;
end;

function TGVWindow.Open(aWidth: Integer; aHeight: Integer; aTitle: string): Boolean;
var
  LMarshaller: TMarshaller;
begin
  Result := False;
  if FHandle <> nil then Exit;
  al_set_new_display_flags(ALLEGRO_OPENGL_3_0 or ALLEGRO_RESIZABLE or ALLEGRO_PROGRAMMABLE_PIPELINE);
  al_set_new_display_option(ALLEGRO_COMPATIBLE_DISPLAY, 1, ALLEGRO_REQUIRE);
  al_set_new_display_option(ALLEGRO_VSYNC, 2, ALLEGRO_SUGGEST);
  al_set_new_display_option(ALLEGRO_CAN_DRAW_INTO_BITMAP, 1, ALLEGRO_REQUIRE);
  al_set_new_display_option(ALLEGRO_SAMPLE_BUFFERS, 1, ALLEGRO_SUGGEST);
  al_set_new_display_option(ALLEGRO_SAMPLES, 8, ALLEGRO_SUGGEST);
  al_set_new_window_title(LMarshaller.AsUtf8(aTitle).ToPointer);
  //GetWindowCenterScaledToDPI(aWidth, aHeight, LX, LY);
  //al_set_new_window_position(LX, LY);
  FHandle := al_create_display(aWidth, aHeight);
  if FHandle = nil then Exit;
  FHWnd := al_get_win_window_handle(FHandle);
  SetWindowLong(FHwnd, GWL_STYLE, GetWindowLong(FHWnd, GWL_STYLE) and (not WS_MAXIMIZEBOX));
  GV.Util.LoadDefaultIcon(al_get_win_window_handle(FHandle));
  FWidth := aWidth;
  FHeight := aHeight;
  FScale := 1;
  FRenderTarget := nil;
  al_register_event_source(GV.Queue, al_get_display_event_source(FHandle));
  ScaleToDPI;
end;

function TGVWindow.Close: Boolean;
begin
  Result := False;
  if FHandle = nil then Exit;
  if al_is_event_source_registered(GV.Queue, al_get_display_event_source(FHandle)) then
    al_unregister_event_source(GV.Queue, al_get_display_event_source(FHandle));
  al_destroy_display(FHandle);
  FHandle := nil;
end;

procedure TGVWindow.Clear(aColor: TGVColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FHandle = nil then Exit;
  al_clear_to_color(LColor);
end;

procedure TGVWindow.Show;
begin
  if FHandle = nil then Exit;
  al_flip_display;
end;

procedure TGVWindow.SetTitle(aTitle: string);
var
  LMarshaller: TMarshaller;
begin
  if FHandle = nil then Exit;
  al_set_window_title(FHandle, LMarshaller.AsUtf8(aTitle).ToPointer);
end;

function TGVWindow.IsOpen: Boolean;
begin
  Result := Boolean(FHandle <> nil);
end;

procedure TGVWindow.ResetTransform;
begin
  if FHandle = nil then Exit;
  al_use_transform(@FTransform);
end;

procedure TGVWindow.SetTransformPosition(aX: Single; aY: Single);
var
  LTransform: ALLEGRO_TRANSFORM;
begin
  if FHandle = nil then Exit;
  al_copy_transform(@LTransform, al_get_current_transform);
  al_translate_transform(@LTransform, aX, aY);
  al_use_transform(@LTransform);
end;

procedure TGVWindow.SetTransformAngle(aAngle: Single);
var
  LTransform: ALLEGRO_TRANSFORM;
  LX, LY: Integer;
begin
  if FHandle = nil then Exit;
  LX := al_get_display_width(FHandle);
  LY := al_get_display_height(FHandle);
  al_copy_transform(@FTransform, al_get_current_transform);
  al_translate_transform(@FTransform, -(LX div 2), -(LY div 2));
  al_rotate_transform(@LTransform, aAngle * GV_DEG2RAD);
  al_translate_transform(@LTransform, 0, 0);
  al_translate_transform(@LTransform, LX div 2, LY div 2);
  al_use_transform(@LTransform);
end;

procedure TGVWindow.GetViewportSize(var aSize: TGVRectangle);
begin
  //aSize := FRenderTarget.Size;
  if FRenderTarget = nil then
    aSize.Assign(0, 0, FWidth, FHeight)
  else
    FRenderTarget.GetSize(aSize);
end;

procedure TGVWindow.SetBlender(aOperation: Integer; aSource: Integer; aDestination: Integer);
begin
  if FHandle = nil then Exit;
  al_set_blender(aOperation, aSource, aDestination);
end;

procedure TGVWindow.GetBlender(aOperation: PInteger; aSource: PInteger; aDestination: PInteger);
begin
  if FHandle = nil then Exit;
  al_get_blender(aOperation, aSource, aDestination);
end;

procedure TGVWindow.SetBlendColor(aColor: TGVColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FHandle = nil then Exit;
  al_set_blend_color(LColor);
end;

function  TGVWindow.GetBlendColor: TGVColor;
var
  LResult: ALLEGRO_COLOR absolute Result;
begin
  Result := BLANK;
  if FHandle = nil then Exit;
  LResult := al_get_blend_color;
end;

procedure TGVWindow.SetBlendMode(aMode: TGVBlendMode);
begin
  if FHandle = nil then Exit;
  case aMode of
    TGVBlendMode.PreMultipliedAlpha:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_INVERSE_ALPHA);
      end;
    TGVBlendMode.NonPreMultipliedAlpha:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ALPHA, ALLEGRO_INVERSE_ALPHA);
      end;
    TGVBlendMode.AdditiveAlpha:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ONE);
      end;
    TGVBlendMode.CopySrcToDest:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ZERO);
      end;
    TGVBlendMode.MultiplySrcAndDest:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_DEST_COLOR, ALLEGRO_ZERO);
      end;
  end;
end;

procedure TGVWindow.SetBlendModeColor(aMode: TGVBlendModeColor; aColor: TGVColor);
begin
  if FHandle = nil then Exit;
  case aMode of
    TGVBlendModeColor.Normal:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_ONE);
        al_set_blend_color(al_map_rgba_f(aColor.red, aColor.green, aColor.blue, aColor.alpha));
      end;
    TGVBlendModeColor.AvgSrcDest:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);
        al_set_blend_color(al_map_rgba_f(aColor.red, aColor.green, aColor.blue, aColor.alpha));
      end;
  end;
end;

procedure TGVWindow.RestoreDefaultBlendMode;
begin
  if FHandle = nil then Exit;
  al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_INVERSE_ALPHA);
  al_set_blend_color(al_map_rgba(255, 255, 255, 255));
end;

procedure TGVWindow.Save(const aFilename: string);
var
  LBackbuffer: PALLEGRO_BITMAP;
  LScreenshot: PALLEGRO_BITMAP;
  LVX, LVY, LVW, LVH: Integer;
  LFilename: string;
  LMarshallar: TMarshaller;
  LSize: TGVRectangle;
begin
  if FHandle = nil then Exit;

  // get viewport size
  GetViewportSize(LSize);
  LVX := Round(LSize.X);
  LVY := Round(LSize.Y);
  LVW := Round(LSize.Width);
  LVH := Round(LSize.Height);

  // create LScreenshot bitmpat
  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR);
  LScreenshot := al_create_bitmap(LVW, LVH);

  // exit if failed to create LScreenshot bitmap
  if LScreenshot = nil then Exit;

  // get LBackbuffer
  LBackbuffer := al_get_backbuffer(FHandle);

  // set target to LScreenshot bitmap
  al_set_target_bitmap(LScreenshot);

  // draw viewport area of LBackbuffer to LScreenshot bitmap
  al_draw_bitmap_region(LBackbuffer, LVX, LVY, LVW, LVH, 0, 0, 0);

  // restore LBackbuffer target
  al_set_target_bitmap(LBackbuffer);

  // make sure filename is a PNG file
  LFilename := aFilename;
  LFilename := TPath.ChangeExtension(LFilename, GV_FILEEXT_PNG);

  // save screen bitmap to PNG filename
  GV.SetFileSandBoxed(False);
  if not al_save_bitmap(LMarshallar.AsUtf8(LFilename).ToPointer, LScreenshot) then
  GV.SetFileSandBoxed(True);

  // destroy LScreenshot bitmap
  al_destroy_bitmap(LScreenshot);
end;

{ --- PRIMITIVES ------------------------------------------------------------ }
{ TPrimitive }
constructor TGVPrimitive.Create;
begin
  inherited;
end;

destructor TGVPrimitive.Destroy;
begin
  inherited;
end;

procedure TGVPrimitive.Line(aX1, aY1, aX2, aY2: Single; aColor: TGVColor; aThickness: Single);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not GV.Window.IsOpen then Exit;
  al_draw_line(aX1, aY1, aX2, aY2, LColor, aThickness);
end;

procedure TGVPrimitive.Rectangle(aX, aY, aWidth, aHeight, aThickness: Single; aColor: TGVColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not GV.Window.IsOpen then Exit;
  al_draw_rectangle(aX, aY, aX + (aWidth-1), aY + (aHeight-1), LColor, aThickness);
end;

procedure TGVPrimitive.FilledRectangle(aX, aY, aWidth, aHeight: Single; aColor: TGVColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not GV.Window.IsOpen then Exit;
  al_draw_filled_rectangle(aX, aY, aX + (aWidth-1), aY + (aHeight-1), LColor);
end;

procedure TGVPrimitive.Circle(aX, aY, aRadius, aThickness: Single; aColor: TGVColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not GV.Window.IsOpen then Exit;
  al_draw_circle(aX, aY, aRadius, LColor, aThickness);
end;

procedure TGVPrimitive.FilledCircle(aX, aY, aRadius: Single; aColor: TGVColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not GV.Window.IsOpen then Exit;
  al_draw_filled_circle(aX, aY, aRadius, LColor);
end;

procedure TGVPrimitive.DrawPolygon(aVertices: System.PSingle; aVertexCount: Integer; aThickness: Single; aColor: TGVColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not GV.Window.IsOpen then Exit;
  al_draw_polygon(WinApi.Windows.PSingle(aVertices), aVertexCount, ALLEGRO_LINE_JOIN_ROUND, LColor, aThickness, 1.0);
end;

procedure TGVPrimitive.DrawFilledPolygon(aVertices: System.PSingle; aVertexCount: Integer; aColor: TGVColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not GV.Window.IsOpen then Exit;
  al_draw_filled_polygon(WinApi.Windows.PSingle(aVertices), aVertexCount, LColor);
end;

{ --- INPUT ----------------------------------------------------------------- }
{ TGVJoystick }
procedure TGVJoystick.Setup(aNum: Integer);
var
  LJoyCount: Integer;
  LJoy: PALLEGRO_JOYSTICK;
  LJoyState: ALLEGRO_JOYSTICK_STATE;
  LI, LJ: Integer;
begin
  LJoyCount := al_get_num_joysticks;
  if (aNum < 0) or (aNum > LJoyCount - 1) then
    Exit;

  LJoy := al_get_joystick(aNum);
  if LJoy = nil then
  begin
    Sticks := 0;
    Buttons := 0;
    Exit;
  end;

  Name := string(al_get_joystick_name(LJoy));

  al_get_joystick_state(LJoy, @LJoyState);

  Sticks := al_get_joystick_num_sticks(LJoy);
  if (Sticks > MAX_STICKS) then
    Sticks := MAX_STICKS;

  for LI := 0 to Sticks - 1 do
  begin
    StickName[LI] := string(al_get_joystick_stick_name(LJoy, LI));
    Axes[LI] := al_get_joystick_num_axes(LJoy, LI);
    for LJ := 0 to Axes[LI] - 1 do
    begin
      Pos[LI, LJ] := LJoyState.stick[LI].axis[LJ];
      AxesName[LI, LJ] := string(al_get_joystick_axis_name(LJoy, LI, LJ));
    end;
  end;

  Buttons := al_get_joystick_num_buttons(LJoy);
  if (Buttons > MAX_BUTTONS) then
    Buttons := MAX_BUTTONS;

  for LI := 0 to Buttons - 1 do
  begin
    ButtonName[LI] := string(al_get_joystick_button_name(LJoy, LI));
    Button[0, LI] := Boolean(LJoyState.Button[LI] >= 16384);
  end
end;

function TGVJoystick.GetPos(aStick: Integer; aAxes: Integer): Single;
begin
  Result := Pos[aStick, aAxes];
end;

function TGVJoystick.GetButton(aButton: Integer): Boolean;
begin
  Result := Button[0, aButton];
end;

procedure TGVJoystick.Clear;
begin
  FillChar(Button, SizeOf(Button), False);
  FillChar(Pos, SizeOf(Pos), 0);
end;

{ TGVInput }
constructor TGVInput.Create;
begin
  inherited;
  Clear;
  FJoystick.Setup(0);
end;

destructor TGVInput.Destroy;
begin
  inherited;
end;

procedure TGVInput.Clear;
begin
  FillChar(FMouseButtons, SizeOf(FMouseButtons), False);
  FillChar(FKeyButtons, SizeOf(FKeyButtons), False);
  //FillChar(FJoyButtons, SizeOf(FJoyButtons), False);
  FJoystick.Clear;

  if GV.Window.FHandle <> nil then
  begin
    al_clear_keyboard_state(GV.Window.FHandle);
  end;
end;

procedure TGVInput.Update;
begin
  //FMouse.Postion.Clear;
  //FMouse.Delta.Clear;
  //FMouse.Pressure := 0;

  case GV.Event.type_ of
    ALLEGRO_EVENT_KEY_CHAR:
    begin
      FKeyCode := GV.Event.keyboard.unichar;
    end;

    ALLEGRO_EVENT_JOYSTICK_AXIS:
    begin
      if (GV.Event.Joystick.stick < MAX_STICKS) and
        (GV.Event.Joystick.axis < MAX_AXES) then
      begin
        FJoystick.Pos[GV.Event.Joystick.stick][GV.Event.Joystick.axis] :=
          GV.Event.Joystick.Pos;
      end;
    end;

    ALLEGRO_EVENT_KEY_DOWN:
    begin
      FKeyButtons[0, GV.Event.keyboard.keycode] := True;
    end;

    ALLEGRO_EVENT_KEY_UP:
    begin
      FKeyButtons[0, GV.Event.keyboard.keycode] := False;
    end;

    ALLEGRO_EVENT_MOUSE_BUTTON_DOWN:
    begin
      FMouseButtons[0, GV.Event.mouse.button] := True;
    end;

    ALLEGRO_EVENT_MOUSE_BUTTON_UP:
    begin
      FMouseButtons[0, GV.Event.mouse.button] := False;
    end;

    ALLEGRO_EVENT_MOUSE_AXES:
    begin
      FMouse.Postion.X := Round(GV.Event.mouse.x / GV.Window.Scale);
      FMouse.Postion.Y := Round(GV.Event.mouse.y / GV.Window.Scale);
      FMouse.Postion.Z := GV.Event.mouse.z;
      FMouse.Postion.W := GV.Event.mouse.w;

      FMouse.Delta.X := GV.Event.mouse.dx;
      FMouse.Delta.Y := GV.Event.mouse.dy;
      FMouse.Delta.Z := GV.Event.mouse.dz;
      FMouse.Delta.W := GV.Event.mouse.dw;

      FMouse.Pressure := GV.Event.mouse.pressure;
    end;

    ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN:
    begin
      FJoystick.Button[0, GV.Event.Joystick.Button] := True;
    end;

    ALLEGRO_EVENT_JOYSTICK_BUTTON_UP:
    begin
      FJoystick.Button[0, GV.Event.Joystick.Button] := False;
    end;

    ALLEGRO_EVENT_JOYSTICK_CONFIGURATION:
    begin
      al_reconfigure_joysticks;
      FJoystick.Setup(0);
    end;
  end;
end;

function TGVInput.KeyDown(aKey: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aKey, 0, 255) then  Exit;
  Result := FKeyButtons[0, aKey];
end;

function TGVInput.KeyPressed(aKey: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aKey, 0, 255) then  Exit;
  if KeyDown(aKey) and (not FKeyButtons[1, aKey]) then
  begin
    FKeyButtons[1, aKey] := True;
    Result := True;
  end
  else if (not KeyDown(aKey)) and (FKeyButtons[1, aKey]) then
  begin
    FKeyButtons[1, aKey] := False;
    Result := False;
  end;
end;

function TGVInput.KeyReleased(aKey: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aKey, 0, 255) then Exit;
  if KeyDown(aKey) and (not FKeyButtons[1, aKey]) then
  begin
    FKeyButtons[1, aKey] := True;
    Result := False;
  end
  else if (not KeyDown(aKey)) and (FKeyButtons[1, aKey]) then
  begin
    FKeyButtons[1, aKey] := False;
    Result := True;
  end;
end;

function TGVInput.MouseDown(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE) then Exit;
  Result := FMouseButtons[0, aButton];
end;

function TGVInput.MousePressed(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE) then Exit;

  if MouseDown(aButton) and (not FMouseButtons[1, aButton]) then
  begin
    FMouseButtons[1, aButton] := True;
    Result := True;
  end
  else if (not MouseDown(aButton)) and (FMouseButtons[1, aButton]) then
  begin
    FMouseButtons[1, aButton] := False;
    Result := False;
  end;
end;

function TGVInput.MouseReleased(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE) then Exit;

  if MouseDown(aButton) and (not FMouseButtons[1, aButton]) then
  begin
    FMouseButtons[1, aButton] := True;
    Result := False;
  end
  else if (not MouseDown(aButton)) and (FMouseButtons[1, aButton]) then
  begin
    FMouseButtons[1, aButton] := False;
    Result := True;
  end;
end;

procedure TGVInput.MouseSetPos(aX: Integer; aY: Integer);
var
  LX, LY: Integer;
begin
  LX := Round(aX * GV.Window.Scale);
  LY := Round(aY * GV.Window.Scale);
  al_set_mouse_xy(GV.Window.Handle, LX, LY);
end;

procedure TGVInput.GetMouseInfo(aPosition: PGVVector; aDelta: PGVVector; aPressure: System.PSingle);
begin
  if aPosition <> nil then
    aPosition^ := FMouse.Postion;
  if aDelta <> nil then
    aDelta^ := FMouse.Delta;
  if aPressure <> nil then
    aPressure^ := FMouse.Pressure;
end;

function TGVInput.JoystickDown(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, 0, MAX_BUTTONS-1) then Exit;
  Result := FJoystick.Button[0, aButton];
end;

function TGVInput.JoystickPressed(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, 0, MAX_BUTTONS-1) then Exit;

  if JoystickDown(aButton) and (not FJoystick.Button[1, aButton]) then
  begin
    FJoystick.Button[1, aButton] := True;
    Result := True;
  end
  else if (not JoystickDown(aButton)) and (FJoystick.Button[1, aButton]) then
  begin
    FJoystick.Button[1, aButton] := False;
    Result := False;
  end;
end;

function TGVInput.JoystickReleased(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, 0, MAX_BUTTONS-1) then Exit;

  if JoystickDown(aButton) and (not FJoystick.Button[1, aButton]) then
  begin
    FJoystick.Button[1, aButton] := True;
    Result := False;
  end
  else if (not JoystickDown(aButton)) and (FJoystick.Button[1, aButton]) then
  begin
    FJoystick.Button[1, aButton] := False;
    Result := True;
  end;
end;

function  TGVInput.JoystickPosition(aStick: Integer; aAxes: Integer): Single;
begin
  Result := 0;
  if not InRange(aStick, 0, MAX_STICKS-1) then Exit;
  if not InRange(aAxes, 0, MAX_AXES-1) then Exit;
  Result := FJoystick.Pos[aStick, aAxes];
end;

{ --- INPUTMAP -------------------------------------------------------------- }
{ TInputMap }
function TGVInputMap.NewAction(const aAction: string; aDevice: TGVInputMapDevice; aData: Integer): TInputMapAction;
var
  LInput: TInputMapDeviceInput;
begin
  Result.Action := aAction;
  Result.List := TList<TInputMapDeviceInput>.Create;
  LInput.Device := aDevice;
  LInput.Data := aData;
  Result.List.Add(LInput);
end;

constructor TGVInputMap.Create;
begin
  inherited;
  FList := TDictionary<string, TInputMapAction>.Create;
end;

destructor TGVInputMap.Destroy;
begin
  Clear;
  FreeAndNil(FList);
  inherited;
end;

procedure TGVInputMap.Clear;
var
  LItem: TPair<string, TInputMapAction>;
begin
  for LItem in FList do
  begin
    FreeAndNil(LItem.Value.List);
  end;
  FList.Clear;
end;

function TGVInputMap.Add(const aAction: string; aDevice: TGVInputMapDevice; aData: Integer): Boolean;
var
  LAction: TInputMapAction;
  LInput: TInputMapDeviceInput;
begin
  Result := False;
  if FList.TryGetValue(aAction, LAction) then
    begin
      LInput.Device := aDevice;
      LInput.Data := aData;
      if LAction.List.Contains(LInput) then
        begin
          Exit;
        end
      else
        begin
          LAction.List.Add(LInput);
          Result := False;
        end;
    end
  else
    begin
      LAction := NewAction(aAction, aDevice, aData);
      FList.Add(aAction, LAction);
    end;
end;

function TGVInputMap.Remove(const aAction: string): Boolean;
var
  LAction: TInputMapAction;
begin
  Result := False;
  if FList.TryGetValue(aAction, LAction) then
  begin
    FList.Remove(aAction);
    FreeAndNil(LAction.List);
    FList.TrimExcess;
    Result := True;
  end;
end;

function TGVInputMap.Remove(const aAction: string; aDevice: TGVInputMapDevice; aData: Integer): Boolean;
var
  LAction: TInputMapAction;
  LInput: TInputMapDeviceInput;
begin
  Result := False;

  if not FList.TryGetValue(aAction, LAction) then Exit;
  LInput.Device := aDevice;
  LInput.Data := aData;
  if LAction.List.Contains(LInput) then
  begin
    LAction.List.Remove(LInput);
    LAction.List.Pack;
    Result := True;
  end;
end;

function TGVInputMap.Pressed(const aAction: string): Boolean;
var
  LAction: TInputMapAction;
begin
  Result := False;
  if FList.TryGetValue(aAction, LAction) then
  begin
    for var I := 0 to LAction.List.Count-1 do
    begin
      case LAction.List.Items[I].Device of
        TGVInputMapDevice.Keyboard:
          begin
            Result := GV.Input.KeyPressed(LAction.List.Items[I].Data);
            if Result then Break;
          end;
        TGVInputMapDevice.Mouse:
          begin
            Result := GV.Input.MousePressed(LAction.List.Items[I].Data);
            if Result then Break;
          end;
        TGVInputMapDevice.Joystick:
          begin
            Result := GV.Input.JoystickPressed(LAction.List.Items[I].Data);
            if Result then Break;
          end;
      end;
    end;
  end;
end;

function TGVInputMap.Released(const aAction: string): Boolean;
var
  LAction: TInputMapAction;
  LI: Integer;
begin
  Result := False;
  if FList.TryGetValue(aAction, LAction) then
  begin
    for LI := 0 to LAction.List.Count-1 do
    begin
      case LAction.List.Items[LI].Device of
        TGVInputMapDevice.Keyboard:
          begin
            Result := GV.Input.KeyReleased(LAction.List.Items[LI].Data);
            if Result then Break;
          end;
        TGVInputMapDevice.Mouse:
          begin
            Result := GV.Input.MouseReleased(LAction.List.Items[LI].Data);
            if Result then Break;
          end;
        TGVInputMapDevice.Joystick:
          begin
            Result := GV.Input.JoystickReleased(LAction.List.Items[LI].Data);
            if Result then Break;
          end;
      end;
    end;
  end;
end;

function TGVInputMap.Down(const aAction: string): Boolean;
var
  LAction: TInputMapAction;
  LI: Integer;
begin
  Result := False;
  if FList.TryGetValue(aAction, LAction) then
  begin
    for LI := 0 to LAction.List.Count-1 do
    begin
      case LAction.List.Items[LI].Device of
       TGVInputMapDevice.Keyboard:
          begin
            Result := GV.Input.KeyDown(LAction.List.Items[LI].Data);
            if Result then Break;
          end;
        TGVInputMapDevice.Mouse:
          begin
            Result := GV.Input.MouseDown(LAction.List.Items[LI].Data);
            if Result then Break;
          end;
        TGVInputMapDevice.Joystick:
          begin
            Result := GV.Input.JoystickDown(LAction.List.Items[LI].Data);
            if Result then Break;
          end;
      end;
    end;
  end;
end;

function TGVInputMap.Save(const aFilename: string): Boolean;
var
  LStream: TFileStream;
  LAction: TInputMapAction;
  LIndex: Integer;
begin
  Result := False;
  if aFilename.IsEmpty then Exit;

  LStream := TFile.Create(aFilename);
  try
    // save FList count
    LStream.WriteData(FList.Count);

    // loop thru each action
    for LAction in FList.Values do
    begin
      // save LAction count
      LStream.WriteData(LAction.List.Count);

      // save Action name
      GV.Util.WriteStringToStream(LStream, LAction.Action);

      // save action list data
      for LIndex := 0 to LAction.List.Count-1 do
      begin
        LStream.WriteData(LAction.List.Items[LIndex].Device);
        LStream.WriteData(LAction.List.Items[LIndex].Data);
      end;
    end;

    Result := TFile.Exists(aFilename);
  finally
    FreeAndNil(LStream);
  end;
end;

function TGVInputMap.Load(aArchive: TGVArchive; const aFilename: string): Boolean;
var
  LBuffer: TGVBuffer;
  LCount: Integer;
  LIndex: Integer;
  LAction: string;
  LDevice: TGVInputMapDevice;
  LData: Integer;
begin
  Result := False;
  if aFilename.IsEmpty then Exit;

  if aArchive <> nil then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileExist(aFilename) then Exit;
      LBuffer := aArchive.ExtractToBuffer(aFilename);
      // TODO: check for errors
    end
  else
    begin
      if not TFile.Exists(aFilename) then Exit;
      LBuffer := TGVBuffer.Create;
      // TODO: check for errors
      LBuffer.LoadFromFile(aFilename);
    end;

  Self.Clear;

  LBuffer.Position := 0;

  // read FList Count
  LBuffer.Read(@LCount, SizeOf(LCount));

  // loop thru each action
  while not LBuffer.Eof do
  begin
    // load LAction count
    LBuffer.Read(@LCount, SizeOf(LCount));

    // load action name
    LAction := GV.Util.ReadStringFromBuffer(LBuffer);

    for LIndex := 0 to LCount-1 do
    begin
      // load action data
      LBuffer.Read(@LDevice, SizeOf(LDevice));
      LBuffer.Read(@LData, SizeOf(LData));

      // add action map
      self.Add(LAction, LDevice, LData);
    end;
  end;

  FreeAndNil(LBuffer);

  Result := True;
end;

{ --- FONT ------------------------------------------------------------------ }
  { TGVFont }
constructor TGVFont.Create;
begin
  inherited;
  FHandle := nil;
  FFilename := '';
  FSize := 0;
  LoadBuiltIn;
end;

destructor TGVFont.Destroy;
begin
  Unload;
  inherited;
end;

function TGVFont.LoadBuiltIn: Boolean;
var
  LHandle: PALLEGRO_FONT;
begin
  Result := FAlse;
  if FHandle <> nil then Exit;
  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR or ALLEGRO_MIPMAP or ALLEGRO_VIDEO_BITMAP);
  LHandle := al_create_builtin_font;
  if LHandle = nil then Exit;

  Unload;
  FHandle := LHandle;
  FFilename := '';
  FSize := 8;

  Result := True;
end;

function TGVFont.LoadDefault(aSize: Cardinal): Boolean;
var
  LFilename: string;
begin
  Result := False;
  if aSize = 0 then Exit;
  LFilename := TPath.Combine(TPath.GetDirectoryName(ParamStr(0)), 'default.ttf');
  if not TFile.Exists(LFilename) then Exit;

  Result := Load(nil, aSize, LFilename);
end;

function TGVFont.Load(aArchive: TGVArchive; aSize: Cardinal; aFilename: string): Boolean;
var
  LMarshaller: TMarshaller;
  LFilename: string;
  LHandle: PALLEGRO_FONT;
begin
  Result := False;
  if FHandle = nil then Exit;
  if aFilename.IsEmpty then Exit;
  if aSize = 0 then Exit;

  if aArchive <> nil then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileExist(aFilename) then Exit;
      LFilename := string(aArchive.GetPasswordFilename(aFilename));
    end
  else
    begin
      if not TFile.Exists(aFilename) then Exit;
      LFilename := aFilename;
    end;

  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR or ALLEGRO_MIPMAP or ALLEGRO_VIDEO_BITMAP);
  if aArchive = nil then GV.SetFileSandBoxed(False);
  LHandle := al_load_ttf_font(LMarshaller.AsUtf8(LFilename).ToPointer, -aSize, 0);
  if aArchive = nil then GV.SetFileSandBoxed(True);
  if LHandle = nil then Exit;

  Unload;
  FHandle := LHandle;
  FFilename := aFilename;
  FSize := aSize;
end;

function TGVFont.Unload: Boolean;
begin
  Result := False;
  if FHandle = nil then Exit;
  al_destroy_font(FHandle);
  FHandle := nil;
  FFilename := '';
  FSize := 0;
  Result := True;
end;

procedure TGVFont.PrintText(aX: Single; aY: Single; aColor: TGVColor; aAlign: TGVHAlign; const aMsg: string; const aArgs: array of const);
var
  LUstr: PALLEGRO_USTR;
  LText: string;
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FHandle = nil then Exit;
  LText := Format(aMsg, aArgs);
  if LText.IsEmpty then  Exit;
  LUstr := al_ustr_new_from_utf16(PUInt16(PChar(LText)));
  al_draw_ustr(FHandle, LColor, aX, aY, Ord(aAlign) or ALLEGRO_ALIGN_INTEGER, LUstr);
  al_ustr_free(LUstr);
end;

procedure TGVFont.PrintText(aX: Single; var aY: Single; aLineSpace: Single; aColor: TGVColor; aAlign: TGVHAlign; const aMsg: string; const aArgs: array of const);
begin
  if FHandle = nil then Exit;
  PrintText(aX, aY, aColor, aAlign, aMsg, aArgs);
  aY := aY + GetLineHeight + aLineSpace;
end;

procedure TGVFont.PrintText(aX: Single; aY: Single; aColor: TGVColor; aAngle: Single; const aMsg: string; const aArgs: array of const);
var
  LUstr: PALLEGRO_USTR;
  LText: string;
  LFX, LFY: Single;
  LTR: ALLEGRO_TRANSFORM;
  LColor: ALLEGRO_COLOR absolute aColor;
  LTrans: ALLEGRO_TRANSFORM;
begin
  if FHandle = nil then Exit;
  LText := Format(aMsg, aArgs);
  if LText.IsEmpty then Exit;
  LFX := GetTextWidth(LText, []) / 2;
  LFY := GetLineHeight / 2;
  al_identity_transform(@LTR);
  al_translate_transform(@LTR, -LFX, -LFY);
  al_rotate_transform(@LTR, aAngle * GV_DEG2RAD);
  GV.Math.AngleRotatePos(aAngle, LFX, LFY);
  al_translate_transform(@LTR, aX + LFX, aY + LFY);
  LTrans := GV.Window.FTransform;
  al_compose_transform(@LTR, @LTrans);
  al_use_transform(@LTR);
  LUstr := al_ustr_new_from_utf16(PUInt16(PChar(LText)));
  al_draw_ustr(FHandle, LColor, 0, 0, ALLEGRO_ALIGN_LEFT or ALLEGRO_ALIGN_INTEGER, LUstr);
  al_ustr_free(LUstr);
  LTrans := GV.Window.FTransform;
  al_use_transform(@LTrans);
end;

function  TGVFont.GetTextWidth(const aMsg: string; const aArgs: array of const): Single;
var
  LUstr: PALLEGRO_USTR;
  LText: string;
begin
  Result := 0;
  if FHandle = nil then Exit;
  LText := Format(aMsg, aArgs);
  if LText.IsEmpty then  Exit;
  LUstr := al_ustr_new_from_utf16(PUInt16(PChar(LText)));
  Result := al_get_ustr_width(FHandle, LUstr);
  al_ustr_free(LUstr);
end;

function  TGVFont.GetLineHeight: Single;
begin
  Result := 0;
  if FHandle = nil then Exit;
  Result := al_get_font_line_height(FHandle);
end;

{ --- AUDIO ----------------------------------------------------------------- }
{ TGVAudio }
function TGVAudio.GetID: Integer;
begin
  Inc(FId);
  Result := FId;
end;

constructor TGVAudio.Create;
begin
  inherited;
  FMusicList := TDictionary<TGVMusic, TMusic>.Create;
  FSampleList := TDictionary<TGVSound, TSound>.Create;
  FSampleIdList := TDictionary<TGVSoundId, ALLEGRO_SAMPLE_ID>.Create;
  ReserveSoundChannels(AUDIO_MAX_CHANNELS);
end;

destructor TGVAudio.Destroy;
begin
  Clear;
  FreeAndNil(FSAmpleIdList);
  FreeAndNil(FSampleList);
  FreeAndNil(FMusicList);
  inherited;
end;

procedure TGVAudio.Update;
var
  LSoundId: TGVSoundId;
  LTrim: Boolean;
begin
  // check if sounds playing
  LTrim := False;
  for LSoundId in FSampleIdList.Keys do
  begin
    if not SoundPlaying(LSoundId) then
    begin
      FSampleIdList.Remove(LSoundId);
      LTrim := True;
    end;
  end;
  if LTrim then
    FSampleIdList.TrimExcess;
end;

procedure TGVAudio.Pause(aPause: Boolean);
begin
  if not al_is_audio_installed then Exit;
  al_set_mixer_playing(GV.Mixer, not aPause);
end;

procedure TGVAudio.Clear;
begin
  UnloadAllSounds;
  UnloadAllMusic;
end;

function  TGVAudio.LoadMusic(aArchive: TGVArchive; const aFilename: string): TGVMusic;
var
  LMarshaller: TMarshaller;
  LFilename: string;
  LMusic: TMusic;
begin
  Result := GV_ID_NIL;
  if not al_is_audio_installed then Exit;
  if aFilename.IsEmpty then Exit;

  if aArchive <> nil then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileExist(aFilename) then Exit;
      LFilename := string(aArchive.GetPasswordFilename(aFilename));
    end
  else
    begin
      if not TFile.Exists(aFilename) then Exit;
      LFilename := aFilename;
    end;

  if aArchive = nil then GV.SetFileSandBoxed(False);
  LMusic.Handle := al_load_audio_stream(LMarshaller.AsUtf8(LFilename).ToPointer, 4, 2048);
  if aArchive = nil then GV.SetFileSandBoxed(True);

  if LMusic.Handle = nil then Exit;

  al_set_audio_stream_playmode(LMusic.Handle, ALLEGRO_PLAYMODE_ONCE);
  al_attach_audio_stream_to_mixer(LMusic.Handle, GV.Mixer);
  al_set_audio_stream_playing(LMusic.Handle, False);

  Result := GetId;
  LMusic.Filename := aFilename;
  FMusicList.Add(Result, LMusic);
end;

function TGVAudio.UnloadMusic(var aMusic: TGVMusic): Boolean;
var
  LMusic: TMusic;
begin
  Result := False;
  if not al_is_audio_installed then Exit;
  if not FMusicList.TryGetValue(aMusic, LMusic) then Exit;
  if LMusic.Handle = nil then Exit;
  al_set_audio_stream_playing(LMusic.Handle, False);
  al_drain_audio_stream(LMusic.Handle);
  al_detach_audio_stream(LMusic.Handle);
  al_destroy_audio_stream(LMusic.Handle);
  FMusicList.Remove(aMusic);
  aMusic := GV_ID_NIL;
  Result := True;
end;

procedure TGVAudio.UnloadAllMusic;
var
  LId: TGVMusic;
  LMusic: TGVMusic;
begin
  if not al_is_audio_installed then Exit;
  for LId in FMusicList.Keys do
  begin
    LMusic := LId;
    UnloadMusic(LMusic);
  end;
end;

function TGVAudio.PlayMusic(aMusic: TGVMusic; aVolume: Single; aLoop: Boolean): Boolean;
var
  LMusic: TMusic;
  LMode: ALLEGRO_PLAYMODE;
begin
  Result := False;

  if not al_is_audio_installed then Exit;
  if not FMusicList.TryGetValue(aMusic, LMusic) then Exit;
  if LMusic.Handle = nil then Exit;

  al_set_audio_stream_playing(LMusic.Handle, False);
  al_rewind_audio_stream(LMusic.Handle);
  al_set_audio_stream_gain(LMusic.Handle, aVolume);
  if aLoop then
    LMode := ALLEGRO_PLAYMODE_LOOP
  else
    LMode := ALLEGRO_PLAYMODE_ONCE;
  al_set_audio_stream_playmode(LMusic.Handle, LMode);
  al_set_audio_stream_playing(LMusic.Handle, True);

  Result := True;
end;

function  TGVAudio.StopMusic(aMusic: TGVMusic): Boolean;
var
  LMusic: TMusic;
begin
  Result := False;
  if not al_is_audio_installed then Exit;
  if not FMusicList.TryGetValue(aMusic, LMusic) then Exit;
  if LMusic.Handle = nil then Exit;

  al_set_audio_stream_playing(LMusic.Handle, False);
  al_rewind_audio_stream(LMusic.Handle);

  Result := True;
end;

procedure TGVAudio.StopAllMusic;
var
  LId: TGVMusic;
  LMusic: TGVMusic;
begin
  if not al_is_audio_installed then Exit;
  for LId in FMusicList.Keys do
  begin
    LMusic := LId;
    StopMusic(LMusic);
  end;
end;

function  TGVAudio.GetMusicLooping(aMusic: TGVMusic): Boolean;
var
  LMusic: TMusic;
  LMode: ALLEGRO_PLAYMODE;
begin
  Result := False;
  if not al_is_audio_installed then Exit;
  if not FMusicList.TryGetValue(aMusic, LMusic) then Exit;
  if LMusic.Handle = nil then Exit;

  LMode := al_get_audio_stream_playmode(LMusic.Handle);
  if (LMode = ALLEGRO_PLAYMODE_LOOP) or
     (LMode = _ALLEGRO_PLAYMODE_STREAM_ONEDIR) then
  begin
    Result := True;
  end;
end;

procedure TGVAudio.SetMusicLooping(aMusic: TGVMusic; aLoop: Boolean);
var
  LMusic: TMusic;
  LMode: ALLEGRO_PLAYMODE;
begin
  if not al_is_audio_installed then Exit;
  if not FMusicList.TryGetValue(aMusic, LMusic) then Exit;
  if LMusic.Handle = nil then Exit;
  if aLoop then
    LMode := ALLEGRO_PLAYMODE_LOOP
  else
    LMode := ALLEGRO_PLAYMODE_ONCE;
  al_set_audio_stream_playmode(LMusic.Handle, LMode);
end;

function  TGVAudio.GetMusicPlaying(aMusic: TGVMusic): Boolean;
var
  LMusic: TMusic;
begin
  Result := False;
  if not al_is_audio_installed then Exit;
  if not FMusicList.TryGetValue(aMusic, LMusic) then Exit;
  if LMusic.Handle = nil then Exit;
  Result := al_get_audio_stream_playing(LMusic.Handle);
end;

procedure TGVAudio.SetMusicPlaying(aMusic: TGVMusic; aPlay: Boolean);
var
  LMusic: TMusic;
begin
  if not al_is_audio_installed then Exit;
  if not FMusicList.TryGetValue(aMusic, LMusic) then Exit;
  if LMusic.Handle = nil then Exit;
  al_set_audio_stream_playing(LMusic.Handle, aPlay);
end;

procedure TGVAudio.SetMusicVolume(aMusic: TGVMusic; aVolume: Single);
var
  LMusic: TMusic;
begin
  if not al_is_audio_installed then Exit;
  if not FMusicList.TryGetValue(aMusic, LMusic) then Exit;
  if LMusic.Handle = nil then Exit;
  al_set_audio_stream_gain(LMusic.Handle, aVolume);
end;

function  TGVAudio.GetMusicVolume(aMusic: TGVMusic): Single;
var
  LMusic: TMusic;
begin
  Result := 0;
  if not al_is_audio_installed then Exit;
  if not FMusicList.TryGetValue(aMusic, LMusic) then Exit;
  if LMusic.Handle = nil then Exit;
  Result := al_get_audio_stream_gain(LMusic.Handle);
end;

procedure TGVAudio.SeekMusic(aMusic: TGVMusic; aTime: Single);
var
  LMusic: TMusic;
begin
  if not al_is_audio_installed then Exit;
  if not FMusicList.TryGetValue(aMusic, LMusic) then Exit;
  if LMusic.Handle = nil then Exit;
  al_seek_audio_stream_secs(LMusic.Handle, aTime);
end;

procedure TGVAudio.RewindMusic(aMusic: TGVMusic; aTime: Single);
var
  LMusic: TMusic;
begin
  if not al_is_audio_installed then Exit;
  if not FMusicList.TryGetValue(aMusic, LMusic) then Exit;
  if LMusic.Handle = nil then Exit;
  al_rewind_audio_stream(LMusic.Handle);
end;

function  TGVAudio.ReserveSoundChannels(aCount: Integer): Boolean;
begin
  Result := False;
  if not al_is_audio_installed then Exit;
  Result := al_reserve_samples(aCount);
end;

function  TGVAudio.LoadSound(aArchive: TGVArchive; const aFilename: string): TGVSound;
var
  LMarshaller: TMarshaller;
  LFilename: string;
  LSound: TSound;
begin
  Result := GV_ID_NIL;

  if not al_is_audio_installed then Exit;
  if aFilename.IsEmpty then Exit;

  if aArchive <> nil then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileExist(aFilename) then Exit;
      LFilename := string(aArchive.GetPasswordFilename(aFilename));
    end
  else
    begin
      if not TFile.Exists(aFilename) then Exit;
      LFilename := aFilename;
    end;

  if aArchive = nil then GV.SetFileSandBoxed(False);
  LSound.Handle := al_load_sample(LMarshaller.AsUtf8(LFilename).ToPointer);
  if aArchive = nil then GV.SetFileSandBoxed(True);

  if LSound.Handle = nil then Exit;

  Result := GetID;
  LSound.Filename := aFilename;
  FSampleList.Add(Result, LSound);
end;

procedure TGVAudio.UnloadSound(var aSound: TGVSound);
var
  LSound: TSound;
begin
  if not al_is_audio_installed then Exit;
  if not FSampleList.TryGetValue(aSound, LSound) then Exit;
  if LSound.Handle = nil then Exit;
  al_destroy_sample(LSound.Handle);
  FSampleList.Remove(aSound);
  aSound := GV_ID_NIL;
end;

procedure TGVAudio.UnloadAllSounds;
var
  LKey: TGVSound;
  LSound: TGVSound;
begin
  if not al_is_audio_installed then Exit;
  for LKey in FSampleList.Keys do
  begin
    LSound := LKey;
    UnloadSound(LSound);
  end;
end;

function  TGVAudio.PlaySound(aSound: TGVSound; aVolume: Single; aLoop: Boolean; aPan: Single; aSpeed: Single): TGVSoundId;
var
  LSound: TSound;
  LMode: ALLEGRO_PLAYMODE;
  LID: ALLEGRO_SAMPLE_ID;
begin
  Result := GV_ID_NIL;
  if not al_is_audio_installed then Exit;
  if not FSampleList.TryGetValue(aSound, LSound) then Exit;
  if LSound.Handle = nil then Exit;

  if aLoop then
    LMode := ALLEGRO_PLAYMODE_LOOP
  else
    LMode := ALLEGRO_PLAYMODE_ONCE;

  if not al_play_sample(LSound.Handle, aVolume, aPan, aSpeed, LMode, @LID) then Exit;

  Result := GetID;
  FSampleIdList.Add(Result, LID);
end;

procedure TGVAudio.StopSound(var aId: TGVSoundId);
var
  LID: ALLEGRO_SAMPLE_ID;
  LInstance: PALLEGRO_SAMPLE_INSTANCE;
begin
  if not al_is_audio_installed then Exit;
  if not FSampleIdList.TryGetValue(aId, LID) then Exit;
  LInstance := al_lock_sample_id(@LID);
  try
    if LInstance = nil then Exit;
    if not al_get_sample_instance_playing(LInstance) then Exit;
    al_stop_sample(@LID);
    aId := GV_ID_NIL;
  finally
    al_unlock_sample_id(@LID);
  end;
end;

procedure TGVAudio.StopAllSounds;
var
  LKey: TGVSoundId;
  LSound: TGVSoundId;
begin
  if not al_is_audio_installed then Exit;
  for LKey in FSampleIdList.Keys do
  begin
    LSound := LKey;
    StopSound(LSound);
  end;
end;

function  TGVAudio.SoundPlaying(aId: TGVSoundId): Boolean;
var
  LID: ALLEGRO_SAMPLE_ID;
  LInstance: PALLEGRO_SAMPLE_INSTANCE;
begin
  Result := False;
  if not al_is_audio_installed then Exit;
  if not FSampleIdList.TryGetValue(aId, LID) then Exit;
  LInstance := al_lock_sample_id(@LID);
  try
    if LInstance = nil then Exit;
    Result := al_get_sample_instance_playing(LInstance);
  finally
    al_unlock_sample_id(@LID);
  end;
end;

{ --- VIDEO ----------------------------------------------------------------- }
{ TGVVideo }
procedure TGVVideo.OnFinished(aHandle: PALLEGRO_VIDEO);
begin
  if FHandle <> aHandle then Exit;

  Rewind;
  if FLoop then
    begin
      if not FPaused then
        SetPlaying(True);
    end
  else
    begin
      GV.Game.OnFinishedVideo(FFilename)
    end;
end;

constructor TGVVideo.Create;
begin
  inherited;
end;

destructor TGVVideo.Destroy;
begin
  Unload;
  inherited;
end;

function  TGVVideo.Load(aArchive: TGVArchive; const aFilename: string): Boolean;
var
  LMarshallar: TMarshaller;
  LFilename: string;
  LHandle: PALLEGRO_VIDEO;
begin
  Result := False;
  if aFilename.IsEmpty then Exit;

  if aArchive <> nil then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileExist(aFilename) then Exit;
      LFilename := string(aArchive.GetPasswordFilename(aFilename));
    end
  else
    begin
      if not TFile.Exists(aFilename) then Exit;
      LFilename := aFilename;
    end;

  if aArchive = nil then GV.SetFileSandBoxed(False);
  LHandle := al_open_video(LMarshallar.AsUtf8(LFilename).ToPointer);
  if aArchive = nil then GV.SetFileSandBoxed(True);

  if LHandle = nil then Exit;

  Unload;

  if al_is_audio_installed then
  begin
    if FVoice = nil then
    begin
      FVoice := al_create_voice(44100, ALLEGRO_AUDIO_DEPTH_INT16, ALLEGRO_CHANNEL_CONF_2);
      FMixer := al_create_mixer(44100, ALLEGRO_AUDIO_DEPTH_FLOAT32, ALLEGRO_CHANNEL_CONF_2);
      al_attach_mixer_to_voice(FMixer, FVoice);
    end;
  end;

  al_register_event_source(GV.Queue, al_get_video_event_source(LHandle));
  al_set_video_playing(LHandle, False);

  FHandle := LHandle;
  FFilename := aFilename;
  FLoop := False;
  FPlaying := False;
  FPaused := False;
  GV.Game.OnLoadVideo(FFilename);
  Result := True;
end;

function  TGVVideo.Unload: Boolean;
begin
  Result := False;
  if FHandle = nil then Exit;
  GV.Game.OnUnloadVideo(FFilename);
  al_set_video_playing(FHandle, False);
  al_unregister_event_source(GV.Queue, al_get_video_event_source(FHandle));
  al_close_video(FHandle);

  if al_is_audio_installed then
  begin
    al_detach_mixer(FMixer);
    al_destroy_mixer(FMixer);
    al_destroy_voice(FVoice);
  end;

  FHandle := nil;
  FFilename := '';
  FLoop := False;
  FPlaying := False;
  FPaused := False;
end;

function  TGVVideo.GetPause: Boolean;
begin
  Result := False;
  if FHandle = nil then Exit;
  Result := FPaused;
end;

procedure TGVVideo.SetPause(aPause: Boolean);
begin
  if FHandle = nil then Exit;

  // if trying to pause and video is not playing, just exit
  if (aPause = True) then
  begin
    if not al_is_video_playing(FHandle) then
    Exit;
  end;

  // if trying to unpause without first being paused, just exit
  if (aPause = False) then
  begin
    if FPaused = False then
      Exit;
  end;

  al_set_video_playing(FHandle, not aPause);
  FPaused := aPause;
end;

function  TGVVideo.GetLooping:  Boolean;
begin
  Result := False;
  if FHandle = nil then Exit;
  Result := FLoop;
end;

procedure TGVVideo.Setooping(aLoop: Boolean);
begin
  if FHandle = nil then Exit;
  FLoop := aLoop;
end;

function  TGVVideo.GetPlaying: Boolean;
begin
  Result := False;
  if FHandle = nil then Exit;
  Result := al_is_video_playing(FHandle);
end;

procedure TGVVideo.SetPlaying(aPlay: Boolean);
begin
  if FHandle = nil then Exit;
  if FPaused then Exit;
  al_set_video_playing(FHandle, aPlay);
  FPlaying := aPlay;
  FPaused := False;
end;

function  TGVVideo.GetFilename: string;
begin
  Result := '';
  if FHandle = nil then Exit;
  Result := FFilename;
end;

procedure TGVVideo.Play(aArchive: TGVArchive; const aFilename: string; aLoop: Boolean; aVolume: Single);
begin
  if not Load(aArchive, aFilename) then Exit;
  Play(aLoop, aVolume);
end;

procedure TGVVideo.Play(aLoop: Boolean; aVolume: Single);
begin
  if FHandle = nil then Exit;
  al_start_video(FHandle, GV.Mixer);
  al_set_mixer_gain(FMixer, aVolume);
  al_set_video_playing(FHandle, True);
  FLoop := aLoop;
  FPlaying := True;
  FPaused := False;
end;

procedure TGVVideo.Draw(aX: Single; aY: Single; aScale: Single);
var
  LFrame: PALLEGRO_BITMAP;
  LSize: TGVVector;
  LScaled: TGVVector;
  LViewportSize: TGVRectangle;
  LScale: Single;
begin
  if FHandle = nil then Exit;
  if aScale <= 0 then Exit;
  LScale := aScale;

  if (not GetPlaying) and (not FPaused) then Exit;

  LFrame := al_get_video_frame(FHandle);
  if LFrame <> nil then
  begin

    GV.Window.GetViewportSize(LViewportSize);
    LSize.X := al_get_bitmap_width(LFrame);
    LSize.Y := al_get_bitmap_height(LFrame);
    LScaled.X := al_get_video_scaled_width(FHandle);
    LScaled.Y := al_get_video_scaled_height(FHandle);

    al_draw_scaled_bitmap(LFrame, 0, 0,
      LSize.X,
      LSize.Y,
      aX, aY,
      LScaled.X*LScale,
      LScaled.Y*LScale,
      0);
  end;
end;

procedure TGVVideo.GetSize(aWidth: PSingle; aHeight: PSingle);
begin
  if FHandle = nil then
  begin
    if aWidth <> nil then
      aWidth^ := 0;
    if aHeight <> nil then
      aHeight^ := 0;
    Exit;
  end;
  if aWidth <> nil then
    aWidth^ := al_get_video_scaled_width(FHandle);
  if aHeight <> nil then
    aHeight^ := al_get_video_scaled_height(FHandle);
end;

procedure TGVVideo.Seek(aSeconds: Single);
begin
  if FHandle = nil then Exit;
  al_seek_video(FHandle, aSeconds);
end;

procedure TGVVideo.Rewind;
begin
  if FHandle = nil then Exit;
  al_seek_video(FHandle, 0);
end;

{ --- CONFIGFILE ------------------------------------------------------------ }
  { TGVConfigFile }
constructor TGVConfigFile.Create;
begin
  inherited;

  FHandle := nil;
  FSection := TStringList.Create;
end;

destructor TGVConfigFile.Destroy;
begin
  Close;
  FreeAndNil(FSection);

  inherited;
end;

function  TGVConfigFile.Open(const aFilename: string=''): Boolean;
var
  LFilename: string;
begin
  Result := False;
  if IsOpen then Exit;
  LFilename := aFilename;
  if LFilename.IsEmpty then LFilename := TPath.ChangeExtension(ParamStr(0), GV_FILEEXT_INI);
  FHandle := TIniFile.Create(LFilename);
  Result := Boolean(FHandle <> nil);
  FFilename := LFilename;
end;

procedure TGVConfigFile.Close;
begin
  if not IsOpen then Exit;
  FHandle.UpdateFile;
  FreeAndNil(FHandle);
end;

function  TGVConfigFile.IsOpen: Boolean;
begin
  Result := Boolean(FHandle <> nil);
end;

procedure TGVConfigFile.Update;
begin
  if not IsOpen then Exit;
  FHandle.UpdateFile;
end;

function  TGVConfigFile.RemoveSection(const aName: string): Boolean;
var
  LName: string;
begin
  Result := False;
  if FHandle = nil then Exit;
  LName := aName;
  if LName.IsEmpty then Exit;
  FHandle.EraseSection(LName);
  Result := True;
end;

procedure TGVConfigFile.SetValue(const aSection: string; const aKey: string; const aValue: string);
begin
  if FHandle = nil then Exit;
  FHandle.WriteString(aSection, aKey, aValue);
end;

procedure TGVConfigFile.SetValue(const aSection: string; const aKey: string; aValue: Integer);
begin
  SetValue(aSection, aKey, aValue.ToString);
end;

procedure TGVConfigFile.SetValue(const aSection: string; const aKey: string; aValue: Boolean);
begin
  SetValue(aSection, aKey, aValue.ToInteger);
end;

procedure TGVConfigFile.SetValue(const aSection: string; const aKey: string; aValue: Pointer; aValueSize: Cardinal);
var
  LValue: TMemoryStream;
begin
  if aValue = nil then Exit;
  LValue := TMemoryStream.Create;
  try
    LValue.Position := 0;
    LValue.Write(aValue^, aValueSize);
    LValue.Position := 0;
    FHandle.WriteBinaryStream(aSection, aKey, LValue);
  finally
    FreeAndNil(LValue);
  end;
end;

function  TGVConfigFile.GetValue(const aSection: string; const aKey: string; const aDefaultValue: string): string;
begin
  Result := '';
  if FHandle = nil then Exit;
  Result := FHandle.ReadString(aSection, aKey, aDefaultValue);
end;

function  TGVConfigFile.GetValue(const aSection: string; const aKey: string; aDefaultValue: Integer): Integer;
var
  LResult: string;
begin
  LResult := GetValue(aSection, aKey, aDefaultValue.ToString);
  Integer.TryParse(LResult, Result);
end;

function  TGVConfigFile.GetValue(const aSection: string; const aKey: string; aDefaultValue: Boolean): Boolean;
begin
  Result := GetValue(aSection, aKey, aDefaultValue.ToInteger).ToBoolean;
end;

procedure TGVConfigFile.GetValue(const aSection: string; const aKey: string; aValue: Pointer; aValueSize: Cardinal);
var
  LValue: TMemoryStream;
  LSize: Cardinal;
begin
  LValue := TMemoryStream.Create;
  try
    LValue.Position := 0;
    FHandle.ReadBinaryStream(aSection, aKey, LValue);
    LSize := aValueSize;
    if aValueSize > LValue.Size then
      LSize := LValue.Size;
    LValue.Position := 0;
    LValue.Write(aValue^, LSize);
  finally
    FreeAndNil(LValue);
  end;

end;

function  TGVConfigFile.RemoveKey(const aSection: string; const aKey: string): Boolean;
var
  LSection: string;
  LKey: string;
begin
  Result := False;
  if FHandle = nil then Exit;
  LSection := aSection;
  LKey := aKey;
  if LSection.IsEmpty then Exit;
  if LKey.IsEmpty then Exit;
  FHandle.DeleteKey(LSection, LKey);
  Result := True;
end;

function  TGVConfigFile.GetSectionValues(const aSection: string): Integer;
var
  LSection: string;
begin
  Result := 0;
  if LSection.IsEmpty then Exit;
  LSection := aSection;
  FSection.Clear;
  FHandle.ReadSectionValues(LSection, FSection);
  Result := FSection.Count;
end;

function  TGVConfigFile.GetSectionValue(aIndex: Integer; aDefaultValue: string): string;
begin
  Result := '';
  if (aIndex < 0) or (aIndex > FSection.Count - 1) then Exit;
  Result := FSection.ValueFromIndex[aIndex];
  if Result = '' then Result := aDefaultValue;
end;

function  TGVConfigFile.GetSectionValue(aIndex: Integer; aDefaultValue: Integer): Integer;
begin
  Result := string(GetSectionValue(aIndex, aDefaultValue.ToString)).ToInteger;
end;

function  TGVConfigFile.GetSectionValue(aIndex: Integer; aDefaultValue: Boolean): Boolean;
begin
  Result := string(GetSectionValue(aIndex, aDefaultValue.ToString)).ToBoolean
end;

{ --- SPEECH ---------------------------------------------------------------- }
{  TGVSpeech }
procedure TGVSpeech.OnWord(aSender: TObject; aStreamNumber: Integer; aStreamPosition: OleVariant; aCharacterPosition, aLength: Integer);
begin
  if FText.IsEmpty then Exit;
  FWord := FText.Substring(aCharacterPosition, aLength);
  GV.Game.OnSpeechWord(FWord, FText);
end;

//procedure Speech.OnStartStream(aSender: TObject; aStreamNumber: Integer; aStreamPosition: OleVariant);
//begin
//end;

procedure TGVSpeech.DoSpeak(aText: string; aFlags: Integer);
begin
  if FSpVoice = nil then Exit;
  if aText.IsEmpty then Exit;
  if FPaused then Resume;
  FSpVoice.Speak(aText, aFlags);
  FText := aText;
end;

procedure TGVSpeech.EnumVoices;
var
  LI: Integer;
  LSOToken: ISpeechObjectToken;
  LSOTokens: ISpeechObjectTokens;
begin
  FVoiceList := TInterfaceList.Create;
  FVoiceDescList := TStringList.Create;
  LSOTokens := FSpVoice.GetVoices('', '');
  for LI := 0 to LSOTokens.Count - 1 do
  begin
    LSOToken := LSOTokens.Item(LI);
    FVoiceDescList.Add(LSOToken.GetDescription(0));
    FVoiceList.Add(LSOToken);
  end;
end;

procedure TGVSpeech.FreeVoices;
begin
  FreeAndNil(FVoiceDescList);
  FreeAndNil(FVoiceList);
end;

procedure TGVSpeech.Setup;
begin
  FPaused := False;
  FText := '';
  FWord := '';
  FVoice := 0;
  FSpVoice := TSpVoice.Create(nil);
  FSpVoice.EventInterests := SVEAllEvents;
  EnumVoices;
  //FSpVoice.OnStartStream := OnStartStream;
  FSpVoice.OnWord := OnWord;
  GV.Logger.Log('Initialized %s Subsystem', ['Speech']);
end;

procedure TGVSpeech.Shutdown;
begin
  FreeVoices;
  FSpVoice.OnWord := nil;
  FSpVoice.Free;

  GV.Logger.Log('Shutdown %s Subsystem', ['Speech']);
end;

constructor TGVSpeech.Create;
begin
  inherited;
  Setup;
end;

destructor TGVSpeech.Destroy;
begin
  Shutdown;
  inherited;
end;

function TGVSpeech.GetVoiceCount: Integer;
begin
  Result := FVoiceList.Count;
end;

function TGVSpeech.GetVoiceAttribute(aIndex: Integer; aAttribute: TGVSpeechVoiceAttribute): WideString;
var
  LSOToken: ISpeechObjectToken;

  function GetAttr(aItem: string): string;
  begin
    if aItem = 'Id' then
      Result := LSOToken.Id
    else
      Result := LSOToken.GetAttribute(aItem);
  end;

begin
  Result := '';
  if (aIndex < 0) or (aIndex > FVoiceList.Count - 1) then
    Exit;
  LSOToken := ISpeechObjectToken(FVoiceList.Items[aIndex]);
  case aAttribute of
    TGVSpeechVoiceAttribute.Description:
      Result := FVoiceDescList[aIndex];
    TGVSpeechVoiceAttribute.Name:
      Result := GetAttr('Name');
    TGVSpeechVoiceAttribute.Vendor:
      Result := GetAttr('Vendor');
    TGVSpeechVoiceAttribute.Age:
      Result := GetAttr('Age');
    TGVSpeechVoiceAttribute.Gender:
      Result := GetAttr('Gender');
    TGVSpeechVoiceAttribute.Language:
      Result := GetAttr('Language');
    TGVSpeechVoiceAttribute.Id:
      Result := GetAttr('Id');
  end;
end;

procedure TGVSpeech.ChangeVoice(aIndex: Integer);
var
  LSOToken: ISpeechObjectToken;
begin
  if (aIndex < 0) or (aIndex > FVoiceList.Count - 1) then Exit;
  if aIndex = FVoice then Exit;
  LSOToken := ISpeechObjectToken(FVoiceList.Items[aIndex]);
  FSpVoice.Voice := LSOToken;
  FVoice := aIndex;
end;

function TGVSpeech.GetVoice: Integer;
begin
  Result := FVoice;
end;

procedure TGVSpeech.SetVolume(aVolume: Single);
var
  LVolume: Integer;
begin
  if aVolume < 0 then
    aVolume := 0
  else if aVolume > 1 then
    aVolume := 1;

  LVolume := Round(100.0 * aVolume);

  if FSpVoice = nil then
    Exit;
  FSpVoice.Volume := LVolume;
end;

function TGVSpeech.GetVolume: Single;
begin
  Result := 0;
  if FSpVoice = nil then Exit;
  Result := FSpVoice.Volume / 100.0;
end;

procedure TGVSpeech.SetRate(aRate: Single);
var
  LVolume: Integer;
begin
  if aRate < 0 then
    aRate := 0
  else if aRate > 1 then
    aRate := 1;

  LVolume := Round(20.0 * aRate) - 10;

  if LVolume < -10 then
    LVolume := -10
  else if LVolume > 10 then
    LVolume := 10;

  if FSpVoice = nil then
    Exit;
  FSpVoice.Rate := LVolume;
end;

function TGVSpeech.GetRate: Single;
begin
  Result := 0;
  if FSpVoice = nil then Exit;
  Result := (FSpVoice.Rate + 10.0) / 20.0;
end;

procedure TGVSpeech.Say(const aText: WideString; aPurge: Boolean);
var
  LFlag: Integer;
  LText: string;
begin
  LFlag := SVSFlagsAsync;
  LText := aText;
  if aPurge then
    LFlag := LFlag or SVSFPurgeBeforeSpeak;
  DoSpeak(LText, LFlag);
end;

procedure TGVSpeech.SayXML(const aText: WideString; aPurge: Boolean);
var
  LFlag: Integer;
  LText: string;
begin
  LFlag := SVSFlagsAsync or SVSFIsXML;
  if aPurge then
    LFlag := LFlag or SVSFPurgeBeforeSpeak;
  LText := aText;
  DoSpeak(aText, LFlag);
end;

procedure TGVSpeech.Clear;
begin
  if FSpVoice = nil then Exit;
  if Active then
  begin
    FSpVoice.Skip('Sentence', MaxInt);
    Say(' ', True);
  end;
  FText := '';
end;

function TGVSpeech.Active: Boolean;
begin
  Result := False;
  if FSpVoice = nil then Exit;
  Result := Boolean(FSpVoice.Status.RunningState <> SRSEDone);
end;

procedure TGVSpeech.Pause;
begin
  if FSpVoice = nil then Exit;
  FSpVoice.Pause;
  FPaused := True;
end;

procedure TGVSpeech.Resume;
begin
  if FSpVoice = nil then Exit;
  FSpVoice.Resume;
  FPaused := False;
end;

procedure TGVSpeech.Reset;
begin
  Clear;
  FreeAndNil(FSpVoice);
  FPaused := False;
  FText := '';
  FWord := '';
  FSpVoice := TSpVoice.Create(nil);
  FSpVoice.EventInterests := SVEAllEvents;
  EnumVoices;
  //FSpVoice.OnStartStream := OnStartStream;
  FSpVoice.OnWord := OnWord;
end;

{ --- ASYNC ----------------------------------------------------------------- }
{ TGVAsyncThread }
constructor TGVAsyncThread.Create;
begin
  inherited Create(True);

  FTask := nil;
  FWait := nil;
  FFinished := False;
end;

destructor TGVAsyncThread.Destroy;
begin
  inherited;
end;

procedure TGVAsyncThread.Execute;
begin
  FFinished := False;

  if Assigned(FTask) then
  begin
    FTask();
  end;

  FFinished := True;
end;

{ TGVAsync }
procedure TGVAsync.Setup;
begin
  FCriticalSection := TCriticalSection.Create;
  FQueue := TList<TGVAsyncThread>.Create;
end;

procedure TGVAsync.Shutdown;
begin
  FreeAndNil(FQueue);
  FreeAndNil(FCriticalSection);
end;

procedure TGVAsync.Process;
var
  LAsyncThread: TGVAsyncThread;
begin
  Enter;

  if TThread.CurrentThread.ThreadID = MainThreadID then
  begin
    for LAsyncThread in FQueue do
    begin
      if Assigned(LAsyncThread) then
      begin
        if LAsyncThread.Finished then
        begin
          LAsyncThread.WaitFor;
          if Assigned(LAsyncThread.WaitProc) then
            LAsyncThread.WaitProc();
          FQueue.Remove(LAsyncThread);
          FreeAndNil(LAsyncThread);
        end;
      end;
    end;
    FQueue.Pack;
  end;

  Leave;
end;

constructor TGVAsync.Create;
begin
  inherited;
  Setup;
end;

destructor TGVAsync.Destroy;
begin
  Shutdown;
  inherited;
end;

procedure TGVAsync.Run(aTask: TProc; aWait: TProc);
var
  LAsyncThread: TGVAsyncThread;
begin
  if not Assigned(aTask) then Exit;
  LAsyncThread := TGVAsyncThread.Create;
  LAsyncThread.TaskProc := aTask;
  if Assigned(aWait) then LAsyncThread.WaitProc := aWait;
  FQueue.Add(LAsyncThread);
  LAsyncThread.Start;
end;

procedure TGVAsync.Enter;
begin
  FCriticalSection.Enter;
end;

procedure TGVAsync.Leave;
begin
  FCriticalSection.Leave;
end;

{ --- DATABASE -------------------------------------------------------------- }
{ TGVDatabase }
constructor TGVDatabase.Create;
begin
  inherited;
  FHandle := gv_database_create;
end;

destructor TGVDatabase.Destroy;
begin
  gv_database_destroy(FHandle);
  inherited;
end;

procedure TGVDatabase.SetupMySQL(const aServer: string; aPort: Integer; const aDatabase: string; const aUserName: string; const aPassword: string);
begin
  gv_database_setupmysql(FHandle, aServer, aPort, aDatabase, aUserName, aPassword);
end;

procedure TGVDatabase.SetupSQLite(const aDatabase: string; aPassword: string);
begin
  gv_database_setupsqlite(FHandle, aDatabase, aPassword);
end;

procedure TGVDatabase.Open;
begin
  gv_database_open(FHandle);
end;

procedure TGVDatabase.Close;
begin
  gv_database_close(FHandle);
end;

function TGVDatabase.Connected: Boolean;
begin
  Result := gv_database_connected(FHandle);
end;

function TGVDatabase.ExecSQL(const aSQL: string; const aParams: array of const): LongInt;
begin
  Result := gv_database_execsql(FHandle, aSQL, aParams);
end;

function TGVDatabase.ExecSQLScalar(const aSQL: string; const aParams: array of const): string;
begin
  Result := gv_database_execsql_scalar(FHandle, aSQL, aParams);
end;

function TGVDatabase.Query(const aSQL: string; const aParams: array of const): LongInt;
begin
  Result := gv_database_query(FHandle, aSQL, aParams);
end;

function TGVDatabase.QueryFieldCount: Integer;
begin
  Result := gv_database_query_field_count(FHandle);
end;

function TGVDatabase.QueryRecordCount: Integer;
begin
  Result := gv_databaes_query_record_count(FHandle);
end;

function TGVDatabase.QueryBOF: Boolean;
begin
  Result := gv_database_query_bof(FHandle);
end;

function TGVDatabase.QueryEOF: Boolean;
begin
  Result := gv_database_query_eof(FHandle);
end;

procedure TGVDatabase.QueryNext;
begin
  gv_database_query_next(FHandle);
end;

procedure TGVDatabase.QueryPrev;
begin
  gv_database_query_prev(FHandle);
end;

procedure TGVDatabase.QueryLast;
begin
  gv_database_query_last(FHandle);
end;

procedure TGVDatabase.QueryFirst;
begin
  gv_database_query_first(FHandle);
end;

function TGVDatabase.QueryField(const aName: string): string;
begin
  Result := gv_database_query_field(FHandle, aName);
end;

function TGVDatabase.LastError: string;
begin
  Result := gv_database_last_error(FHandle);
end;

{ --- SCREENSHOT ------------------------------------------------------------ }
{ TGVScreenshot }
procedure TGVScreenshot.Process;
var
  LC: Integer;
  LF, LD, LB: string;
begin
  if GV.Screenshake.Active then Exit;
  if not FFlag then Exit;

  FFlag := False;

  // directory
  LD := ExpandFilename(FDir);
  ForceDirectories(LD);

  // base name
  LB := FBaseFilename;

  // search file maks
  LF := LB + '*.png';

  // file count
  LC := GV.Util.FileCount(LD, LF);

  // screenshot file mask
  LF := Format('%s\%s (%.6d).png', [LD, LB, LC]);
  FFilename := LF;

  // save screenshot
  GV.Window.Save(LF);

  // call event handler
  if TFile.Exists(LF) then
    GV.Game.OnScreenshot(LF);
end;

constructor TGVScreenshot.Create;
begin
  inherited;
  FFlag := False;
  FFilename := '';
  FDir := 'Screenshots';
  FBaseFilename := 'Screen';
  Init('', '');
end;

destructor TGVScreenshot.Destroy;
begin
  inherited;
end;

procedure TGVScreenshot.Init(const aDir: WideString; const aBaseFilename: WideString);
var
  LDir: string;
  LBaseFilename: string;
begin
  FFilename := '';
  FFlag := False;

  LDir := aDir;
  LBaseFilename := aBaseFilename;

  if LDir.IsEmpty then
    LDir := 'Screenshots';
  FDir := LDir;

  if LBaseFilename.IsEmpty then
    LBaseFilename := 'Screen';
  FBaseFilename := LBaseFilename;

  ChangeFileExt(FBaseFilename, '');
end;

procedure TGVScreenshot.Take;
begin
  FFlag := True;
end;


{ --- SCREENSHAKE ----------------------------------------------------------- }
{ TGVAScreenshake }
constructor TGVAScreenshake.Create(aDuration: Single; aMagnitude: Single);
begin
  inherited Create;

  FActive := True;
  FDuration := aDuration;
  FMagnitude := aMagnitude;
  FTimer := 0;
  FPos.x := 0;
  FPos.y := 0;
end;

destructor TGVAScreenshake.Destroy;
begin

  inherited;
end;

function lerp(t: Single; a: Single; b: Single): Single; inline;
begin
  Result := (1 - t) * a + t * b;
end;

procedure TGVAScreenshake.Process(aSpeed: Single; aDeltaTime: Double);
begin
  if not FActive then Exit;

  FDuration := FDuration - (aSpeed * aDeltaTime);
  if FDuration <= 0 then
  begin
    GV.Window.SetTransformPosition(-FPos.x, -FPos.y);
    FActive := False;
    Exit;
  end;

  if Round(FDuration) <> Round(FTimer) then
  begin
    GV.Window.SetTransformPosition(-FPos.x, -FPos.y);

    FPos.x := Round(GV.Math.RandomRange(-FMagnitude, FMagnitude));
    FPos.y := Round(GV.Math.RandomRange(-FMagnitude, FMagnitude));

    GV.Window.SetTransformPosition(FPos.x, FPos.y);

    FTimer := FDuration;
  end;
end;

{ TGVScreenshake }
procedure TGVScreenshake.Process(aSpeed: Single; aDeltaTime: Double);
var
  LShake: TGVAScreenshake;
  LFlag: Boolean;
begin
  // process shakes
  LFlag := Active;
  for LShake in FList do
  begin
    if LShake.Active then
    begin
      LShake.Process(aSpeed, aDeltaTime);
    end
    else
    begin
      FList.Remove(LShake);
    end;
  end;

  if LFlag then
  begin
    if not Active then
    begin
      // Lib.Display.ResetTransform;
    end;
  end;
end;

constructor TGVScreenshake.Create;
begin
  inherited;
  FList := TObjectList<TGVAScreenshake>.Create(True);
  al_identity_transform(@FTrans);
end;

destructor TGVScreenshake.Destroy;
begin
  FreeAndNil(FList);
  inherited;
end;

procedure TGVScreenshake.Start(aDuration: Single; aMagnitude: Single);
var
  LShake: TGVAScreenshake;
begin
  LShake := TGVAScreenshake.Create(aDuration, aMagnitude);
  FList.Add(LShake);
end;

procedure TGVScreenshake.Clear;
begin
  FList.Clear;
end;

function TGVScreenshake.Active: Boolean;
begin
  Result := Boolean(FList.Count > 0);
end;

{ --- STARFIELD ------------------------------------------------------------- }
{ TGVStarfield }
procedure TGVStarfield.TransformDrawPoint(aX, aY, aZ: Single; aVPX, aVPY, aVPW, aVPH: Integer);
var
  LX, LY: Single;
  LSW, LSH: Single;
  LOOZ: Single;
  LCV: byte;
  LColor: TGVColor;

  function IsVisible(vx, vy, vw, vh: Single): Boolean;
  begin
    Result := False;
    if ((vx - vw) < 0) then
      Exit;
    if (vx > (aVPW - 1)) then
      Exit;
    if ((vy - vh) < 0) then
      Exit;
    if (vy > (aVPH - 1)) then
      Exit;
    Result := True;
  end;

begin
  FViewScaleRatio := aVPW / aVPH;
  FCenter.X := (aVPW / 2) + aVPX;
  FCenter.Y := (aVPH / 2) + aVPY;

  LOOZ := ((1.0 / aZ) * FViewScale);
  LX := (FCenter.X - aVPX) - (aX * LOOZ) * FViewScaleRatio;
  LY := (FCenter.Y - aVPY) + (aY * LOOZ) * FViewScaleRatio;
  LSW := (GV.Window.Scale * LOOZ);
  if LSW < GV.Window.Scale then
    LSW := GV.Window.Scale;
  LSH := (GV.Window.Scale * LOOZ);
  if LSH < GV.Window.Scale then
    LSH := GV.Window.Scale;

  if not IsVisible(LX, LY, LSW, LSH) then Exit;
  LCV := round(255.0 - (((1.0 / FMax.Z) / (1.0 / aZ)) * 255.0));

  LColor.Make(LCV, LCV, LCV, LCV);

  LX := LX - FVirtualPos.X;
  LY := LY - FVirtualPos.Y;

  GV.Primitive.FilledRectangle(LX, LY, LSW, LSH, LColor);

end;

constructor TGVStarfield.Create;
begin
  inherited;

  Init(250, -1000, -1000, 10, 1000, 1000, 1000, 120);
end;

destructor TGVStarfield.Destroy;
begin
  Done;
  inherited;
end;

procedure TGVStarfield.Init(aStarCount: Cardinal; aMinX, aMinY, aMinZ, aMaxX, aMaxY, aMaxZ, aViewScale: Single);
var
  LVPX, LVPY: Integer;
  LVPW, LVPH: Integer;
  LI: Integer;
  LSize: TGVRectangle;
begin
  Done;

  FStarCount := aStarCount;
  SetLength(FStar, FStarCount);
  GV.Window.GetViewportSize(LSize);
  LVPX := Round(LSize.X);
  LVPY := Round(LSize.Y);
  LVPW := Round(LSize.Width);
  LVPH := Round(LSize.Height);

  FViewScale := aViewScale;
  FViewScaleRatio := LVPW / LVPH;
  FCenter.X := (LVPW / 2) + LVPX;
  FCenter.Y := (LVPH / 2) + LVPY;
  FCenter.Z := 0;

  FMin.X := aMinX;
  FMin.Y := aMinY;
  FMin.Z := aMinZ;
  FMax.X := aMaxX;
  FMax.Y := aMaxY;
  FMax.Z := aMaxZ;

  for LI := 0 to FStarCount - 1 do
  begin
    FStar[LI].X := GV.Math.RandomRange(FMin.X, FMax.X);
    FStar[LI].Y := GV.Math.RandomRange(FMin.Y, FMax.Y);
    FStar[LI].Z := GV.Math.RandomRange(FMin.Z, FMax.Z);
  end;

  SetXSpeed(0.0);
  SetYSpeed(0.0);
  SetZSpeed(-60*3);
  SetVirtualPos(0, 0);
end;

procedure TGVStarfield.Done;
begin
  FStar := nil;
end;

procedure TGVStarfield.SetVirtualPos(aX, aY: Single);
begin
  FVirtualPos.X := aX;
  FVirtualPos.Y := aY;
  FVirtualPos.Z := 0;
end;

procedure TGVStarfield.GetVirtualPos(var aX: Single; var aY: Single);
begin
  aX := FVirtualPos.X;
  aY := FVirtualPos.Y;
end;

procedure TGVStarfield.SetXSpeed(aSpeed: Single);
begin
  FSpeed.X := aSpeed;
end;

procedure TGVStarfield.SetYSpeed(aSpeed: Single);
begin
  FSpeed.Y := aSpeed;
end;

procedure TGVStarfield.SetZSpeed(aSpeed: Single);
begin

  FSpeed.Z := aSpeed;
end;

procedure TGVStarfield.Update(aDeltaTime: Single);
var
  LI: Integer;

  procedure SetRandomPos(aIndex: Integer);
  begin
    FStar[aIndex].X := GV.Math.RandomRange(FMin.X, FMax.X);
    FStar[aIndex].Y := GV.Math.RandomRange(FMin.Y, FMax.Y);
    FStar[aIndex].Z := GV.Math.RandomRange(FMin.Z, FMax.Z);
  end;

begin

  for LI := 0 to FStarCount - 1 do
  begin
    FStar[LI].X := FStar[LI].X + (FSpeed.X * aDeltaTime);
    FStar[LI].Y := FStar[LI].Y + (FSpeed.Y * aDeltaTime);
    FStar[LI].Z := FStar[LI].Z + (FSpeed.Z * aDeltaTime);

    if FStar[LI].X < FMin.X then
    begin
      SetRandomPos(LI);
      FStar[LI].X := FMax.X;
    end;

    if FStar[LI].X > FMax.X then
    begin
      SetRandomPos(LI);
      FStar[LI].X := FMin.X;
    end;

    if FStar[LI].Y < FMin.Y then
    begin
      SetRandomPos(LI);
      FStar[LI].Y := FMax.Y;
    end;

    if FStar[LI].Y > FMax.Y then
    begin
      SetRandomPos(LI);
      FStar[LI].Y := FMin.Y;
    end;

    if FStar[LI].Z < FMin.Z then
    begin
      SetRandomPos(LI);
      FStar[LI].Z := FMax.Z;
    end;

    if FStar[LI].Z > FMax.Z then
    begin
      SetRandomPos(LI);
      FStar[LI].Z := FMin.Z;
    end;

  end;
end;

procedure TGVStarfield.Render;
var
  LI: Integer;
  LVPX, LVPY, LVPW, LVPH: Integer;
  LSize: TGVRectangle;
begin
  GV.Window.GetViewportSize(LSize);
  LVPX := Round(LSize.X);
  LVPY := Round(LSize.Y);
  LVPW := Round(LSize.Width);
  LVPH := Round(LSize.Height);
  for LI := 0 to FStarCount - 1 do
  begin
    TransformDrawPoint(FStar[LI].X, FStar[LI].Y, FStar[LI].Z, LVPX, LVPY, LVPW, LVPH);
  end;
end;

{ --- POLYGON --------------------------------------------------------------- }
{ TGVPolygon }
procedure TGVPolygon.Clear;
begin
  FSegment := nil;
  FWorldPoint := nil;
  FItemCount := 0;
end;

constructor TGVPolygon.Create;
begin
  inherited;
  Clear;
end;

destructor TGVPolygon.Destroy;
begin
  Clear;
  inherited;
end;

function TGVPolygon.Save(const aFilename: string): Boolean;
begin
  Result := False;
  // TODO:
end;

function TGVPolygon.Load(aArchive: TGVArchive; const aFilename: string): Boolean;
begin
  Result := False;
  // TODO:
end;

procedure TGVPolygon.CopyFrom(aPolygon: TGVPolygon);
var
  LI: Integer;
begin
  Clear;
  with TGVPolygon(aPolygon) do
  begin
    for LI := 0 to FItemCount - 1 do
    begin
      with FSegment[LI] do
      begin
        Self.AddLocalPoint(Round(Point.X), Round(Point.Y), Visible);
      end;
    end;
  end;
end;

procedure TGVPolygon.AddLocalPoint(aX: Single; aY: Single; aVisible: Boolean);
begin
  Inc(FItemCount);
  SetLength(FSegment, FItemCount);
  SetLength(FWorldPoint, FItemCount);
  FSegment[FItemCount - 1].Point.X := aX;
  FSegment[FItemCount - 1].Point.Y := aY;
  FSegment[FItemCount - 1].Visible := aVisible;
  FWorldPoint[FItemCount - 1].X := 0;
  FWorldPoint[FItemCount - 1].Y := 0;
end;

function  TGVPolygon.Transform(aX: Single; aY: Single; aScale: Single; aAngle: Single; aOrigin: PGVVector; aHFlip: Boolean; aVFlip: Boolean): Boolean;
var
  LI: Integer;
  LP: TGVVector;
begin
  Result := False;

  if FItemCount < 2 then
    Exit;

  for LI := 0 to FItemCount - 1 do
  begin
    // get local coord
    LP.X := FSegment[LI].Point.X;
    LP.Y := FSegment[LI].Point.Y;

    // move point to origin
    if aOrigin <> nil then
    begin
      LP.X := LP.X - aOrigin.X;
      LP.Y := LP.Y - aOrigin.Y;
    end;

    // horizontal flip
    if aHFlip then
    begin
      LP.X := -LP.X;
    end;

    // virtical flip
    if aVFlip then
    begin
      LP.Y := -LP.Y;
    end;

    // scale
    LP.X := LP.X * aScale;
    LP.Y := LP.Y * aScale;

    // rotate
    GV.Math.AngleRotatePos(aAngle, LP.X, LP.Y);

    // convert to world
    LP.X := LP.X + aX;
    LP.Y := LP.Y + aY;

    // set world point
    FWorldPoint[LI].X := LP.X;
    FWorldPoint[LI].Y := LP.Y;
  end;

  Result := True;
end;

procedure TGVPolygon.Render(aX: Single; aY: Single; aScale: Single; aAngle: Single; aThickness: Integer; aColor: TGVColor; aOrigin: PGVVector; aHFlip: Boolean; aVFlip: Boolean);
var
  LI: Integer;
begin
  if not Transform(aX, aY, aScale, aAngle, aOrigin, aHFlip, aVFlip) then Exit;

  // draw line segments
  for LI := 0 to FItemCount - 2 do
  begin
    if FSegment[LI].Visible then
    begin
      GV.Primitive.Line(FWorldPoint[LI].X, FWorldPoint[LI].Y, FWorldPoint[LI + 1].X, FWorldPoint[LI + 1].Y, aColor, aThickness);
    end;
  end;
end;

procedure TGVPolygon.SetSegmentVisible(aIndex: Integer; aVisible: Boolean);
begin
  FSegment[aIndex].Visible := True;
end;

function  TGVPolygon.GetSegmentVisible(aIndex: Integer): Boolean;
begin
  Result := FSegment[aIndex].Visible;
end;

function  TGVPolygon.GetPointCount: Integer;
begin
  Result := FItemCount;
end;

function  TGVPolygon.GetWorldPoint(aIndex: Integer): PGVVector;
begin
  Result := @FWorldPoint[aIndex];
end;

function  TGVPolygon.GetLocalPoint(aIndex: Integer): PGVVector;
begin
  Result := @FSegment[aIndex].Point;
end;


{ --- POLYPOINT ------------------------------------------------------------- }
{ PolyPointTrace  }
class function PolyPointTrace.IsNeighbour(X1, Y1, X2, Y2: Integer): Boolean;
begin
  Result := (Abs(X2 - X1) <= 1) and (Abs(Y2 - Y1) <= 1);
end;

class function PolyPointTrace.IsPixEmpty(Tex: TGVTexture; X, Y: Integer; W, H: Single): Boolean;
var
  LColor: TGVColor;
begin
  if (X < 0) or (Y < 0) or (X > W - 1) or (Y > H - 1) then
    Result := true
  else
  begin
    LColor := Tex.GetPixel(X, Y);
    Result := Boolean(LColor.alpha * 255 < mAlphaThreshold);
  end;
end;

// some point list functions
class procedure PolyPointTrace.AddPoint(X, Y: Integer);
var
  LL: Integer;
begin
  Inc(mPntCount);
  // L := Length(PolyArr);
  LL := High(mPolyArr) + 1;
  if LL < mPntCount then
    SetLength(mPolyArr, LL + mMaxStepBack);
  mPolyArr[mPntCount - 1].X := X;
  mPolyArr[mPntCount - 1].Y := Y;
end;

class procedure PolyPointTrace.DelPoint(Index: Integer);
var
  LI: Integer;
begin
  if mPntCount > 1 then
    for LI := Index to mPntCount - 2 do
      mPolyArr[LI] := mPolyArr[LI + 1];
  Dec(mPntCount);
end;

class function PolyPointTrace.IsInList(X, Y: Integer): Boolean;
var
  LI: Integer;
begin
  Result := False;
  for LI := 0 to mPntCount - 1 do
  begin
    Result := (mPolyArr[LI].X = X) and (mPolyArr[LI].Y = Y);
    if Result then
      Break;
  end;
end;

class procedure PolyPointTrace.FindStartingPoint(Tex: TGVTexture; var X, Y: Integer; W, H: Single);
var
  LI, LJ: Integer;
begin
  X := 1000000; // init X and Y with huge values
  Y := 1000000;
  // and simply find the non-zero point with lowest Y
  LI := 0;
  LJ := 0;
  while (X = 1000000) and (LI <= H) and (LJ <= W) do
  begin
    if not IsPixEmpty(Tex, LI, LJ, W, H) then
    begin
      X := LI;
      Y := LJ;
    end;
    Inc(LI);
    if LI = W then
    begin
      LI := 0;
      Inc(LJ);
    end;
  end;
  if X = 1000000 then
  begin
    // do something awful - texture is empty!
     //ShowMessage('do something awful - texture is empty!', [], SHOWMESSAGE_ERROR);
     raise Exception.Create('do something awful - texture is empty!');
  end;
end;

const
  // this is an order of looking for neighbour. Order is quite important
  Neighbours: array [1 .. 8, 1 .. 2] of Integer = ((0, -1), (-1, 0), (0, 1),
    (1, 0), (-1, -1), (-1, 1), (1, 1), (1, -1));

class function PolyPointTrace.CountEmptyAround(Tex: TGVTexture; X, Y: Integer; W, H: Single): Integer;
var
  LI: Integer;
begin
  Result := 0;
  for LI := 1 to 8 do
    if IsPixEmpty(Tex, X + Neighbours[LI, 1], Y + Neighbours[LI, 2], W, H) then
      Inc(Result);
end;

// finds nearest non-empty pixel with maximum empty neighbours which is NOT neighbour of some other pixel
// Returns true if found and XF,YF - coordinates
// This function may look odd but I need it for finding primary circumscribed poly which later will be
// simplified
class function PolyPointTrace.FindNearestButNotNeighbourOfOther(Tex: TGVTexture; Xs, Ys, XOther, YOther: Integer; var XF, YF: Integer; W, H: Single): Boolean;
var
  LI, LMaxEmpty, LE: Integer;
  LXt, LYt: Integer;
begin
  LMaxEmpty := 0;
  Result := False;
  for LI := 1 to 8 do
  begin
    LXt := Xs + Neighbours[LI, 1];
    LYt := Ys + Neighbours[LI, 2];
    // is it non-empty and not-a-neighbour point?
    if (not IsInList(LXt, LYt)) and (not IsNeighbour(LXt, LYt, XOther, YOther)) and
      (not IsPixEmpty(Tex, LXt, LYt, W, H)) then
    begin
      LE := CountEmptyAround(Tex, LXt, LYt, W, H); // ok. count empties around
      if LE > LMaxEmpty then // the best choice point has max empty neighbours
      begin
        XF := LXt;
        YF := LYt;
        LMaxEmpty := LE;
        Result := true;
      end;
    end;
  end;
end;

// simplifying procedures
class function PolyPointTrace.LineLength(X1, Y1, X2, Y2: Integer): Extended;
var
  LA, LB: Integer;
begin
  LA := Abs(X2 - X1);
  LB := Abs(Y2 - Y1);
  Result := Sqrt(LA * LA + LB * LB);
end;

//class function PolyPointTrace.TriangleSquare(X1, Y1, X2, Y2, X3, Y3: Integer): Extended;
//var
//  LP: Extended;
//  LA, LB, LC: Extended;
//begin
//  LA := LineLength(X1, Y1, X2, Y2);
//  LB := LineLength(X2, Y2, X3, Y3);
//  LC := LineLength(X3, Y3, X1, Y1);
//  LP := LA + LB + LC;
//  Result := Sqrt(LP * (LP - LA) * (LP - LB) * (LP - LC)); // using Heron's formula
//end;

// for alternate method simplifying I decided to use "thinness" of triangles
// the idea is that if square of triangle is small but his perimeter is big it means that
// triangle is "thin" - so it can be approximated to line
class function PolyPointTrace.TriangleThinness(X1, Y1, X2, Y2, X3, Y3: Integer): Extended;
var
  LP: Extended;
  LA, LB, LC, LS: Extended;
begin
  LA := LineLength(X1, Y1, X2, Y2);
  LB := LineLength(X2, Y2, X3, Y3);
  LC := LineLength(X3, Y3, X1, Y1);
  LP := LA + LB + LC;
  LS := Sqrt(LP * (LP - LA) * (LP - LB) * (LP - LC));
  // using Heron's formula to find triangle'LS square
  Result := LS / LP;
  // so if this result less than some Mju then we can approximate particular triangle
end;

class procedure PolyPointTrace.ApplyPolyPoint(aPolyPoint: TGVPolyPoint; aNum: Integer; aOrigin: PGVVector);
var
  LI: Integer;
begin
  for LI := 0 to mPntCount - 1 do
  begin
    aPolyPoint.AddPoint(aNum, mPolyArr[LI].X, mPolyArr[LI].Y, aOrigin);
  end;
end;

class procedure PolyPointTrace.Init(aMju: Extended = 6; aMaxStepBack: Integer = 10; aAlphaThreshold: Byte = 70);
begin
  Done;
  mMju := aMju;
  mMaxStepBack := aMaxStepBack;
  mAlphaThreshold := aAlphaThreshold;
end;

class procedure PolyPointTrace.Done;
begin
  mPntCount := 0;
  mPolyArr := nil;
end;

class function PolyPointTrace.GetPointCount: Integer;
begin
  Result := mPntCount;
end;

// primarily tracer procedure (gives too precise polyline - need to simplify later)
class procedure PolyPointTrace.PrimaryTrace(aTex: TGVTexture; aWidth, aHeight: Single);
var
  LI: Integer;
  LXn, LYn, LXnn, LYnn: Integer;
  LNextPointFound: Boolean;
  LBack: Integer;
  LLStepBack: Integer;
begin
  FindStartingPoint(aTex, LXn, LYn, aWidth, aHeight);
  LNextPointFound := LXn <> 1000000;
  LLStepBack := 0;
  while LNextPointFound do
  begin
    LNextPointFound := False;
    // checking if we got LBack to starting point...
    if not((mPntCount > 3) and IsNeighbour(LXn, LYn, mPolyArr[0].X, mPolyArr[0].Y))
    then
    begin
      if mPntCount > 7 then
        LBack := 7
      else
        LBack := mPntCount;
      if LBack = 0 then // no points in list - take any near point
        LNextPointFound := FindNearestButNotNeighbourOfOther(aTex, LXn, LYn, -100,
          -100, LXnn, LYnn, aWidth, aHeight)
      else
        // checking near but not going LBack
        for LI := 1 to LBack do
        begin
          LNextPointFound := FindNearestButNotNeighbourOfOther(aTex, LXn, LYn,
            mPolyArr[mPntCount - LI].X, mPolyArr[mPntCount - LI].Y, LXnn, LYnn, aWidth, aHeight);
          LNextPointFound := LNextPointFound and (not IsInList(LXnn, LYnn));
          if LNextPointFound then
            Break;
        end;
      AddPoint(LXn, LYn);
      if LNextPointFound then
      begin
        LXn := LXnn;
        LYn := LYnn;
        LLStepBack := 0;
      end
      else if LLStepBack < mMaxStepBack then
      begin
        LXn := mPolyArr[mPntCount - LLStepBack * 2 - 2].X;
        LYn := mPolyArr[mPntCount - LLStepBack * 2 - 2].Y;
        Inc(LLStepBack);
        LNextPointFound := true;
      end;
    end;
  end;
  // close the poly
  if mPntCount > 0 then
    AddPoint(mPolyArr[0].X, mPolyArr[0].Y);
end;

class procedure PolyPointTrace.SimplifyPoly;
var
  I: Integer;
  Finished: Boolean;
  Thinness: Extended;
begin
  Finished := False;
  while not Finished do
  begin
    I := 0;
    Finished := true;
    while I <= mPntCount - 3 do
    begin
      Thinness := TriangleThinness(mPolyArr[I].X, mPolyArr[I].Y, mPolyArr[I + 1].X,
        mPolyArr[I + 1].Y, mPolyArr[I + 2].X, mPolyArr[I + 2].Y);
      if Thinness < mMju then
      // the square of triangle is too thin - we can approximate it!
      begin
        DelPoint(I + 1); // so delete middle point
        Finished := False;
      end;
      Inc(I);
    end;
  end;
end;

{ TGVPolyPoint }
procedure TGVPolyPoint.Clear;
var
  LI: Integer;
begin
  for LI := 0 to Count - 1 do
  begin
    if Assigned(FPolygon[LI]) then
    begin
      FreeAndNil(FPolygon[LI]);
    end;
  end;
  FPolygon := nil;
  FCount := 0;
end;

constructor TGVPolyPoint.Create;
begin
  inherited;
  FPolygon := nil;
  FCount := 0;
end;

destructor TGVPolyPoint.Destroy;
begin
  Clear;
  inherited;
end;

function TGVPolyPoint.Save(const aFilename: string): Boolean;
begin
  Result := False;
  // TODO:
end;

function TGVPolyPoint.Load(aArchive: TGVArchive; const aFilename: string): Boolean;
begin
  Result := False;
  // TODO:
end;

function TGVPolyPoint.CopyFrom(aPolyPoint: TGVPolyPoint): Boolean;
begin
  Result := False;
  // TODO:
end;

procedure TGVPolyPoint.AddPoint(aNum: Integer; aX: Single; aY: Single; aOrigin: PGVVector);
var
  LX, LY: Single;
begin
  LX := aX;
  LY := aY;

  if aOrigin <> nil then
  begin
    LX := LX - aOrigin.X;
    LY := LY - aOrigin.Y;
  end;

  FPolygon[aNum].AddLocalPoint(LX, LY, True);
end;

function TGVPolyPoint.TraceFromTexture(aTexture: TGVTexture; aMju: Single; aMaxStepBack: Integer; aAlphaThreshold: Integer; aOrigin: PGVVector): Integer;
var
  LI: Integer;
  LW, LH: Single;
begin
  Inc(FCount);
  SetLength(FPolygon, FCount);
  LI := FCount - 1;
  FPolygon[LI] := TGVPolygon.Create;
  LW := aTexture.Width;
  LH := aTexture.Height;
  aTexture.Lock(nil);
  PolyPointTrace.Init(aMju, aMaxStepBack, aAlphaThreshold);
  PolyPointTrace.PrimaryTrace(aTexture, LW, LH);
  PolyPointTrace.SimplifyPoly;
  PolyPointTrace.ApplyPolyPoint(Self, LI, aOrigin);
  PolyPointTrace.Done;
  aTexture.Unlock;

  Result := LI;
end;

procedure TGVPolyPoint.TraceFromSprite(aSprite: TGVSprite; aGroup: Integer; aMju: Single; aMaxStepBack: Integer; aAlphaThreshold: Integer; aOrigin: PGVVector);
var
  LI: Integer;
  LRect: TGVRectangle;
  LTex: TGVTexture;
  LW, LH: Integer;
begin
  Clear;
  FCount := aSprite.GetImageCount(aGroup);
  SetLength(FPolygon, Count);
  for LI := 0 to Count - 1 do
  begin
    FPolygon[LI] := TGVPolygon.Create;
    LTex := TGVTexture(aSprite.GetImageTexture(LI, aGroup));
    LRect := aSprite.GetImageRect(LI, aGroup);
    LW := Round(LRect.width);
    LH := Round(LRect.height);
    LTex.Lock(@LRect);
    PolyPointTrace.Init(aMju, aMaxStepBack, aAlphaThreshold);
    PolyPointTrace.PrimaryTrace(LTex, LW, LH);
    PolyPointTrace.SimplifyPoly;
    PolyPointTrace.ApplyPolyPoint(Self, LI, aOrigin);
    PolyPointTrace.Done;
    LTex.Unlock;
  end;
end;

function TGVPolyPoint.Count: Integer;
begin
  Result := FCount;
end;

procedure TGVPolyPoint.Render(aNum: Integer; aX: Single; aY: Single; aScale: Single; aAngle: Single; aColor: TGVColor; aOrigin: PGVVector; aHFlip: Boolean; aVFlip: Boolean);
begin
  if aNum >= FCount then Exit;
  FPolygon[aNum].Render(aX, aY, aScale, aAngle, 1, aColor, aOrigin, aHFlip, aVFlip);
end;

function TGVPolyPoint.Collide(aNum1: Integer; aGroup1: Integer; aX1: Single; aY1: Single;
  aScale1: Single; aAngle1: Single; aOrigin1: PGVVector; aHFlip1: Boolean;
  aVFlip1: Boolean; aPolyPoint2: TGVPolyPoint; aNum2: Integer;
  aGroup2: Integer; aX2: Single; aY2: Single; aScale2: Single;
  aAngle2: Single; aOrigin2: PGVVector; aHFlip2: Boolean; aVFlip2: Boolean;
  var aHitPos: TGVVector): Boolean;
var
  LL1, LL2, LIX, LIY: Integer;
  LCnt1, LCnt2: Integer;
  LPos: array [0 .. 3] of PGVVector;
  LPoly1, LPoly2: TGVPolygon;
begin
  Result := False;

  if (aPolyPoint2 = nil) then Exit;

  LPoly1 := FPolygon[aNum1];
  LPoly2 := aPolyPoint2.Polygon(aNum2);

  // transform to world points
  LPoly1.Transform(aX1, aY1, aScale1, aAngle1, aOrigin1, aHFlip1, aVFlip1);
  LPoly2.Transform(aX2, aY2, aScale2, aAngle2, aOrigin2, aHFlip2, aVFlip2);

  LCnt1 := LPoly1.GetPointCount;
  LCnt2 := LPoly2.GetPointCount;

  if LCnt1 < 2 then Exit;
  if LCnt2 < 2 then Exit;

  for LL1 := 0 to LCnt1 - 2 do
  begin
    LPos[0] := LPoly1.GetWorldPoint(LL1);
    LPos[1] := LPoly1.GetWorldPoint(LL1 + 1);

    for LL2 := 0 to LCnt2 - 2 do
    begin

      LPos[2] := LPoly2.GetWorldPoint(LL2);
      LPos[3] := LPoly2.GetWorldPoint(LL2 + 1);
      if GV.Collision.LineIntersection(Round(LPos[0].X), Round(LPos[0].Y), Round(LPos[1].X),
        Round(LPos[1].Y), Round(LPos[2].X), Round(LPos[2].Y), Round(LPos[3].X),
        Round(LPos[3].Y), LIX, LIY) = TGVLineIntersection.Cross then
      begin
        aHitPos.X := LIX;
        aHitPos.Y := LIY;
        Result := True;
        Exit;
      end;
    end;
  end;
end;

function TGVPolyPoint.CollidePoint(aNum: Integer; aGroup: Integer; aX: Single;
  aY: Single; aScale: Single; aAngle: Single; aOrigin: PGVVector;
  aHFlip: Boolean; aVFlip: Boolean; var aPoint: TGVVector): Boolean;
var
  LL1, LIX, LIY: Integer;
  LCnt1: Integer;
  LPos: array [0 .. 3] of PGVVector;
  LPoint2: TGVVector;
  LPoly1: TGVPolygon;
begin
  Result := False;

  LPoly1 := FPolygon[aNum];

  // transform to world points
  LPoly1.Transform(aX, aY, aScale, aAngle, aOrigin, aHFlip, aVFlip);

  LCnt1 := LPoly1.GetPointCount;

  if LCnt1 < 2 then
    Exit;

  LPoint2.X := aPoint.X + 1;
  LPoint2.Y := aPoint.Y + 1;
  LPos[2] := @aPoint;
  LPos[3] := @LPoint2;

  for LL1 := 0 to LCnt1 - 2 do
  begin
    LPos[0] := LPoly1.GetWorldPoint(LL1);
    LPos[1] := LPoly1.GetWorldPoint(LL1 + 1);

    if GV.Collision.LineIntersection(Round(LPos[0].X), Round(LPos[0].Y), Round(LPos[1].X),
      Round(LPos[1].Y), Round(LPos[2].X), Round(LPos[2].Y), Round(LPos[3].X),
      Round(LPos[3].Y), LIX, LIY) = TGVLineIntersection.Cross then
    begin
      aPoint.X := LIX;
      aPoint.Y := LIY;
      Result := True;
      Exit;
    end;
  end;
end;

function TGVPolyPoint.Polygon(aNum: Integer): TGVPolygon;
begin
  Result := FPolygon[aNum];
end;

function TGVPolyPoint.Valid(aNum: Integer): Boolean;
begin
  Result := False;
  if aNum >= FCount then Exit;
  Result := Boolean(FPolygon[aNum].GetPointCount >= 2);
end;

{ --- SPRITE ---------------------------------------------------------------- }
{ TGVSprite }
constructor TGVSprite.Create;
begin
  inherited;
  FTexture := nil;
  FGroup := nil;
  FPageCount := 0;
  FGroupCount := 0;
end;

destructor TGVSprite.Destroy;
begin
  Clear;
  inherited;
end;

procedure TGVSprite.Clear;
var
  LI: Integer;
begin
  if FTexture <> nil then
  begin
    // free group data
    for LI := 0 to FGroupCount - 1 do
    begin
      // free image array
      FGroup[LI].Image := nil;

      // free polypoint
      FreeAndNil(FGroup[LI].PolyPoint);
    end;

    // free page
    for LI := 0 to FPageCount - 1 do
    begin
      if Assigned(FTexture[LI]) then
      begin
        FreeAndNil(FTexture[LI]);
      end;
    end;

    FTexture := nil;
    FGroup := nil;
    FPageCount := 0;
    FGroupCount := 0;
  end;
end;

function TGVSprite.LoadPage(aArchive: TGVArchive; const aFilename: string; aColorKey: PGVColor): Integer;
begin
  Result := FPageCount;
  Inc(FPageCount);
  SetLength(FTexture, FPageCount);
  FTexture[Result] := TGVTexture.Create;
  FTexture[Result].Load(aArchive, aFilename, aColorKey);
end;

function TGVSprite.AddGroup: Integer;
begin
  Result := FGroupCount;
  Inc(FGroupCount);
  SetLength(FGroup, FGroupCount);
  FGroup[Result].PolyPoint := TGVPolyPoint.Create;
end;

function TGVSprite.GetGroupCount: Integer;
begin
  Result := FGroupCount;
end;

function TGVSprite.AddImageFromRect(aPage: Integer; aGroup: Integer; aRect: TGVRectangle): Integer;
begin
  Result := FGroup[aGroup].Count;
  Inc(FGroup[aGroup].Count);
  SetLength(FGroup[aGroup].Image, FGroup[aGroup].Count);

  FGroup[aGroup].Image[Result].Rect.X := aRect.X;
  FGroup[aGroup].Image[Result].Rect.Y := aRect.Y;
  FGroup[aGroup].Image[Result].Rect.Width := aRect.Width;
  FGroup[aGroup].Image[Result].Rect.Height := aRect.Height;
  FGroup[aGroup].Image[Result].Page := aPage;
end;

function TGVSprite.AddImageFromGrid(aPage: Integer; aGroup: Integer; aGridX: Integer; aGridY: Integer; aGridWidth: Integer; aGridHeight: Integer): Integer;
begin
  Result := FGroup[aGroup].Count;
  Inc(FGroup[aGroup].Count);
  SetLength(FGroup[aGroup].Image, FGroup[aGroup].Count);

  FGroup[aGroup].Image[Result].Rect.X := aGridWidth * aGridX;
  FGroup[aGroup].Image[Result].Rect.Y := aGridHeight * aGridY;
  FGroup[aGroup].Image[Result].Rect.Width := aGridWidth;
  FGroup[aGroup].Image[Result].Rect.Height := aGridHeight;
  FGroup[aGroup].Image[Result].Page := aPage;
end;

function TGVSprite.GetImageCount(aGroup: Integer): Integer;
begin
  Result := FGroup[aGroup].Count;
end;

function TGVSprite.GetImageWidth(aNum: Integer; aGroup: Integer): Single;
begin
  Result := FGroup[aGroup].Image[aNum].Rect.Width;
end;

function TGVSprite.GetImageHeight(aNum: Integer; aGroup: Integer): Single;
begin
  Result := FGroup[aGroup].Image[aNum].Rect.Height;
end;

function TGVSprite.GetImageTexture(aNum: Integer; aGroup: Integer): TGVTexture;
begin
  Result := FTexture[FGroup[aGroup].Image[aNum].Page];
end;

function TGVSprite.GetImageRect(aNum: Integer; aGroup: Integer): TGVRectangle;
begin
  Result := FGroup[aGroup].Image[aNum].Rect;
end;

procedure TGVSprite.DrawImage(aNum: Integer; aGroup: Integer; aX: Single; aY: Single; aOrigin: PGVVector; aScale: PGVVector; aAngle: Single; aColor: TGVColor; aHFlip: Boolean; aVFlip: Boolean; aDrawPolyPoint: Boolean);
var
  LPageNum: Integer;
  LRectP: PGVRectangle;
  LOXY: TGVVector;
begin
  LRectP := @FGroup[aGroup].Image[aNum].Rect;
  LPageNum := FGroup[aGroup].Image[aNum].Page;
  FTexture[LPageNum].Draw(aX, aY, LRectP, aOrigin, aScale, aAngle, aColor, aHFlip, aVFlip);

  if aDrawPolyPoint then
  begin
    LOXY.X := 0;
    LOXY.Y := 0;
    if aOrigin <> nil then
    begin
      LOXY.X := FGroup[aGroup].Image[aNum].Rect.Width;
      LOXY.Y := FGroup[aGroup].Image[aNum].Rect.Height;

      LOXY.X := Round(LOXY.X * aOrigin.X);
      LOXY.Y := Round(LOXY.Y * aOrigin.Y);
    end;
    FGroup[aGroup].PolyPoint.Render(aNum, aX, aY, aScale.X, aAngle, YELLOW, @LOXY, aHFlip, aVFlip);
  end;
end;

function TGVSprite.GroupPolyPoint(aGroup: Integer): TGVPolyPoint;
begin
  Result := FGroup[aGroup].PolyPoint;
end;

procedure TGVSprite.GroupPolyPointTrace(aGroup: Integer; aMju: Single=6; aMaxStepBack: Integer=12; aAlphaThreshold: Integer=70; aOrigin: PGVVector=nil);
begin
  FGroup[aGroup].PolyPoint.TraceFromSprite(Self, aGroup, aMju, aMaxStepBack, aAlphaThreshold, aOrigin);
end;

function TGVSprite.GroupPolyPointCollide(aNum1: Integer; aGroup1: Integer;
  aX1: Single; aY1: Single; aScale1: Single; aAngle1: Single;
  aOrigin1: PGVVector; aHFlip1: Boolean; aVFlip1: Boolean; aSprite2: TGVSprite;
  aNum2: Integer; aGroup2: Integer; aX2: Single; aY2: Single;
  aScale2: Single; aAngle2: Single; aOrigin2: PGVVector; aHFlip2: Boolean;
  aVFlip2: Boolean; aShrinkFactor: Single; var aHitPos: TGVVector): Boolean;
var
  LPP1, LPP2: TGVPolyPoint;
  LRadius1: Integer;
  LRadius2: Integer;
  LOrigini1, LOrigini2: TGVVector;
  LOrigini1P, LOrigini2P: PGVVector;
begin
  Result := False;

  if (aSprite2 = nil) then
    Exit;

  LPP1 := FGroup[aGroup1].PolyPoint;
  LPP2 := aSprite2.FGroup[aGroup2].PolyPoint;

  if not LPP1.Valid(aNum1) then
    Exit;
  if not LPP2.Valid(aNum2) then
    Exit;

  LRadius1 := Round(FGroup[aGroup1].Image[aNum1].Rect.Height + FGroup[aGroup1]
    .Image[aNum1].Rect.Width) div 2;

  LRadius2 := Round(aSprite2.FGroup[aGroup2].Image[aNum2].Rect.Height +
    TGVSprite(aSprite2).FGroup[aGroup2].Image[aNum2].Rect.Width) div 2;

  if not GV.Collision.RadiusOverlap(LRadius1, aX1, aY1, LRadius2, aX2, aY2, aShrinkFactor) then Exit;

  LOrigini2.X := aSprite2.FGroup[aGroup2].Image[aNum2].Rect.Width;
  LOrigini2.Y := aSprite2.FGroup[aGroup2].Image[aNum2].Rect.Height;

  LOrigini1P := nil;
  if aOrigin1 <> nil then
  begin
    LOrigini1.X := Round(FGroup[aGroup1].Image[aNum1].Rect.Width * aOrigin1.X);
    LOrigini1.Y := Round(FGroup[aGroup1].Image[aNum1].Rect.Height * aOrigin1.Y);
    LOrigini1P := @LOrigini1;
  end;

  LOrigini2P := nil;
  if aOrigin2 <> nil then
  begin
    LOrigini2.X := Round(aSprite2.FGroup[aGroup2].Image[aNum2]
      .Rect.Width * aOrigin2.X);
    LOrigini2.Y := Round(aSprite2.FGroup[aGroup2].Image[aNum2]
      .Rect.Height * aOrigin2.Y);
    LOrigini2P := @LOrigini2;
  end;

  Result := LPP1.Collide(aNum1, aGroup1, aX1, aY1, aScale1, aAngle1, LOrigini1P,
    aHFlip1, aVFlip1, LPP2, aNum2, aGroup2, aX2, aY2, aScale2, aAngle2,
    LOrigini2P, aHFlip2, aVFlip2, aHitPos);
end;

function TGVSprite.GroupPolyPointCollidePoint(aNum: Integer; aGroup: Integer;
  aX: Single; aY: Single; aScale: Single; aAngle: Single; aOrigin: PGVVector;
  aHFlip: Boolean; aVFlip: Boolean; aShrinkFactor: Single;
  var aPoint: TGVVector): Boolean;
var
  LPP1: TGVPolyPoint;
  LRadius1: Integer;
  LRadius2: Integer;
  LOrigini1: TGVVector;
  LOrigini1P: PGVVector;
begin
  Result := False;

  LPP1 := FGroup[aGroup].PolyPoint;

  if not LPP1.Valid(aNum) then
    Exit;

  LRadius1 := Round(FGroup[aGroup].Image[aNum].Rect.Height + FGroup[aGroup].Image
    [aNum].Rect.Width) div 2;

  LRadius2 := 2;

  if not GV.Collision.RadiusOverlap(LRadius1, aX, aY, LRadius2, aPoint.X, aPoint.Y,
    aShrinkFactor) then
    Exit;

  LOrigini1P := nil;
  if aOrigin <> nil then
  begin
    LOrigini1.X := FGroup[aGroup].Image[aNum].Rect.Width * aOrigin.X;
    LOrigini1.Y := FGroup[aGroup].Image[aNum].Rect.Height * aOrigin.Y;
    LOrigini1P := @LOrigini1;
  end;

  Result := LPP1.CollidePoint(aNum, aGroup, aX, aY, aScale, aAngle, LOrigini1P,
    aHFlip, aVFlip, aPoint);
end;

{ --- ENTITY ---------------------------------------------------------------- }
{ TGVEntity }
constructor TGVEntity.Create;
begin
  inherited;
end;

destructor TGVEntity.Destroy;
begin
  inherited;
end;

procedure TGVEntity.Init(aSprite: TGVSprite; aGroup: Integer);
begin
  FSprite      := aSprite;
  FGroup       := aGroup;
  FFrame       := 0;
  FFrameFPS    := 15;
  FScale       := 1.0;
  FAngle       := 0;
  FAngleOffset := 0;
  FColor       := WHITE;
  FHFlip       := False;
  FVFlip       := False;
  FLoopFrame   := True;
  FRenderPolyPoint := False;
  FShrinkFactor:= 1.0;
  FOrigin.X := 0.5;
  FOrigin.Y := 0.5;
  FFrameTimer := 0;
  SetPosAbs(0, 0);
  SetFrameRange(0, aSprite.GetImageCount(FGroup)-1);
  SetFrame(FFrame);
end;

procedure TGVEntity.SetFrameRange(aFirst: Integer; aLast: Integer);
begin
  FFirstFrame := aFirst;
  FLastFrame  := aLast;
end;

function  TGVEntity.NextFrame: Boolean;
begin
  Result := False;
  if GV.Game.FrameSpeed(FFrameTimer, FFrameFPS) then
  begin
    Inc(FFrame);
    if FFrame > FLastFrame then
    begin
      if FLoopFrame then
        FFrame := FFirstFrame
      else
        FFrame := FLastFrame;
      Result := True;
    end;
  end;
  SetFrame(FFrame);
end;

function  TGVEntity.PrevFrame: Boolean;
begin
  Result := False;
  if GV.Game.FrameSpeed(FFrameTimer, FFrameFPS) then
  begin
    Dec(FFrame);
    if FFrame < FFirstFrame then
    begin
      if FLoopFrame then
        FFrame := FLastFrame
      else
        FFrame := FFirstFrame;
      Result := True;
    end;
  end;

  SetFrame(FFrame);
end;

function  TGVEntity.GetFrame: Integer;
begin
  Result := FFrame;
end;

procedure TGVEntity.SetFrame(aFrame: Integer);
var
  LW, LH, LR: Single;
begin
  if aFrame > FSprite.GetImageCount(FGroup)-1  then
    FFrame := FSprite.GetImageCount(FGroup)-1
  else
    FFrame := aFrame;

  LW := FSprite.GetImageWidth(FFrame, FGroup);
  LH := FSprite.GetImageHeight(FFrame, FGroup);

  LR := (LW + LH) / 2;

  FWidth  := LW * FScale;
  FHeight := LH * FScale;
  FRadius := LR * FScale;
end;

function  TGVEntity.GetFrameFPS: Single;
begin
  Result := FFrameFPS;
end;

procedure TGVEntity.SetFrameFPS(aFrameFPS: Single);
begin
  FFrameFPS := aFrameFPS;
  FFrameTimer := 0;
end;

function  TGVEntity.GetFirstFrame: Integer;
begin
  Result := FFirstFrame;
end;

function  TGVEntity.GetLastFrame: Integer;
begin
  Result := FLastFrame;
end;

procedure TGVEntity.SetPosAbs(aX: Single; aY: Single);
begin
  FPos.X := aX;
  FPos.Y := aY;
  FDir.X := 0;
  FDir.Y := 0;
end;

procedure TGVEntity.SetPosRel(aX: Single; aY: Single);
begin
  FPos.X := FPos.X + aX;
  FPos.Y := FPos.Y + aY;
  FDir.X := aX;
  FDir.Y := aY;
end;

function  TGVEntity.GetPos: TGVVector;
begin
  Result := FPos;
end;

function  TGVEntity.GetDir: TGVVector;
begin
  Result := FDir;
end;

procedure TGVEntity.SetScaleAbs(aScale: Single);
begin
  FScale := aScale;
  SetFrame(FFrame);
end;

procedure TGVEntity.SetScaleRel(aScale: Single);
begin
  FScale := FScale + aScale;
  SetFrame(FFrame);
end;

function  TGVEntity.GetAngle: Single;
begin
  Result := FAngle;
end;

function  TGVEntity.GetAngleOffset: Single;
begin
  Result := FAngleOffset;
end;

procedure TGVEntity.SetAngleOffset(aAngle: Single);
begin
  aAngle := aAngle + FAngleOffset;
  GV.Math.ClipValue(aAngle, 0, 360, True);
  FAngleOffset := aAngle;
end;

procedure TGVEntity.RotateAbs(aAngle: Single);
begin
  GV.Math.ClipValue(aAngle, 0, 360, True);
  FAngle := aAngle;
end;

procedure TGVEntity.RotateRel(aAngle: Single);
begin
  aAngle := aAngle + FAngle;
  GV.Math.ClipValue(aAngle, 0, 360, True);
  FAngle := aAngle;
end;

function  TGVEntity.RotateToAngle(aAngle: Single; aSpeed: Single): Boolean;
var
  Step: Single;
  Len : Single;
  S   : Single;
begin
  Result := False;
  Step := GV.Math.AngleDifference(FAngle, aAngle);
  Len  := Sqrt(Step*Step);
  if Len = 0 then
    Exit;
  S    := (Step / Len) * aSpeed;
  FAngle := FAngle + S;
  if GV.Math.SameValue(Step, 0, S) then
  begin
    RotateAbs(aAngle);
    Result := True;
  end;
end;

function  TGVEntity.RotateToPos(aX: Single; aY: Single; aSpeed: Single): Boolean;
var
  LAngle: Single;
  LStep: Single;
  LLen: Single;
  LS: Single;
  LTmpPos: TGVVector;
begin
  Result := False;
  LTmpPos.X  := aX;
  LTmpPos.Y  := aY;

  LAngle := -FPos.Angle(LTmpPos);
  LStep := GV.Math.AngleDifference(FAngle, LAngle);
  LLen  := Sqrt(LStep*LStep);
  if LLen = 0 then
    Exit;
  LS := (LStep / LLen) * aSpeed;

  if not GV.Math.SameValue(LStep, LS, aSpeed) then
    RotateRel(LS)
  else begin
    RotateRel(LStep);
    Result := True;
  end;
end;

function  TGVEntity.RotateToPosAt(aSrcX: Single; aSrcY: Single; aDestX: Single; aDestY: Single; aSpeed: Single): Boolean;
var
  LAngle: Single;
  LStep : Single;
  LLen  : Single;
  LS    : Single;
  LSPos,LDPos : TGVVector;
begin
  Result := False;
  LSPos.X := aSrcX;
  LSPos.Y := aSrcY;
  LDPos.X  := aDestX;
  LDPos.Y  := aDestY;

  LAngle := LSPos.Angle(LDPos);
  LStep := GV.Math.AngleDifference(FAngle, LAngle);
  LLen  := Sqrt(LStep*LStep);
  if LLen = 0 then
    Exit;
  LS := (LStep / LLen) * aSpeed;
  if not GV.Math.SameValue(LStep, LS, aSpeed) then
    RotateRel(LS)
  else begin
    RotateRel(LStep);
    Result := True;
  end;
end;

procedure TGVEntity.Thrust(aSpeed: Single);
var
  LA, LS: Single;
begin
  LA := FAngle + 90.0;
  GV.Math.ClipValue(LA, 0, 360, True);

  LS := -aSpeed;

  FDir.x := GV.Math.AngleCos(Round(LA)) * LS;
  FDir.y := GV.Math.AngleSin(Round(LA)) * LS;

  FPos.x := FPos.x + FDir.x;
  FPos.y := FPos.y + FDir.y;
end;

procedure TGVEntity.ThrustAngle(aAngle: Single; aSpeed: Single);
var
  LA, LS: Single;
begin
  LA := aAngle;

  GV.Math.ClipValue(LA, 0, 360, True);

  LS := -aSpeed;

  FDir.x := GV.Math.AngleCos(Round(LA)) * LS;
  FDir.y := GV.Math.AngleSin(Round(LA)) * LS;

  FPos.x := FPos.x + FDir.x;
  FPos.y := FPos.y + FDir.y;
end;

function  TGVEntity.ThrustToPos(aThrustSpeed: Single; aRotSpeed: Single; aDestX: Single; aDestY: Single; aSlowdownDist: Single; aStopDist: Single; aStopSpeed: Single; aStopSpeedEpsilon: Single; aDeltaTime: Single): Boolean;
var
  LDist : Single;
  LStep : Single;
  LSpeed: Single;
  LDestPos: TGVVector;
begin
  Result := False;

  if aSlowdownDist <= 0 then Exit;
  if aStopDist < 0 then aStopDist := 0;

  LDestPos.X := aDestX;
  LDestPos.Y := aDestY;
  LDist := FPos.Distance(LDestPos);

  LDist := LDist - aStopDist;

  if LDist > aSlowdownDist then
    begin
      LSpeed := aThrustSpeed;
    end
  else
    begin
      LStep := (LDist/aSlowdownDist);
      LSpeed := (aThrustSpeed * LStep);
      if LSpeed <= aStopSpeed then
      begin
        LSpeed := 0;
        Result := True;
      end;
    end;

  if RotateToPos(aDestX, aDestY, aRotSpeed*aDeltaTime) then
  begin
    Thrust(LSpeed*aDeltaTime);
  end;
end;

function  TGVEntity.IsVisible(aVirtualX: Single; aVirtualY: Single): Boolean;
var
  LHW,LHH: Single;
  LVPW,LVPH: Integer;
  LX,LY: Single;
  LSize: TGVRectangle;
begin
  Result := False;

  LHW := FWidth / 2;
  LHH := FHeight / 2;

  GV.Window.GetViewportSize(LSize);
  LVPW := Round(LSize.Width);
  LVPH := Round(LSize.Height);

  Dec(LVPW); Dec(LVPH);

  LX := FPos.X - aVirtualX;
  LY := FPos.Y - aVirtualY;

  if LX > (LVPW + LHW) then Exit;
  if LX < -LHW    then Exit;
  if LY > (LVPH + LHH) then Exit;
  if LY < -LHH    then Exit;

  Result := True;
end;

function  TGVEntity.IsFullyVisible(aVirtualX: Single; aVirtualY: Single): Boolean;
var
  LHW,LHH: Single;
  LVPW,LVPH: Integer;
  LX,LY: Single;
  LSize: TGVRectangle;
begin
  Result := False;

  LHW := FWidth / 2;
  LHH := FHeight / 2;

  GV.Window.GetViewportSize(LSize);
  LVPW := Round(LSize.Width);
  LVPH := Round(LSize.Height);

  Dec(LVPW); Dec(LVPH);

  LX := FPos.X - aVirtualX;
  LY := FPos.Y - aVirtualY;

  if LX > (LVPW - LHW) then Exit;
  if LX <  LHW       then Exit;
  if LY > (LVPH - LHH) then Exit;
  if LY <  LHH       then Exit;

  Result := True;
end;

function  TGVEntity.Overlap(aX: Single; aY: Single; aRadius: Single; aShrinkFactor: Single): Boolean;
var
  LDist: Single;
  LR1,LR2: Single;
  LV0,LV1: TGVVector;
begin
  LR1  := FRadius * aShrinkFactor;
  LR2  := aRadius * aShrinkFactor;

  LV0.X := FPos.X;
  LV0.Y := FPos.Y;

  LV1.x := aX;
  LV1.y := aY;

  LDist := LV0.Distance(LV1);

  if (LDist < LR1) or (LDist < LR2) then
    Result := True
  else
   Result := False;
end;

function  TGVEntity.Overlap(aEntity: TGVEntity): Boolean;
begin
  Result := Overlap(aEntity.GetPos.X, aEntity.GetPos.Y, aEntity.GetRadius, aEntity.GetShrinkFactor);
end;

procedure TGVEntity.Render(aVirtualX: Single; aVirtualY: Single);
var
  LX,LY: Single;
  LSV: TGVVector;
begin
  LX := FPos.X - aVirtualX;
  LY := FPos.Y - aVirtualY;
  LSV.Assign(FScale, FScale);
  FSprite.DrawImage(FFrame, FGroup, LX, LY, @FOrigin, @LSV, FAngle, FColor, FHFlip, FVFlip, FRenderPolyPoint);
end;

procedure TGVEntity.RenderAt(aX: Single; aY: Single);
var
  LSV: TGVVector;
begin
  LSV.Assign(FScale, FScale);
  FSprite.DrawImage(FFrame, FGroup, aX, aY, @FOrigin, @LSV, FAngle, FColor, FHFlip, FVFlip, FRenderPolyPoint);
end;

function  TGVEntity.GetSprite: TGVSprite;
begin
  Result := FSprite;
end;

function  TGVEntity.GetGroup: Integer;
begin
  Result := FGroup;
end;

function  TGVEntity.GetScale: Single;
begin
  Result := FScale;
end;

function  TGVEntity.GetColor: TGVColor;
begin
 Result := FColor;
end;

procedure TGVEntity.SetColor(aColor: TGVColor);
begin
  FColor := aColor;
end;

procedure TGVEntity.GetFlipMode(aHFlip: PBoolean; aVFlip: PBoolean);
begin
  if Assigned(aHFlip) then
    aHFlip^ := FHFlip;
  if Assigned(aVFlip) then
    aVFlip^ := FVFlip;
end;

procedure TGVEntity.SetFlipMode(aHFlip: PBoolean; aVFlip: PBoolean);
begin
  if aHFlip <> nil then
    FHFlip := aHFlip^;

  if aVFlip <> nil then
    FVFlip := aVFlip^;
end;

function  TGVEntity.GetLoopFrame: Boolean;
begin
  Result := FLoopFrame;
end;

procedure TGVEntity.SetLoopFrame(aLoop: Boolean);
begin
  FLoopFrame := aLoop;
end;

function  TGVEntity.GetWidth: Single;
begin
  Result := FWidth;
end;

function  TGVEntity.GetHeight: Single;
begin
  Result := FHeight;
end;

function  TGVEntity.GetRadius: Single;
begin
  Result := FRadius;
end;

function  TGVEntity.GetShrinkFactor: Single;
begin
  Result := FShrinkFactor;
end;

procedure TGVEntity.SetShrinkFactor(aShrinkFactor: Single);
begin
  FShrinkFactor := aShrinkFactor;
end;

procedure TGVEntity.SetRenderPolyPoint(aRenderPolyPoint: Boolean);
begin
  FRenderPolyPoint := aRenderPolyPoint;
end;

function  TGVEntity.GetRenderPolyPoint: Boolean;
begin
  Result := FRenderPolyPoint;
end;

procedure TGVEntity.TracePolyPoint(aMju: Single; aMaxStepBack: Integer; aAlphaThreshold: Integer; aOrigin: PGVVector);
begin
  FSprite.GroupPolyPointTrace(FGroup, aMju, aMaxStepBack, aAlphaThreshold, aOrigin);
end;

function  TGVEntity.CollidePolyPoint(aEntity: TGVEntity; var aHitPos: TGVVector): Boolean;
var
  LShrinkFactor: Single;
  LHFlip,LVFlip: Boolean;
begin
  LShrinkFactor := (FShrinkFactor + aEntity.GetShrinkFactor) / 2.0;

  aEntity.GetFlipMode(@LHFlip, @LVFlip);

  Result := FSprite.GroupPolyPointCollide(
    FFrame, FGroup, Round(FPos.X), Round(FPos.Y), FScale, FAngle, @FOrigin,
    FHFlip, FVFlip, aEntity.FSprite, aEntity.FFrame, aEntity.FGroup,
    Round(aEntity.FPos.X), Round(aEntity.FPos.Y), aEntity.FScale,
    aEntity.FAngle, @aEntity.FOrigin, LHFlip, LVFlip,
    LShrinkFactor, aHitPos);
end;

function  TGVEntity.CollidePolyPointPoint(var aPoint: TGVVector): Boolean;
var
  LShrinkFactor: Single;
begin
  LShrinkFactor := FShrinkFactor;

  Result := FSprite.GroupPolyPointCollidePoint(FFrame, FGroup, FPos.X, FPos.Y,
    FScale, FAngle, @FOrigin, FHFlip, FVFlip, LShrinkFactor, aPoint);
end;

{ --- CUSTOMGAME ------------------------------------------------------------ }
{ TGVCustomGame }
constructor TGVCustomGame.Create;
begin
  inherited;
  FOnPrint := nil;
end;

destructor TGVCustomGame.Destroy;
begin
  inherited;
end;

procedure TGVCustomGame.Print(const aMsg: string; const aArgs: array of const);
begin
  if Assigned(FOnPrint) then
    FOnPrint(aMsg, aArgs)
  else
    GV.Console.Print(aMsg, aArgs);
end;

procedure TGVCustomGame.PrintLn;
begin
  PrintLn('', []);
end;

procedure TGVCustomGame.PrintLn(const aMsg: string; const aArgs: array of const);
begin
  if Assigned(FOnPrint) then
    FOnPrint(aMsg, aArgs)
  else
    GV.Console.PrintLn(aMsg, aArgs);
end;

procedure TGVCustomGame.OnRun;
begin
end;

procedure TGVCustomGame.OnProcessCmdLine;
begin
end;

procedure TGVCustomGame.OnStartup;
begin
end;

procedure TGVCustomGame.OnShutdown;
begin
end;

{ --- GAME ------------------------------------------------------------------ }
procedure TGVGame.UpdateTiming;
begin
  FTimer.LNow := GetTime;
  FTimer.Passed := FTimer.LNow - FTimer.Last;
  FTimer.Last := FTimer.LNow;

  // process framerate
  Inc(FTimer.FrameCount);
  FTimer.FrameAccumulator := FTimer.FrameAccumulator + FTimer.Passed + GV_EPSILON;
  if FTimer.FrameAccumulator >= 1 then
  begin
    FTimer.FrameAccumulator := 0;
    FTimer.FrameRate := FTimer.FrameCount;
    FTimer.FrameCount := 0;
  end;

  // process variable update
  FTimer.Accumulator := FTimer.Accumulator + FTimer.Passed;
  while (FTimer.Accumulator >= FTimer.DeltaTime) do
  begin
    // process screen shakes
    GV.Screenshake.Process(FTimer.UpdateSpeed, FTimer.DeltaTime);

    // call herited update frame
    OnUpdateFrame(FTimer.DeltaTime);

    // call herited fixed update frame
    if FrameSpeed(FTimer.FixedUpdateTimer, FTimer.FixedUpdateSpeed) then
      OnFixedUpdateFrame;

    // update accumulator
    FTimer.Accumulator := FTimer.Accumulator - FTimer.DeltaTime;
  end;
end;

constructor TGVGame.Create;
begin
  inherited;
  // configfile
  FConfigFile := TGVConfigFile.Create;
  FConfigFile.Open;

  // inputmap
  FInputMap := TGVInputMap.Create;

  ResetTiming(60.0, 1.0);
  GV.FGame := Self;
end;

destructor TGVGame.Destroy;
begin
  FreeAndNil(FInputMap);
  FreeAndNil(FConfigFile);
  GV.FGame := nil;
  inherited;
end;

procedure TGVGame.OnPreStartup;
begin
end;

procedure TGVGame.OnPostStartup;
begin
end;

procedure TGVGame.OnLoadConfig;
begin
  // load settings
//  FSettings.WindowWidth := FConfigFile.GetValue('Settings', 'WindowWidth', 960);
//  FSettings.WindowHeight := FConfigFile.GetValue('Settings', 'WindowHeight', 540);
//  FSettings.WindowTitle := FConfigFile.GetValue('Settings', 'WindowTitle', FSettings.WindowTitle);
//  FConfigFile.GetValue('Settings', 'WindowClearColor', @FSettings.WindowClearColor, SizeOf(FSettings.WindowClearColor));
end;

procedure TGVGame.OnSaveConfig;
begin
  // save settings
//  FConfigFile.SetValue('Settings', 'WindowWidth', FSettings.WindowWidth);
//  FConfigFile.SetValue('Settings', 'WindowHeight', FSettings.WindowHeight);
//  FConfigFile.SetValue('Settings', 'WindowTitle', FSettings.WindowTitle) ;
//  FConfigFile.SetValue('Settings', 'WindowClearColor', @FSettings.WindowClearColor, SizeOf(FSettings.WindowClearColor));
end;

procedure TGVGame.OnSetSettings(var aSettings: TGVSettings);
begin
  // archive
  aSettings.ArchivePassword := '';
  aSettings.ArchiveFilename := '';

  // window settings
  aSettings.WindowWidth := 960;
  aSettings.WindowHeight := 540;
  aSettings.WindowTitle := 'GameVision Toolkit';
  aSettings.WindowClearColor := DARKSLATEBROWN;

  // font
  aSettings.FontFilename := '';
  aSettings.FontSize := 16;

  // hud
  aSettings.HudTextItemPadWidth := 10;
  aSettings.HudPosX := 3;
  aSettings.HudPosY := 3;
  aSettings.HudLineSpace := 0;
end;

procedure TGVGame.OnApplySettings;
begin
  // archive
  FArchive := TGVArchive.Create;
  FArchive.Open(FSettings.ArchivePassword, FSettings.ArchiveFilename);

  // window settings
  GV.Window.Open(FSettings.WindowWidth, FSettings.WindowHeight, FSettings.WindowTitle);

  // font
  FFont := TGVFont.Create;

  if (not FSettings.FontFilename.IsEmpty) and (FSettings.FontSize <> 0) then
    begin
      if not FFont.Load(FArchive, FSettings.FontSize, FSettings.FontFilename) then
        FFont.LoadDefault(FSettings.FontSize)
    end
  else
    if FSettings.FontSize > 0 then
      FFont.LoadDefault(FSettings.FontSize);

  // hud
  HudPos(FSettings.HudPosX, FSettings.HudPosY);
  HudLineSpace(FSettings.HudLineSpace);
  HudTextItemPadWidth(FSettings.HudTextItemPadWidth);

  // default inputmap
  // accept
  FInputMap.Add('accept', TGVInputMapDevice.Keyboard, KEY_ENTER);
  FInputMap.Add('accept', TGVInputMapDevice.Keyboard, KEY_PAD_ENTER);
  FInputMap.Add('accept', TGVInputMapDevice.Keyboard, KEY_SPACE);
  FInputMap.Add('accept', TGVInputMapDevice.Joystick, JOY_BTN_A);

  // select
  FInputMap.Add('select', TGVInputMapDevice.Keyboard, KEY_SPACE);
  FInputMap.Add('select', TGVInputMapDevice.Joystick, JOY_BTN_Y);

  // cancel
  FInputMap.Add('cancel', TGVInputMapDevice.Keyboard, KEY_ESCAPE);
  FInputMap.Add('cancel', TGVInputMapDevice.Joystick, JOY_BTN_B);

  // left
  FInputMap.Add('left', TGVInputMapDevice.Keyboard, KEY_LEFT);
  FInputMap.Add('left', TGVInputMapDevice.Joystick, JOY_BTN_LDPAD);
  FInputMap.Add('left', TGVInputMapDevice.Keyboard, KEY_A);

  // right
  FInputMap.Add('right', TGVInputMapDevice.Keyboard, KEY_RIGHT);
  FInputMap.Add('right', TGVInputMapDevice.Joystick, JOY_BTN_RDPAD);
  FInputMap.Add('right', TGVInputMapDevice.Keyboard, KEY_S);

  // up
  FInputMap.Add('up', TGVInputMapDevice.Keyboard, KEY_UP);
  FInputMap.Add('up', TGVInputMapDevice.Joystick, JOY_BTN_UDPAD);
  FInputMap.Add('up', TGVInputMapDevice.Keyboard, KEY_W);

  // down
  FInputMap.Add('down', TGVInputMapDevice.Keyboard, KEY_DOWN);
  FInputMap.Add('down', TGVInputMapDevice.Joystick, JOY_BTN_DDPAD);
  FInputMap.Add('down', TGVInputMapDevice.Keyboard, KEY_S);

  // pgup
  FInputMap.Add('pgup', TGVInputMapDevice.Keyboard, KEY_PGUP);

  // pgdn
  FInputMap.Add('pgdn', TGVInputMapDevice.Keyboard, KEY_PGDN);

  // home
  FInputMap.Add('home', TGVInputMapDevice.Keyboard, KEY_HOME);

  // end
  FInputMap.Add('end', TGVInputMapDevice.Keyboard, KEY_END);

  // init sprite
  FSprite := TGVSprite.Create;
end;

procedure TGVGame.OnUnApplySettings;
begin
  // sprite
  FreeAndNil(FSprite);

  // font
  FreeAndNil(FFont);

  // window settings
  GV.Window.Close;

  // archive
  FreeAndNil(FArchive);
end;

procedure TGVGame.OnStartup;
begin
  inherited;
  GV.Speech.Say('Hello World! Welcome to GameVision. Game development for Delphi, easy, fast, fun.', True);
end;

procedure TGVGame.OnShutdown;
begin
  inherited;
end;

procedure TGVGame.OnReady(aReady: Boolean);
begin
end;

procedure TGVGame.OnUpdateFrame(aDeltaTime: Double);
begin
  If FInputMap.Pressed('cancel') then
    SetTerminate(True);
end;

procedure TGVGame.OnFixedUpdateFrame;
begin
end;

procedure TGVGame.OnStartFrame;
begin
end;

procedure TGVGame.OnEndFrame;
begin
end;

procedure TGVGame.OnClearFrame;
begin
  GV.Window.Clear(FSettings.WindowClearColor);
end;

procedure TGVGame.OnRenderFrame;
begin
end;

procedure TGVGame.OnRenderHUD;
var
  LPos: TGVVector;
begin
  HudResetPos;
  HudText(FFont, WHITE, TGVHAlign.Left, 'fps %d', [GetFrameRate]);
  HudText(FFont, GREEN, TGVHAlign.Left, HudTextItem('ESC', 'Quit'), []);

  LPos.Assign(GV.Window.Width div 2, GV.Window.Height div 2, 0);
  FFont.PrintText(LPos.X, LPos.Y, 0, ORANGE, TGVHAlign.Center, 'Hello world, welcome to GameVision!', []);
end;

procedure TGVGame.OnShowFrame;
begin
  GV.Window.Show;
end;

procedure TGVGame.OnLoadVideo(const aFilename: string);
begin
end;

procedure TGVGame.OnUnloadVideo(const aFilename: string);
begin
end;

procedure TGVGame.OnStartVideo(const aFilename: string);
begin
end;

procedure TGVGame.OnFinishedVideo(const aFilename: string);
begin
end;

procedure TGVGame.OnSpeechWord(aFWord: string; aText: string);
begin
end;

procedure TGVGame.OnScreenshot(const aFilename: string);
begin
end;

function  TGVGame.GetTime: Double;
begin
  Result := al_get_time;
end;

procedure TGVGame.ResetTiming(aSpeed: Single; aFixedSpeed: Single);
begin
  FTimer.LNow := 0;
  FTimer.Passed := 0;
  FTimer.Last := 0;

  FTimer.Accumulator := 0;
  FTimer.FrameAccumulator := 0;

  FTimer.DeltaTime := 0;

  FTimer.FrameCount := 0;
  FTimer.FrameRate := 0;

  if aSpeed > 0 then
    SetUpdateSpeed(aSpeed)
  else
    SetUpdateSpeed(FTimer.UpdateSpeed);

  if aFixedSpeed > 0 then
    SetFixedUpdateSpeed(aFixedSpeed)
  else
    SetFixedUpdateSpeed(FTimer.FixedUpdateSpeed);

  FTimer.Last := GetTime;
end;

procedure TGVGame.SetUpdateSpeed(aSpeed: Single);
begin
  FTimer.UpdateSpeed := aSpeed;
  FTimer.DeltaTime := 1.0 / FTimer.UpdateSpeed;
end;

function  TGVGame.GetUpdateSpeed: Single;
begin
   Result := FTimer.UpdateSpeed;
end;

procedure TGVGame.SetFixedUpdateSpeed(aSpeed: Single);
begin
  FTimer.FixedUpdateSpeed := aSpeed;
  FTimer.FixedUpdateTimer := 0;
end;

function  TGVGame.GetFixedUpdateSpeed: Single;
begin
  Result := FTimer.FixedUpdateSpeed;
end;

function  TGVGame.GetDeltaTime: Double;
begin
  Result := FTimer.DeltaTime;
end;

function  TGVGame.GetFrameRate: Cardinal;
begin
  Result := FTimer.FrameRate;
end;

function  TGVGame.FrameSpeed(var aTimer: Single; aSpeed: Single): Boolean;
begin
  Result := False;
  aTimer := aTimer + (aSpeed / FTimer.UpdateSpeed);
  if aTimer >= 1.0 then
  begin
    aTimer := 0;
    Result := True;
  end;
end;

function  TGVGame.FrameElapsed(var aTimer: Single; aFrames: Single): Boolean;
begin
  Result := False;
  aTimer := aTimer + FTimer.DeltaTime;
  if aTimer > aFrames then
  begin
    aTimer := 0;
    Result := True;
  end;
end;

procedure TGVGame.SetTerminate(aTerminate: Boolean);
begin
  FTerminated := aTerminate;
end;

function  TGVGame.IsTerminated: Boolean;
begin
  Result := FTerminated;
end;

procedure TGVGame.HudResetPos;
begin
  HudPos(FSettings.HudPosX, FSettings.HudPosY);
end;

procedure TGVGame.HudPos(aX: Integer; aY: Integer);
begin
  FHud.Pos.Assign(aX, aY);
end;

procedure TGVGame.HudLineSpace(aLineSpace: Integer);
begin
  FHud.Pos.Z := aLineSpace;
end;

procedure TGVGame.HudTextItemPadWidth(aWidth: Integer);
begin
  FHud.TextItemPadWidth := aWidth;
end;

  procedure TGVGame.HudText(aFont: TGVFont; aColor: TGVColor; aAlign: TGVHAlign; const aMsg: string; const aArgs: array of const);
begin
  aFont.PrintText(FHud.Pos.X, FHud.Pos.Y, FHud.Pos.Z, aColor, aAlign, aMsg, aArgs);
end;

function  TGVGame.HudTextItem(const aKey: string; const aValue: string; const aSeperator: string='-'): string;
begin
  Result := Format('%s %s %s', [aKey.PadRight(FHud.TextItemPadWidth), aSeperator, aValue]);
end;

procedure TGVGame.OnRun;
var
  LCurrentTransform: ALLEGRO_TRANSFORM;
begin
  if not GV.Window.IsOpen then Exit;

  FTerminated := False;
  FReady := True;
  ResetTiming;

  while not FTerminated do
  begin
    repeat
      Sleep(0);
      GV.Util.ProcessMessages;

      if al_get_next_event(GV.Queue, GV.Event) then
      begin

        case GV.Event.type_ of
          ALLEGRO_EVENT_DISPLAY_CLOSE:
          begin
            FTerminated := True;
          end;

          ALLEGRO_EVENT_DISPLAY_RESIZE:
          begin
          end;

          ALLEGRO_EVENT_DISPLAY_DISCONNECTED,
          ALLEGRO_EVENT_DISPLAY_HALT_DRAWING,
          ALLEGRO_EVENT_DISPLAY_LOST,
          ALLEGRO_EVENT_DISPLAY_SWITCH_OUT:
          begin
            // clear input
            if GV.Event.type_ = ALLEGRO_EVENT_DISPLAY_SWITCH_OUT then
            begin
              GV.Input.Clear;
            end;

            // pause audio
            GV.Audio.Pause(True);

            // pause speech
            GV.Speech.Pause;

            // pause Video
            GV.Video.SetPause(True);

            // display not ready
            FReady := False;
            OnReady(FReady);
          end;

          ALLEGRO_EVENT_DISPLAY_CONNECTED,
          ALLEGRO_EVENT_DISPLAY_RESUME_DRAWING,
          ALLEGRO_EVENT_DISPLAY_FOUND,
          ALLEGRO_EVENT_DISPLAY_SWITCH_IN:
          begin
            // reset timing
            ResetTiming;

            // pause speech
            GV.Speech.Resume;

            // unpause audio
            GV.Audio.Pause(False);

            // unpause video
            GV.Video.SetPause(False);

            // display ready
            FReady := True;
            OnReady(FReady);
          end;

          ALLEGRO_EVENT_VIDEO_FINISHED:
          begin
            GV.Video.OnFinished(PALLEGRO_VIDEO(GV.Event.user.data1));
          end;
        end;

        // process input
        GV.Input.Update;
        GV.Input.GetMouseInfo(@FMousePos, @FMouseDelta, @FMousePressure);

      end;
    until al_is_event_queue_empty(GV.Queue);

    if FReady then
      begin
        GV.Async.Process;
        OnStartFrame;
        GV.Audio.Update;
        UpdateTiming;
        OnClearFrame;
        OnRenderFrame;
        LCurrentTransform := al_get_current_transform^;
        GV.Window.ResetTransform;
        OnRenderHUD;
        al_use_transform(@LCurrentTransform);
        GV.Screenshot.Process;
        OnShowFrame;
        OnEndFrame;
      end
    else
      begin
        Sleep(1);
      end;
  end;

  GV.Audio.Clear;
  GV.Video.Unload;
end;


{ GVRunGame }
procedure GVRunGame(aGame: TGVCustomGameClass; aPause: Boolean=False);
const
  cMsg = 'An instance of this program is already running, terminating!';
var
  LCustomGame: TGVCustomGame;

  // run custom game
  procedure RunCustomGame(aCustomGame: TGVCustomGame);
  begin
    aCustomGame.OnProcessCmdLine;
    aCustomGame.OnStartup;
    aCustomGame.OnRun;
    aCustomGame.OnShutdown;
  end;

  // run game
  procedure RunGame(aGame: TGVGame);
  begin
    aGame.OnProcessCmdLine;
    aGame.OnPreStartup;
    aGame.OnSetSettings(aGame.FSettings);
    aGame.OnLoadConfig;
    aGame.OnApplySettings;
    aGame.OnStartup;
    aGame.OnRun;
    aGame.OnShutdown;
    aGame.OnUnApplySettings;
    aGame.OnSaveConfig;
    aGame.OnPostStartup;
  end;

begin
  // report memory leaks
  ReportMemoryLeaksOnShutdown := True;

  // check for multiple instances
  if not TGVUtil.IsSingleInstance(TPath.GetFileName(ParamStr(0))) then
  begin
    if TGVConsole.IsPresent and TGVConsole.AtStartup then
      WriteLn(cMsg)
    else
      MessageBox(0, PChar(cMsg), 'Fatal Error', MB_ICONERROR);
    Exit;
  end;

  // exit if GV is already instantiated
  if GV <> nil then Exit;

  // create GV instance
  GV := TGV.Create;

  // create custom game
  LCustomGame := aGame.Create;

  // check if TGVCustome or TGVGame types
  if LCustomGame is TGVGame then
    // run TGVGame decendant
    RunGame(LCustomGame as TGVGame)
  else
    // run TGVCustomGame decendant
    RunCustomGame(LCustomGame);

  // free custom game
  FreeAndNil(LCustomGame);

  // check if should pause
  if aPause then GV.Console.Pause;

  // free & display of GV
  GV.Free;
  GV := nil;
end;


{ --- GV -------------------------------------------------------------------- }
{ TGV }
function TGV.GetEvent: PALLEGRO_EVENT;
begin
  Result := @FEvent;
end;

procedure TGV.AbortDLL;
begin
  MessageBox(0, 'Unable to initialize GameVision, terminating!', 'Fatal Error', MB_ICONERROR);
  Halt;
end;

procedure TGV.LoadDLL;
begin
  // load clibs dll
  FDllHandle := SafeLoadLibrary('GameVision.dll');
  if FDllHandle = 0 then AbortDLL;
  GetExports(FDLLHandle);
  GetPasLibsExports(FDLLHandle);
end;

procedure TGV.UnloadDLL;
begin
  if FDllHandle <> 0 then
  begin
    FreeLibrary(FDllHandle);
    FDllHandle := 0;
  end;
end;

procedure TGV.StartupAllegro;
begin
  if al_is_system_installed then Exit;

  // init allegro
  al_install_system(ALLEGRO_VERSION_INT, nil);

  // init devices
  al_install_joystick;
  al_install_keyboard;
  al_install_mouse;
  al_install_touch_input;
  al_install_audio;

  // init addons
  al_init_acodec_addon;
  al_init_font_addon;
  al_init_image_addon;
  al_init_native_dialog_addon;
  al_init_primitives_addon;
  al_init_ttf_addon;
  al_init_video_addon;

  // init event queues
  FQueue := al_create_event_queue;
  al_register_event_source(FQueue, al_get_joystick_event_source);
  al_register_event_source(FQueue, al_get_keyboard_event_source);
  al_register_event_source(FQueue, al_get_mouse_event_source);
  al_register_event_source(FQueue, al_get_touch_input_event_source);
  al_register_event_source(FQueue, al_get_touch_input_mouse_emulation_event_source);

  // init audio
  if al_is_audio_installed then
  begin
    FVoice := al_create_voice(44100, ALLEGRO_AUDIO_DEPTH_INT16,  ALLEGRO_CHANNEL_CONF_2);
    FMixer := al_create_mixer(44100, ALLEGRO_AUDIO_DEPTH_FLOAT32,  ALLEGRO_CHANNEL_CONF_2);
    al_set_default_mixer(FMixer);
    al_attach_mixer_to_voice(FMixer, FVoice);
    al_reserve_samples(AUDIO_MAX_CHANNELS);
  end;

  // init physfs
  al_store_state(@FFileState[False], ALLEGRO_STATE_NEW_FILE_INTERFACE);
  PHYSFS_init(nil);
  al_set_physfs_file_interface;
  al_store_state(@FFileState[True], ALLEGRO_STATE_NEW_FILE_INTERFACE);
  //PHYSFS_mount(LMarsaller.AsUtf8(TPath.GetDirectoryName(ParamStr(0))).ToPointer, '', 1);
  //PHYSFS_mount('./', '', 1);
end;

procedure TGV.ShutdownAllegro;
begin
  if not al_is_system_installed then Exit;

  // shutdown physfs
  al_set_standard_file_interface;
  PHYSFS_deinit;

  // shutdown audio
  if al_is_audio_installed then
  begin
    al_stop_samples;
    al_detach_mixer(FMixer);
    al_destroy_mixer(FMixer);
    al_destroy_voice(FVoice);
    al_uninstall_audio;
  end;

  // shutdown event queues
  if al_is_event_source_registered(FQueue, al_get_touch_input_mouse_emulation_event_source) then
    al_unregister_event_source(FQueue, al_get_touch_input_mouse_emulation_event_source);

  if al_is_event_source_registered(FQueue, al_get_touch_input_event_source) then
    al_unregister_event_source(FQueue, al_get_touch_input_event_source);

  if al_is_event_source_registered(FQueue, al_get_keyboard_event_source) then
    al_unregister_event_source(FQueue, al_get_keyboard_event_source);

  if al_is_event_source_registered(FQueue, al_get_mouse_event_source) then
    al_unregister_event_source(FQueue, al_get_mouse_event_source);

  if al_is_event_source_registered(FQueue, al_get_joystick_event_source) then
    al_unregister_event_source(FQueue, al_get_joystick_event_source);

  // shutdown devices
  if al_is_touch_input_installed then
    al_uninstall_touch_input;

  if al_is_mouse_installed then
    al_uninstall_mouse;

  if al_is_keyboard_installed then
    al_uninstall_keyboard;

  if al_is_joystick_installed then
    al_uninstall_joystick;

  if al_is_system_installed then
    al_uninstall_system;
end;

constructor TGV.Create;
begin
  inherited;
  GV := Self;
  FCodePage := GetConsoleOutputCP;
  SetConsoleOutputCP(WinApi.Windows.CP_UTF8);
  FMasterObjectList := TGVObjectList.Create;
  FUtil := TGVUtil.Create;
  FConsole := TGVConsole.Create;
  FLogger := TGVLogger.Create;
  FCmdLine := TGVCmdLine.Create;
  FUserPath := TGVUserPath.Create;
  LoadDLL;
  StartupAllegro;
  FWindow := TGVWindow.Create;
  FPrimitive := TGVPrimitive.Create;
  FInput := TGVInput.Create;
  FAudio := TGVAudio.Create;
  FVideo := TGVVideo.Create;
  FMath := TGVMath.Create;
  FCollision := TGVCollision.Create;
  FSpeech := TGVSpeech.Create;
  FAsync := TGVAsync.Create;
  FScreenshot := TGVScreenshot.Create;
  FScreenshake := TGVScreenshake.Create;
end;

destructor TGV.Destroy;
begin
  FreeAndNil(FScreenshot);
  FreeAndNil(FScreenshake);
  FreeAndNil(FAsync);
  FreeAndNil(FSpeech);
  FreeAndNil(FCollision);
  FreeAndNil(FMath);
  FreeAndNil(FVideo);
  FreeAndNil(FAudio);
  FreeAndNil(FInput);
  FreeAndNil(FPrimitive);
  FreeAndNil(FWindow);
  ShutdownAllegro;
  UnLoadDLL;
  FreeAndNil(UserPath);
  FreeAndNil(FCmdLine);
  FreeAndNil(FLogger);
  FreeAndNil(FConsole);
  FreeAndNil(FUtil);
  FreeAndNil(FMasterObjectList);
  SetConsoleOutputCP(FCodePage);
  GV := nil;
  inherited;
end;

procedure TGV.Run(aGame: TGVCustomGameClass);
var
  LGame: TGVCustomGame;
begin
  LGame := aGame.Create;
  LGame.OnProcessCmdLine;
  LGame.OnStartup;
  LGame.OnRun;
  LGame.OnShutdown;
  FreeAndNil(LGame);
end;

procedure TGV.Run(aGame: TGVGameClass);
var
  LGame: TGVGame;
begin
  LGame := aGame.Create;
  LGame.OnProcessCmdLine;
  LGame.OnPreStartup;
  LGame.OnSetSettings(LGame.FSettings);
  LGame.OnLoadConfig;
  LGame.OnApplySettings;
  LGame.OnStartup;
  LGame.OnRun;
  LGame.OnShutdown;
  LGame.OnUnApplySettings;
  LGame.OnSaveConfig;
  LGame.OnPostStartup;
  FreeAndNil(LGame);
end;

procedure TGV.SetFileSandBoxed(aEnable: Boolean);
begin
  al_restore_state(@FFileState[aEnable]);
end;

function  TGV.GetFileSandBoxed: Boolean;
begin
  Result := Boolean(al_get_new_file_interface = @FFileState[True]);
end;

procedure TGV.SetFileSandboxWriteDir(aPath: string);
var
  LMarshaller: TMarshaller;
begin
  PHYSFS_setWriteDir(LMarshaller.AsUtf8(aPath).ToPointer);
end;

function  TGV.GetFileSandboxWriteDir: string;
begin
  Result := string(PHYSFS_getWriteDir);
end;


{$ENDREGION}

end.
